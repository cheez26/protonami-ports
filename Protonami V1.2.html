<head><title>Protonami</title><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=DotGothic16"></head><body style="background-color: black; margin: 0px; display: flex; align-items: center; justify-content: center;"><canvas id="myCanvas" style="border: 1px solid white"></canvas><canvas id="sprites" width="400" height="2000" style="position: absolute; top: -4000px;"></canvas><script>
        window.onbeforeunload = function (e) {
            e = e || window.event;
            // For IE and Firefox prior to version 4
            if (e) {
                e.returnValue = 'Are you sure you want to close? Your progress will be lost.';
            }
            return 'Are you sure you want to close? Your progress will be lost.';
        };
    class Game {

    static get PLAY_MODE() {
        return 'play';
    }

    static get BUILD_MODE() {
        return 'build';
    }

    static staticConstructor() {
        this.playMode = this.PLAY_MODE;
    }

    static executeGameMode(){
        if (this.playMode === this.PLAY_MODE) {
            window.requestAnimationFrame(play);
        }
        else if (this.playMode === this.BUILD_MODE) {
            window.requestAnimationFrame(build);
        }
    }

    static changeGameMode() {
        const canvas = document.getElementById("myCanvas");
        
        if (this.playMode === this.PLAY_MODE) {
            this.playMode = this.BUILD_MODE;
            this.executeGameMode();
            canvas.addEventListener("mousemove",  (e) => {Controller.mouseMove(e)});
            document.getElementById("changeGameMode").innerHTML = 'Play';
            LevelSizeHandler.toggleSliderDisableAttr(false);
            tileMapHandler?.resetDynamicObjects();
            return null;
        }
        if (this.playMode === this.BUILD_MODE) {
            this.playMode = this.PLAY_MODE;
            this.executeGameMode();
            canvas.removeEventListener("mousemove", (e) => {Controller.mouseMove(e)});
            document.getElementById("changeGameMode").innerHTML = 'Stop';
            LevelSizeHandler.toggleSliderDisableAttr(true);
            return null;
        }
    }
}class Display {

    static staticConstructor(canvas, canvasWidth, canvasHeight) {
        this.ctx = canvas;
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
    }

    static drawLine(x, y, endX, endY, color = "000000", strokeWidth = 1, ctx = this.ctx) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(endX, endY);
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = '#' + color;
        ctx.stroke();
    }

    static drawRectangle(x, y, width, height, color = "000000", ctx = this.ctx) {
        ctx.beginPath();
        ctx.rect(Math.round(x), Math.round(y), width, height);
        ctx.fillStyle = "#" + color;
        ctx.fill();
        ctx.closePath();
    }

    static drawRectangleWithAlpha(x, y, width, height, color = "000000", ctx = this.ctx, alpha = 0) {
        this.ctx.globalAlpha = alpha;
        this.drawRectangle(x, y, width, height, color, ctx = this.ctx);
        this.ctx.globalAlpha = 1;
    }

    static drawRectangleBorder(x, y, width, height, color = "000000", lineWidth = 1, ctx = this.ctx) {
        ctx.beginPath();
        ctx.rect(Math.round(x), Math.round(y), width, height);
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = "#" + color;
        ctx.stroke();
        ctx.closePath();
    }

    static drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh) {
        this.ctx.drawImage(
            img,
            Math.round(sx),
            Math.round(sy),
            sw,
            sh,
            dx,
            dy,
            dw,
            dh);
    }

    static drawImageWithRotation(img, sx, sy, sw, sh, dx, dy, dw, dh, radians = 0) {
        if (radians === 0) {
            this.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
        }
        else {
            const halfImageWidth = dw / 2;
            const halfImageHeight = dh / 2;
            this.ctx.translate(dx + halfImageWidth, dy + halfImageHeight);
            this.ctx.rotate(radians);
            this.ctx.drawImage(
                img,
                Math.round(sx),
                Math.round(sy),
                sw,
                sh,
                -halfImageWidth,
                -halfImageHeight,
                dw,
                dh);
            this.ctx.rotate(-radians);
            this.ctx.translate(-dx - halfImageWidth, -dy - halfImageHeight);
        }
    }

    static drawImageWithAlpha(img, sx, sy, sw, sh, dx, dy, dw, dh, alpha) {
        this.ctx.globalAlpha = alpha;
        this.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
        this.ctx.globalAlpha = 1;
    }

    static displayFleshlight(playerx, playery, radius = 200, flicker = false) {
        var radius = flicker ? MathHelpers.getRandomNumberBetweenTwoNumbers(radius / 1.4, radius) : radius;
        this.ctx.fillStyle = "#" + WorldDataHandler.backgroundColor;
        this.ctx.beginPath();
        this.ctx.rect(Camera.viewport.left, Camera.viewport.top, Camera.viewport.width, Camera.viewport.height);
        this.ctx.arc(playerx, playery, radius, 0, 2 * Math.PI, true);
        this.ctx.fill();
        this.ctx.beginPath();
        var radialGradient = this.ctx.createRadialGradient(playerx, playery, 1, playerx, playery, radius);
        //calculating ligher color and converting hext to rgb needs to be done once, while adding shader
        const lighterColor = AnimationHelper.lightenDarkenColor(WorldDataHandler.backgroundColor, 70);
        const lightResult = AnimationHelper.hexToRGB(lighterColor)
        radialGradient.addColorStop(0, `rgba(${lightResult.r},${lightResult.g},${lightResult.b},0.1)`);
        const result = AnimationHelper.hexToRGB(WorldDataHandler.backgroundColor)
        radialGradient.addColorStop(1, `rgba(${result.r},${result.g},${result.b},0.9)`);
        this.ctx.fillStyle = radialGradient;
        this.ctx.arc(playerx, playery, radius, 0, Math.PI * 2, false);
        this.ctx.fill();
        this.ctx.closePath();
    }

    static displayBackgroundSFX(currentFrame, intensity = 8, tileSize = 24, xSpeed, ySpeed, duration = 24, growAmountByStep = 1.5) {
        if (currentFrame % intensity === 0) {
            const { left, top, width, height } = Camera.viewport;
            SFXHandler.createSFX(MathHelpers.getRandomNumberBetweenTwoNumbers(left + tileSize, left + width - tileSize),
                MathHelpers.getRandomNumberBetweenTwoNumbers(top + tileSize, top + height - tileSize),
                5, AnimationHelper.facingDirections.bottom, xSpeed,
                ySpeed, true, duration, growAmountByStep);
        }
    }

    static drawPixelArray(pixelArray, x, y, pixelArrayUnitSize, pixelArrayUnitAmount, ctx = this.ctx) {
        if (pixelArray) {
            for (var pixelArrayPosY = 0; pixelArrayPosY < pixelArrayUnitAmount; pixelArrayPosY++) {
                for (var pixelArrayPosX = 0; pixelArrayPosX < pixelArrayUnitAmount; pixelArrayPosX++) {
                    const color = pixelArray[pixelArrayPosY][pixelArrayPosX];
                    color !== 0 && color !== "transp" &&
                        this.drawRectangle(x + pixelArrayPosX * pixelArrayUnitSize, y + pixelArrayPosY * pixelArrayUnitSize,
                            Math.round(pixelArrayUnitSize), Math.round(pixelArrayUnitSize), color, ctx);
                }
            }
        }
    }

    static drawGrid(width, height, distance, color = '383838', strokeWidth = 1, ctx = this.ctx) {
        for (var i = 0; i < width; i++) {
            this.drawLine(i * distance, 0, i * distance, height * distance, color, strokeWidth, ctx);
        }

        for (var j = 0; j < height; j++) {
            this.drawLine(0, j * distance, width * distance, j * distance, color, strokeWidth, ctx);
        }
    }

    static displayLoadingScreen(loadedAssets, soundsLength) {
        const loadingBarWidth = this.canvasWidth / 3;
        const loadingBarHeight = 20;
        const leftPos = this.canvasWidth / 2 - loadingBarWidth / 2;
        const topPos = this.canvasHeight / 2 - loadingBarHeight / 2;
        const progressPadding = 5;
        this.drawRectangleBorder(leftPos, topPos,
            loadingBarWidth, loadingBarHeight, WorldDataHandler.textColor);
        const progressWidth = (loadingBarWidth - progressPadding * 2) / soundsLength * loadedAssets;
        this.drawRectangle(leftPos + progressPadding, topPos + progressPadding,
            progressWidth, loadingBarHeight - progressPadding * 2, WorldDataHandler.textColor);
    }

    static displayStartScreen(currentGeneralFrame, maxFrames) {
        PlayMode.updateGeneralFrameCounter();
        const textColor = "#" + WorldDataHandler.textColor;
        this.displayText(WorldDataHandler.gamesName, this.canvasWidth / 2, this.canvasHeight / 2, 30, textColor);

        var moduloDivier = maxFrames / 3;
        if (currentGeneralFrame % moduloDivier < moduloDivier / 2) {
            this.displayText("Press enter to continue", this.canvasWidth / 2, this.canvasHeight / 2 + 40, 18, textColor);
        }
    }

    static measureText(text) {
        const measurements = this.ctx.measureText(text);
        return { width: measurements.width, height: measurements.height };
    }

    static displayEndingScreen(spriteCanvas, currentGeneralFrame, maxFrames) {
        PlayMode.updateGeneralFrameCounter();
        let totalCollectibles = 0;
        let collectedCollectibles = 0;

        WorldDataHandler.levels.forEach(level => {
            level.levelObjects.forEach(levelObject => {
                if (levelObject.type === ObjectTypes.COLLECTIBLE) {
                    totalCollectibles++;
                    if (levelObject.extraAttributes.collected) {
                        collectedCollectibles++;
                    }
                }
            })
        });
        const collectiblesExist = totalCollectibles > 0;
        const extraPadding = collectiblesExist ? 16 : 0;

        const textColor = "#" + WorldDataHandler.textColor;
        this.displayText(WorldDataHandler.endingMessage, this.canvasWidth / 2, this.canvasHeight / 2 - 36 - extraPadding, 30, textColor);
        let endTime = GameStatistics.getFinalTime() || "XX:XX:XX";
        let deathCounter = GameStatistics.deathCounter;
        let collectibleCollectedText = `- ${collectedCollectibles}/${totalCollectibles}`;
        
        this.displayText(`Time: ${endTime}`, this.canvasWidth / 2, this.canvasHeight / 2 + 4 - extraPadding, 18, textColor);
        this.displayText(`Deaths: ${deathCounter}`, this.canvasWidth / 2, this.canvasHeight / 2 + 34 - extraPadding, 18, textColor);
        if (collectiblesExist) {
            const spriteIndex = SpritePixelArrays.getIndexOfSprite(ObjectTypes.COLLECTIBLE);
            const { tileSize } = WorldDataHandler;
            const canvasYSpritePos = spriteIndex * tileSize;
            const collectibleCollectedTextLength = this.ctx.measureText(collectibleCollectedText).width;
            Display.drawImage(spriteCanvas, 0, canvasYSpritePos, tileSize, tileSize,
                this.canvasWidth / 2 - (collectibleCollectedTextLength / 2) - 15, this.canvasHeight / 2 + 54 - tileSize, tileSize, tileSize);
            this.displayText(collectibleCollectedText, this.canvasWidth / 2 + 15, this.canvasHeight / 2 + 48, 18, textColor);
        }
        var moduloDivier = maxFrames / 3;

        if (currentGeneralFrame % moduloDivier < moduloDivier / 2) {
            this.displayText("Press enter to restart", this.canvasWidth / 2, this.canvasHeight / 2 + 64 + extraPadding, 12, textColor);
        }
        if (Controller.enter && !PauseHandler.restartedGame) {
            PauseHandler.restartedGame = true;
            PauseHandler.currentRestartGameFrameCounter = PauseHandler.restartGameMaxFrames;
            SoundHandler.guiSelect.stopAndPlay();
        }
        PauseHandler.handleRestart();
    }

    static displayText(text = "", xPos, yPos, size = 30, color = "white", alignPos = "center") {
        this.ctx.font = size + "px DotGothic16";
        this.ctx.fillStyle = color;
        this.ctx.textAlign = alignPos;
        this.ctx.fillText(text, xPos, yPos);
    }

    static animateFade(currentFrame, totalFrames) {
        const percent = currentFrame / totalFrames * 100;
        const parcelAmount = 10;
        const parcelHeight = this.canvasHeight / parcelAmount;
        const widthParcelAmount = Math.ceil(this.canvasWidth / parcelHeight);

        for (var i = 0; i <= widthParcelAmount; i++) {
            for (var j = 0; j <= parcelAmount; j++) {
                const relativeWidth = parcelHeight / 100 * percent + 1;
                this.drawRectangle(i * parcelHeight + ((parcelHeight - relativeWidth) / 2) + Camera.viewport.left,
                    j * parcelHeight + ((parcelHeight - relativeWidth) / 2) + Camera.viewport.top,
                    relativeWidth,
                    relativeWidth);
            }
        }
    }
}class Camera {

    static staticConstructor(context, canvasWidth, canvasHeight, worldWidth, worldHeight) {
        this.follow = { x: 0, y: 0 };
        this.context = context;
        this.viewport = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            width: canvasWidth,
            halfWidth: canvasWidth / 2,
            height: canvasHeight,
            halfHeight: canvasHeight / 2,
            scale: [1.0, 1.0],
            worldWidth: worldWidth,
            worldHeight: worldHeight
        };
        this.moveTo(this.viewport.halfWidth, this.viewport.halfHeight);
        this.updateViewport();
    }

    static begin() {
        this.context.save();
        this.applyTranslation();
    }

    static end() {
        this.context.restore();
    }

    static applyTranslation() {
        this.context.translate(-this.viewport.left, -this.viewport.top);
    }

    static updateViewport() {
        this.viewport.left = this.follow.x - this.viewport.halfWidth;
        this.viewport.top = this.follow.y - this.viewport.halfHeight;
    }

    static zoomTo(z) {
        this.canvasWidth = z;
        this.updateViewport();
    }

    static followObject(x, y) {

        let newFollowX;
        let newFollowY;
        let positionChanged = false;

        newFollowX = this.outOfBoundsXCorrection(x);
        newFollowY = this.outOfBoundsYCorrection(y);

        if(newFollowX && newFollowX !== this.follow.x){
            this.follow.x = newFollowX;
            positionChanged= true;
        }
        if(newFollowY && newFollowY !== this.follow.y){
            this.follow.y = newFollowY;
            positionChanged= true;
        }
        if(positionChanged) {
            this.updateViewport();
        }
    }

    static outOfBoundsXCorrection(x) {
        if (x <= this.viewport.halfWidth) {
            return Math.round(this.viewport.halfWidth);
        }
        else if(x >= this.viewport.worldWidth - this.viewport.halfWidth) {
            return Math.round(this.viewport.worldWidth - this.viewport.halfWidth);
        }
        else {
            return Math.round(x);
        }
    }

    static outOfBoundsYCorrection(y) {
        if(y <= this.viewport.halfHeight){
            return Math.round(this.viewport.halfHeight);
        }
        else if(y >= this.viewport.worldHeight - this.viewport.halfHeight) {
            return Math.round(this.viewport.worldHeight - this.viewport.halfHeight);
        }
        else {
            return Math.round(y);
        }
    }

    static moveTo(x, y) {
        this.follow.x = this.outOfBoundsXCorrection(x);
        this.follow.y = this.outOfBoundsYCorrection(y);
        this.updateViewport();
    }

    static screenToWorld(x, y) {
        return { x: x - this.viewport.left, y: y - this.viewport.top };
    }

    static worldToScreen(x, y) {
        return { x: x + this.viewport.left, y: y + this.viewport.top };
    }
}class AnimationHelper {

    static staticConstructor() {
        this.walkingFrameDuration = 7;
        this.defaultFrameDuration = 20;
        this.facingDirections = {
            top: "top",
            right: "right",
            bottom: "bottom",
            left: "left",
        };
        this.switchableBlockColors = {
            red: "red",
            blue: "blue",
        }
        this.alignments = {
            vertical: "vertical",
            horizontal: "horizontal",
            corner: "corner"
        }
        this.pathVariants = {
            singlePoint: "singlePoint",
            line: "line",
            enclosed: "enclosed",
        }
        this.possibleDirections = {
            forwards: "forwards",
            backwards: "backwards"
        }
    }

    static lightenDarkenColor(col, amt) {
        var usePound = false;
        if (col[0] == "#") {
            col = col.slice(1);
            usePound = true;
        }

        var num = parseInt(col, 16);

        var r = (num >> 16) + amt;

        if (r > 255) r = 255;
        else if (r < 0) r = 0;

        var b = ((num >> 8) & 0x00FF) + amt;

        if (b > 255) b = 255;
        else if (b < 0) b = 0;

        var g = (num & 0x0000FF) + amt;

        if (g > 255) g = 255;
        else if (g < 0) g = 0;

        return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16);
    }

    static hexToRGB(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec("#" + hex);
        return result = {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        };
    }

    static setSquishValues(obj, squishWidth, squishHeight, squishFrames = 10, direction = this.facingDirections.bottom) {
        const spriteObject = obj.type === "player" ? obj?.spriteObject?.squishAble
            : obj?.spriteObject?.[0]?.squishAble;
        if (spriteObject) {
            let newSquishWidth = squishWidth;
            let newSquishHeight = squishHeight;
            if (direction === this.facingDirections.left ||
                direction === this.facingDirections.right) {
                newSquishWidth = squishHeight;
                newSquishHeight = squishWidth;
            }
            obj.squishWidth = newSquishWidth;
            obj.squishHeight = newSquishHeight;
            obj.squishWidthStep = (newSquishWidth - obj.drawWidth) / squishFrames;
            obj.squishHeightStep = (newSquishHeight - obj.drawHeight) / squishFrames;
        }
    }

    static checkSquishUpdate(obj) {
        if (obj.drawWidth !== obj.squishWidth) {
            obj.squishXOffset = (obj.drawWidth - obj.originalDrawWidth) / 2;
            obj.drawWidth += obj.squishWidthStep;
            if (obj.drawWidth >= obj.squishWidth && obj.squishWidthStep > 0 ||
                obj.drawWidth <= obj.squishWidth && obj.squishWidthStep < 0) {
                obj.drawWidth = obj.squishWidth;
                this.setSquishValues(obj, obj.originalDrawWidth, obj.originalDrawHeight);
            }
        }
        if (obj.drawHeight !== obj.squishHeight) {
            obj.drawHeight += obj.squishHeightStep;
            obj.squishYOffset = (obj.drawHeight - obj.originalDrawHeight);
            if (obj.drawHeight >= obj.squishHeight && obj.squishHeightStep > 0 ||
                obj.drawHeight <= obj.squishHeight && obj.squishHeightStep < 0) {
                obj.drawHeight = obj.squishHeight;
            }
        }
    }

    static setInitialSquishValues(obj) {
        obj.drawWidth = obj.tileSize;
        obj.drawHeight = obj.tileSize;
        obj.squishWidth = obj.tileSize;
        obj.squishHeight = obj.tileSize;
        obj.squishWidthStep = 0;
        obj.squishHeightStep = 0;
        obj.originalDrawWidth = obj.tileSize;
        obj.originalDrawHeight = obj.tileSize;
        obj.squishXOffset = 0;
        obj.squishYOffset = 0;
    }
}class Collision {

    static staticConstructor(tileMapHandler) {
        this.tileMapHandler = tileMapHandler;
    }

    static objectsColliding(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width + obj2.hitBoxOffset &&
            obj1.x + obj1.width > obj2.x - obj2.hitBoxOffset &&
            obj1.y < obj2.y + obj2.height + obj2.hitBoxOffset &&
            obj1.y + obj1.height > obj2.y - obj2.hitBoxOffset;
    }

    static pointAndObjectColliding(point, obj) {
        return point.x < obj.x + obj.width &&
        point.x > obj.x &&
        point.y < obj.y + obj.height &&
        point.y > obj.y;
    }
}class CharacterCollision {

    static staticConstructor(tileMapHandler) {
        this.tileMapHandler = tileMapHandler;
        this.passableTiles = [0, 5];
    }

    static checkHazardsCollision(obj) {
        this.tileMapHandler.levelObjects.forEach(levelObject => {
            if (Collision.objectsColliding(obj, levelObject)) {
                levelObject.collisionEvent();
            }
        });
    }

    static checkCollisionsWithWorld(obj, cornerCorrection = false) {
        this.checkHazardsCollision(obj);
        this.groundUnderFeet(obj);
        this.checkTileCollisions(obj, cornerCorrection);
    }

    static checkPointCollissionsWithAllObjects(positions, obj) {
        return this.tileMapHandler.levelObjects.find(levelObject => {
            if (obj.unpassableObjects.includes(levelObject.type) && levelObject.key !== obj.key) {
                return positions.find(position => {
                    return Collision.pointAndObjectColliding(position, levelObject);
                });
            }
        });
    }

    static checkMovementBasedObjectCollission(obj) {
        if (obj?.unpassableObjects) {
            if (obj.yspeed > 0) {
                const collidedWithObject = this.checkPointCollissionsWithAllObjects([obj.bottom_left_pos, obj.bottom_right_pos],
                    obj);
                if (collidedWithObject) {
                    obj.y = collidedWithObject.y - (obj.height);
                    obj.hitUnpassableObject(AnimationHelper.facingDirections.bottom, collidedWithObject);
                }
            }
            else if (obj.yspeed < 0) {
                const collidedWithObject = this.checkPointCollissionsWithAllObjects([obj.top_left_pos, obj.top_right_pos],
                    obj);
                if (collidedWithObject) {
                    obj.y = collidedWithObject.y + (obj.height);
                    obj.hitUnpassableObject(AnimationHelper.facingDirections.top, collidedWithObject);
                }
            }
            if (obj.xspeed < 0) {
                const collidedWithObject = this.checkPointCollissionsWithAllObjects([obj.bottom_left_pos, obj.top_left_pos],
                    obj);
                if (collidedWithObject) {
                    obj.x = collidedWithObject.x + (obj.width);
                    obj.hitUnpassableObject(AnimationHelper.facingDirections.left, collidedWithObject);
                }
            }
            else if (obj.xspeed > 0) {
                const collidedWithObject = this.checkPointCollissionsWithAllObjects([obj.top_right_pos, obj.bottom_right_pos],
                    obj);
                if (collidedWithObject) {
                    obj.x = collidedWithObject.x - (obj.width);
                    obj.hitUnpassableObject(AnimationHelper.facingDirections.right, collidedWithObject);
                }
            }
        }
    }

    static checkTileCollisions(obj, cornerCorrection = false) {
        obj.y += obj.yspeed;
        this.getEdges(obj);
        // collision to the bottom
        if (obj.yspeed > 0) {
            if ((obj.bottom_right !== 0)
                || (obj.bottom_left !== 0)) {
                // not a cloud...
                if (obj.bottom_right !== 5 &&
                    obj.bottom_left !== 5
                ) {
                    obj.y = obj.bottom * tileMapHandler.tileSize - (obj.height + 1);
                    obj.hitWall(AnimationHelper.facingDirections.bottom);

                } else {
                    //cloud
                    if (obj.prev_bottom < obj.bottom) {
                        obj.y = obj.bottom * tileMapHandler.tileSize - (obj.height + 1);
                        obj.hitWall(AnimationHelper.facingDirections.bottom);
                    }
                }
            }
        }
        // collision to the top
        else if (obj.yspeed < 0) {
            if (!this.passableTiles.includes(obj.top_right)
                || !this.passableTiles.includes(obj.top_left)) {
                cornerCorrection ? this.checkTopCornerCorrection(obj) : this.correctTopPosition(obj);
            }
        }

        obj.x += obj.xspeed;
        this.getEdges(obj);

        // collision to the left
        if (obj.xspeed < 0) {
            if (!this.passableTiles.includes(obj.top_left)
                || !this.passableTiles.includes(obj.bottom_left)) {
                obj.x = (obj.left + 1) * tileMapHandler.tileSize;
                obj.hitWall(AnimationHelper.facingDirections.left);
            }
        }

        // collision to the right
        else if (obj.xspeed > 0) {
            if (!this.passableTiles.includes(obj.top_right)
                || !this.passableTiles.includes(obj.bottom_right)) {
                obj.x = obj.right * tileMapHandler.tileSize - (obj.width + 1);
                obj.hitWall(AnimationHelper.facingDirections.right);
            }
        }

        obj.prev_bottom = obj.bottom;
    }

    static correctTopPosition(obj) {
        obj.y = obj.bottom * tileMapHandler.tileSize + 1;
        obj.hitWall(AnimationHelper.facingDirections.top)
    }

    static checkTopCornerCorrection(obj) {
        const offset = Math.floor(this.tileMapHandler.tileSize / 4)
        const topY = obj.top_right_pos.y - Math.floor(this.tileMapHandler.tileSize / 2);
        const rightX = obj.top_right_pos.x - offset;
        const leftX = obj.top_left_pos.x + offset;
        const rightTileVaue = tileMapHandler.getTileValueForPosition(rightX);
        const leftTileVaue = tileMapHandler.getTileValueForPosition(leftX);
        const topValue = tileMapHandler.getTileValueForPosition(topY);
        const topRightTileValue = tileMapHandler.getTileLayerValueByIndex(topValue, rightTileVaue);
        const topLeftTileValue = tileMapHandler.getTileLayerValueByIndex(topValue, leftTileVaue);
        const touchingSwitch = [obj.top_left, obj.top_right].includes(ObjectTypes.SPECIAL_BLOCK_VALUES.redBlueSwitch);
        if (!touchingSwitch && this.passableTiles.includes(topRightTileValue) && this.passableTiles.includes(obj.top_left)) {
            obj.x = rightTileVaue * this.tileMapHandler.tileSize;
        }
        else if (!touchingSwitch && this.passableTiles.includes(topLeftTileValue) && this.passableTiles.includes(obj.top_right)) {
            obj.x = leftTileVaue * this.tileMapHandler.tileSize + 1;
        }
        else {
            this.correctTopPosition(obj);
        }
    }

    static groundUnderFeet(obj) {
        const left_foot_x = this.tileMapHandler.getTileValueForPosition(obj.x);
        const right_foot_x = this.tileMapHandler.getTileValueForPosition(obj.x + obj.width);
        const foot_y = this.tileMapHandler.getTileValueForPosition(obj.y + (obj.height + 1));
        const left_foot = this.tileMapHandler.tileMap[foot_y][left_foot_x];
        const right_foot = this.tileMapHandler.tileMap[foot_y][right_foot_x];
        const current_tile = left_foot !== 0 ? left_foot : right_foot;

        switch (current_tile) {
            case 0:
                obj.speed = obj.air_acceleration;
                obj.friction = obj.air_friction;
                if (!Controller.jump || obj.jumpframes >= obj.maxJumpFrames || obj.jumpPressedToTheMax || PauseHandler.justClosedPauseScreen) {
                    obj.falling = true;
                }
                break;
            case 5:
                if (obj.yspeed < 0 &&
                    (!Controller.jump || obj.jumpframes >= obj.maxJumpFrames || obj.jumpPressedToTheMax)) {
                    obj.falling = true;
                }
                //if speed is 0, but player is somewhere in the middle of the 5 tile, not exactly on top
                if (obj.yspeed === 0 && (obj.y + obj.height + 1) % this.tileMapHandler.tileSize !== 0) {
                    obj.falling = true;
                }
                break;
            default:
                obj.speed = obj.groundAcceleration;
                obj.friction = obj.groundFriction;
                break;
        }
    }

    static getEdges(obj) {
        const hitBoxOffset = obj?.hitBoxOffset || 0;
        //Pixel values
        const rightX = obj.x + obj.width + hitBoxOffset;
        const leftX = obj.x - hitBoxOffset;
        const bottomY = obj.y + obj.height + hitBoxOffset;
        const topY = obj.y - hitBoxOffset;
        obj.top_right_pos = { x: rightX, y: topY };
        obj.top_left_pos = { x: leftX, y: topY };
        obj.bottom_right_pos = { x: rightX, y: bottomY };
        obj.bottom_left_pos = { x: leftX, y: bottomY };
        //Tile values
        obj.right = tileMapHandler.getTileValueForPosition(rightX);
        obj.left = tileMapHandler.getTileValueForPosition(leftX);
        obj.bottom = tileMapHandler.getTileValueForPosition(bottomY);
        obj.top = tileMapHandler.getTileValueForPosition(topY);
        obj.top_right = tileMapHandler.getTileLayerValueByIndex(obj.top, obj.right);
        obj.top_left = tileMapHandler.getTileLayerValueByIndex(obj.top, obj.left);
        obj.bottom_right = tileMapHandler.getTileLayerValueByIndex(obj.bottom, obj.right);
        obj.bottom_left = tileMapHandler.getTileLayerValueByIndex(obj.bottom, obj.left);
        obj?.wallJumpChecked && obj.checkWallJumpReady();
    }
}class WorldDataHandler {

    static staticConstructor() {
        this.initialPlayerPosition = { x: 2, y: 10 };
        this.levels = [this.createEmptyLevel(), this.exampleLevel(), this.createEmptyLevel()];
        this.tileSize = 24;
        this.gamesName = "Protonami";
        this.endingMessage = "Thanks for playing. <3";
        this.backgroundColor = '000000';
        this.textColor = 'ffffff';
    }

    static createEmptyLevel() {
        const tileData = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        return {
            tileData: tileData,
            levelObjects: [],
            deko: [],
            paths: [],
        };
    }

    static exampleLevel() {
        let exampleLevelTileData = this.createEmptyLevel().tileData;
        for(var i = 0; i < 6; i++) {
            exampleLevelTileData[11][i] = 2;
        }
        for(var i = exampleLevelTileData[0].length-1; i > exampleLevelTileData[0].length-7; i--) {
            exampleLevelTileData[6][i] = 2;
        }

        const levelObjects = [
            { ...this.initialPlayerPosition, type: ObjectTypes.START_FLAG },
            { x: exampleLevelTileData[0].length-3, y: 5, type: ObjectTypes.FINISH_FLAG }
        ];

        return {
            tileData: exampleLevelTileData,
            levelObjects: levelObjects,
            deko: [],
            paths: [],
        };
    }

    static calucalteCanvasSize() {
        return {
            width: this.levels[0].tileData[0].length * this.tileSize,
            height: this.levels[0].tileData.length * this.tileSize,
        }
    }
}class TileMapHandler {

    constructor(tileSize, startingLevel, spriteCanvas, player) {
        this.TILE_TYPES = {}
        SpritePixelArrays.allTileSprites().forEach(sprite => {
            this.TILE_TYPES[sprite.name] = SpritePixelArrays.getIndexOfSprite(sprite.name);
        });
        this.tileSize = tileSize;
        this.pixelArrayUnitAmount = 8;
        this.pixelArrayUnitSize = tileSize / this.pixelArrayUnitAmount;
        this.player = player;
        this.currentLevel = startingLevel;
        this.resetLevel(startingLevel)
        this.spriteCanvas = spriteCanvas;
        this.currentGeneralFrameCounter = 0;
        this.generalFrameCounterMax = 480;
    }

    resetLevel(levelIndex) {
        SFXHandler.sfxAnimations = [];
        this.tileMap = WorldDataHandler.levels[levelIndex].tileData;
        this.updateLevelDimensions();
        this.setInitialPlayerAndCameraPos(levelIndex);
        this.levelObjects = [];
        this.levelObjects = this.createInitialObjects(WorldDataHandler.levels[levelIndex].levelObjects);
        this.deko = this.createInitialDeko(WorldDataHandler.levels[levelIndex].deko);
        this.paths = this.createInitialPaths(WorldDataHandler.levels[levelIndex].paths);
        this.currentGeneralFrameCounter = 0;
        this.player.resetAll();
    }

    setInitialPlayerAndCameraPos(levelIndex) {
        //This is a fallback, in case no flag was set in a level (start, ending, or if user forgot to set it)
        let initialPlayerValue = { x: 0, y: 0 };
        WorldDataHandler.levels[levelIndex].levelObjects.forEach(levelObject => {
            if (levelObject.type === ObjectTypes.START_FLAG) {
                initialPlayerValue.x = levelObject.x * this.tileSize;
                initialPlayerValue.y = levelObject.y * this.tileSize;
            }
        })
        this.player.initialY = initialPlayerValue.x;
        this.player.initialX = initialPlayerValue.y;
        Camera.moveTo(initialPlayerValue.x, initialPlayerValue.y);

        
    }

    updateLevelDimensions() {
        this.levelWidth = this.getLevelWidth();
        this.levelHeight = this.getLevelHeight();
        if (Camera.viewport) {
            Camera.viewport.worldWidth = this.levelWidth * this.tileSize;
            Camera.viewport.worldHeight = this.levelHeight * this.tileSize;
        }
    }

    createInitialPaths(initialPaths) {
        var paths = [];
        initialPaths && initialPaths.forEach(initialPath => {
            const { speed, stopFrames, movementDirection, pathVariant } = initialPath;
            let newPath = new Path(this, speed, stopFrames, movementDirection);
            newPath.pathVariant = pathVariant;
            newPath.pathPoints = initialPath.pathPoints.map(pathPoint =>
                new PathPoint(pathPoint.initialX, pathPoint.initialY, this.tileSize, pathPoint.alignment));
            newPath.checkObjectsOnPath();
            newPath.rearrangePathPoints();
            paths.push(newPath);
        });
        return paths;
    }

    createInitialObjects(initialObjects) {
        var levelObjects = [];
        initialObjects && initialObjects.forEach(initialObject => {
            const { type, x, y } = initialObject;

            const extraAttributes = initialObject.extraAttributes ? initialObject.extraAttributes : {};
            levelObjects.push(new ObjectTypes.objectToClass[type](x,
                y, this.tileSize, type, this, extraAttributes));
        });
        return levelObjects;
    }

    createInitialDeko(initialDekos) {
        var dekos = [];
        initialDekos && initialDekos.forEach(initialDeko => {
            const { x, y, index } = initialDeko;
            dekos.push(new Deko(x, y, this.tileSize, index));
        });
        return dekos;
    }

    drawGrid() {
        Display.drawGrid(this.levelWidth, this.levelHeight, this.tileSize);
    }

    displayTiles() {
        for (var tilePosY = 0; tilePosY < this.levelHeight; tilePosY++) {
            for (var tilePosX = 0; tilePosX < this.levelWidth; tilePosX++) {

                var tileType = this.tileMap[tilePosY][tilePosX];

                if (this.checkIfPositionAtTheEdge(tilePosX, tilePosY)) {
                    tileType = "edge";
                    if (this.checkIfStartOrEndingLevel()) {
                        tileType = 0;
                    }
                }

                if (tileType !== 0) {
                    Display.drawImage(this.spriteCanvas, 0, this.TILE_TYPES[tileType] * this.tileSize,
                        this.tileSize, this.tileSize, tilePosX * this.tileSize, tilePosY * this.tileSize, this.tileSize, this.tileSize);
                }
            }
        }
    }

    displayObjectsOrDeko(arr) {
        if (arr) {
            for (var i = arr.length - 1; i >= 0; i--) {
                arr[i].draw(this.spriteCanvas);
            }
        }
    }

    displayLevel() {
        const isPlayMode = Game.playMode === Game.PLAY_MODE;
        if (PauseHandler.paused && isPlayMode) {
            return;
        }
        this.displayObjectsOrDeko(this.deko);
        /*isPlayMode && Display.displayBackgroundSFX(this.currentGeneralFrameCounter, 8, this.tileSize,
            2, 2, 120, 0);
        isPlayMode && Display.displayFleshlight(this.player.x, this.player.y, 120);*/
        this.displayObjectsOrDeko(this.paths);
        this.displayObjectsOrDeko(this.levelObjects);
        this.displayTiles();
    }

    switchToNextLevel() {
        const nextLevel = PlayMode.customExit?.levelIndex || this.currentLevel + 1;
        const levelAmounth = WorldDataHandler.levels.length;
        if (this.currentLevel < levelAmounth - 1) {
            this.currentLevel = nextLevel;

            if (this.currentLevel === levelAmounth - 1) {
                GameStatistics.stopTimer();
            }
            this.resetLevel(this.currentLevel);
            if (typeof LevelNavigationHandler === 'function') {
                LevelNavigationHandler.updateLevel();
            }
        }
        else {
            console.log("error")
        }
    }

    resetDynamicObjects() {
        for (var i = this.levelObjects.length; i >= 0; i--) {
            if (this.levelObjects[i]?.type === ObjectTypes.CANON_BALL || this.levelObjects[i]?.type === ObjectTypes.ROCKET) {
                SFXHandler.createSFX(this.levelObjects[i].x, this.levelObjects[i].y, 1)
                this.levelObjects.splice(i, 1);
            }
            if (this.levelObjects[i]?.resetObject) {
                this.levelObjects[i].resetObject();
            }
        }
        this.paths.forEach(path => path.resetObjectsToInitialPosition());
        //Check here if tilemaphandler is missing objects from WorldDataHandler (if somethign was deleted)
    }

    filterObjectsByTypes(types) {
        return this.levelObjects.filter(levelObject => types.includes(levelObject.type));
    }

    getLevelHeight() {
        return this.tileMap.length;
    }

    getLevelWidth() {
        return this.tileMap[0].length;
    }

    getTileValueForPosition(pos) {
        return Math.floor(pos / this.tileSize);
    }

    getTileLayerValueByIndex(y, x) {
        return this.tileMap[y]?.[x];
    }

    checkIfPositionAtTheEdge(tilePosX, tilePosY) {
        return tilePosX === 0 || tilePosY === 0 || tilePosX === this.levelWidth - 1 || tilePosY === this.levelHeight - 1;
    }

    checkIfStartOrEndingLevel() {
        return this.currentLevel === 0 || this.currentLevel === WorldDataHandler.levels.length - 1;
    }
}class Controller {

    static staticConstructor() {
        this.down = false;
        this.left = false;
        this.right = false;
        this.up = false;
        this.jump = false;
        this.confirm = false;
        this.alternativeActionButton = false;
        this.alternativeActionButtonReleased = true;
        this.enter = false;
        this.enterReleased = true;
        this.pause = false;
        this.pauseReleased = true;
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseXInDrawCanvas = 0;
        this.mouseYInDrawCanvas = 0;
        this.mousePressed = false;
        this.rightMousePressed = false;
        this.mouseInsideMainCanvas = false;
        this.mouseInsideDrawCanvas = false;
        this.xScroll = 0;
        this.gamepadIndex = null;
        window.addEventListener('gamepadconnected', (event) => {
            this.gamepadIndex = event.gamepad.index;
        });
        window.addEventListener('gamepaddisconnected', (event) => {
            this.gamepadIndex = null;
        });
        document.addEventListener("keyup", (e) => { this.keyUp(e) });
        document.addEventListener("keydown", (e) => { this.keyDown(e) });
        
    }

    static handleGamepadInput() {
        if (this.gamepadIndex !== null) {
            const DEADZONE = 0.5;
            const myGamepad = navigator.getGamepads()[this.gamepadIndex];
            if (myGamepad?.buttons) {
                const primaryButtonPressed = myGamepad.buttons[0].pressed;
                this.jump = primaryButtonPressed;
                this.confirm = primaryButtonPressed;
                this.alternativeActionButton = myGamepad.buttons[1].pressed || myGamepad.buttons[2].pressed;
                const enterAndPause = myGamepad.buttons[9].pressed || myGamepad.buttons[8].pressed;
                this.enter = enterAndPause;
                this.pause = enterAndPause;
                
                const v = this.getControllerAxesCorrectedValue(myGamepad.axes[0], DEADZONE);
                this.left = v < DEADZONE * -1 || myGamepad.buttons[14].pressed;
                this.right = v > DEADZONE || myGamepad.buttons[15].pressed;

                const h = this.getControllerAxesCorrectedValue(myGamepad.axes[1], DEADZONE);
                this.up = h < DEADZONE * -1 || myGamepad.buttons[12].pressed;
                this.down = h > DEADZONE || myGamepad.buttons[13].pressed;
            }
        }
    }

    static getControllerAxesCorrectedValue(value, DEADZONE) {
        let v = value;
        if (Math.abs(v) < DEADZONE) {
            v = 0;
        }
        else {
            v = v - Math.sign(v) * DEADZONE;
            v /= (1.0 - DEADZONE);
        }
        return v;
    }
    
     /*   
        Checks key presses by code and sets the according variable to true or false.
        That way, the function can be reused for key-down and up
     */
    static handleKeyPresses(pressed, e) {
        const key = e.key;
        switch (key) {
            case "Enter": this.enter = pressed; break;
            case "Right": case "ArrowRight": this.right = pressed; e.preventDefault(); break;
            case "d": this.right = pressed; break;
            case "Left": case "ArrowLeft": this.left = pressed; e.preventDefault(); break;
            case "a": this.left = pressed; break;
            case "Up": case "ArrowUp": case "w": this.up = pressed; this.jump = pressed; break;
            case "c": case "j": this.jump = pressed; this.confirm = pressed; break;
            case "x": case "k": this.alternativeActionButton = pressed; break;
            case "Down": case "ArrowDown": this.down = pressed; break;
            case "Escape": case "p": this.pause = pressed; 
        }
    }

    static keyDown(e) {
        this.handleKeyPresses(true, e)
    };

    static keyUp(e) {
        this.handleKeyPresses(false, e)
    }

    static mouseLeave() {
        this.mouseInsideMainCanvas = false;
    }

    static mouseEnter() {
        this.mouseInsideMainCanvas = true;
    }

    static mouseLeaveDrawCanvas() {
        this.mouseInsideDrawCanvas = false;
    }

    static mouseEnterDrawCanvas() {
        this.mouseInsideDrawCanvas = true;
    }

    static mouseMove(e) {
        const coordinatesWithoutTranslation = Camera.worldToScreen(e.clientX, e.clientY);
        this.mouseX = coordinatesWithoutTranslation.x - canvasOffsetLeft + this.xScroll;
        this.mouseY = coordinatesWithoutTranslation.y - canvasOffsetTop;
    }

    static mouseMoveDrawInCanvas(e) {
        this.mouseXInDrawCanvas = e.clientX;
        this.mouseYInDrawCanvas = e.clientY;
    }

    static mouseDown(evt) {
        switch (evt.which) {
            case 1:
                this.mousePressed = true;
                break;
            case 3:
                this.rightMousePressed = true;
                break;
            default:
                console.log('You have a strange Mouse!');
        }
    }

    static mouseUp() {
        this.mousePressed = false;
        this.rightMousePressed = false;
    }

    static onResize() {
        canvasOffsetLeft = document.getElementById("myCanvas").offsetLeft;
        canvasOffsetTop = document.getElementById("myCanvas").offsetTop;
    }

    static onScroll() {
        this.xScroll = window.scrollX;
        DrawSectionHandler.getBoundingRectPosition(0);
    }
}class MoveableCharacter {

    constructor() {

    }

    resetAll(x, y, speed, xspeed, yspeed, jumpframes, falling, death, friction) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.xspeed = xspeed;
        this.yspeed = yspeed;
        this.jumpframes = jumpframes;
        this.falling = falling;
        this.currentCoyoteJumpFrame = 0;
        this.death = death;
        this.friction = friction;
    }
}class Player {

    constructor(initialX, initialY, tileSize) {
        this.tileSize = tileSize;
        this.width = this.tileSize - 2;
        /*
            height minus some pixels, because chracter is 1 pixel above ground,
            and so that he can squeeze between tile exactly above head
        */
        this.height = this.tileSize - 3;
        this.initialX = initialX * this.tileSize;
        this.initialY = initialY * this.tileSize;
        this.wallJumpDirection = 1;
        this.dashDirection = AnimationHelper.facingDirections.left;
        this.maxJumpFrames = 18;
        this.dashCooldown = 3;
        this.maxDashFrames = 10 + this.dashCooldown;
        this.coyoteDashFrames = 6;
        this.currentCoyoteDashFrame = this.coyoteDashFrames;
        this.maxFallSpeed = this.tileSize / 1.5;
        this.coyoteJumpFrames = 6;
        this.extraTrampolineJumpFrames = Math.round(this.maxJumpFrames / 6);
        this.pushToSideWhileWallJumpingFrames = this.maxJumpFrames / 2 - 4;
        this.jumpSpeed = 0.44;
        this.maxSpeed = 3;
        this.groundFriction = 0.65;
        this.air_friction = 0.75;
        this.groundAcceleration = 0.8;
        this.air_acceleration = this.groundAcceleration;
        this.gravity = 0.5;
        this.wallJumpGravity = this.gravity * 2;
        this.spriteCanvas = spriteCanvas;
        this.type = "player";
        this.setBorderPositions();
        this.setAnimationProperties();
        this.setAbilities();
        this.resetAll();
    }

    setBorderPositions() {
        this.right;
        this.left;
        this.bottom;
        this.top;
        this.top_right_pos;
        this.top_left_pos;
        this.bottom_right_pos;
        this.bottom_left_pos;
        this.top_right;
        this.top_left;
        this.bottom_left;
        this.bottom_right;
        this.prev_bottom;
        this.wallJumpLeft;
        this.wallJumpRight;
    }

    resetPosition(checkCheckpoints = false) {
        if (checkCheckpoints) {
            const activeCheckPointPos = PlayMode.checkActiveCheckPoints();
            this.x = activeCheckPointPos ? activeCheckPointPos.x : this.initialX;
            this.y = activeCheckPointPos ? activeCheckPointPos.y : this.initialY;
        } else {
            this.x = this.initialX;
            this.y = this.initialY;
        }
    }

    resetAttributes() {
        this.speed = 0;
        this.xspeed = 0;
        this.yspeed = 0;
        this.jumpframes = 0;
        this.wallJumpFrames = this.maxJumpFrames;
        this.falling = false;
        this.jumping = false;
        this.jumpPressedToTheMax = false;
        this.wallJumping = false;
        this.dashing = false;
        this.onTrampoline = false;
        this.currentDashFrame = 0;
        this.currentCoyoteJumpFrame = 0;
        this.currentWallJumpCoyoteFrame = 0;
        this.walljumpReady = false;
        this.friction = this.air_friction;
        this.collidingWithNpc = false;
    }

    resetAll() {
        this.resetAttributes();
        this.resetPosition();
        this.resetAnimationAttributes();
    }

    setAbilities() {
        this.jumpChecked = true;
        this.wallJumpChecked = true;
        this.dashChecked = false;
        this.runChecked = false;
    }

    setAnimationProperties() {
        this.facingDirection = AnimationHelper.facingDirections.right;
        this.spriteIndexIdle = SpritePixelArrays.getIndexOfSprite(ObjectTypes.PLAYER_IDLE);
        this.spriteIndexJump = SpritePixelArrays.getIndexOfSprite(ObjectTypes.PLAYER_JUMP);
        this.spriteIndexWalk = SpritePixelArrays.getIndexOfSprite(ObjectTypes.PLAYER_WALK);
        this.animationLengths = {
            [this.spriteIndexIdle]: SpritePixelArrays.PLAYER_IDLE_SPRITE.animation.length,
            [this.spriteIndexJump]: SpritePixelArrays.PLAYER_JUMP_SPRITE.animation.length,
            [this.spriteIndexWalk]: SpritePixelArrays.PLAYER_WALK_SPRITE.animation.length,
        };
        this.spriteObject = SpritePixelArrays.PLAYER_JUMP_SPRITE;
        this.currentSpriteIndex = this.spriteIndexIdle;
        this.currentAnimationIndex = 0;
    }

    resetAnimationAttributes() {
        this.clearAnimationInterval("runningAnimationInterval");
        this.clearAnimationInterval("walljumpAnimationInterval");
        AnimationHelper.setInitialSquishValues(this, this.tileSize);
    }

    setAnimationState(newAnimationState) {
        if (this.currentSpriteIndex !== newAnimationState) {
            this.currentAnimationIndex = 0;
        }
        this.currentSpriteIndex = newAnimationState;
    }

    activateAnimationInterval(intervalName, xOffset = 0, yOffset = 0, intervalTime = 200) {
        if (!this[intervalName]) {
            this[intervalName] = setInterval(() => {
                SFXHandler.createSFX(this.x + xOffset, this.y + yOffset, 1, AnimationHelper.facingDirections.bottom, 0, 0, true);
            }, intervalTime);
        }
    }

    clearAnimationInterval(intervalName) {
        if (this[intervalName]) {
            clearInterval(this[intervalName]);
            this[intervalName] = null;
        }
    }

    draw() {
        if (this.xspeed > 0) {
            //this.activateAnimationInterval("runningAnimationInterval");
            this.facingDirection = AnimationHelper.facingDirections.right;
        }
        else if (this.xspeed < 0) {
            //this.activateAnimationInterval("runningAnimationInterval");
            this.facingDirection = AnimationHelper.facingDirections.left;
        }
        else {
            //this.clearAnimationInterval("runningAnimationInterval");
        }

        if (this.xspeed === 0 && this.yspeed === 0) {
            this.setAnimationState(this.spriteIndexIdle);
        }
        else if (this.xspeed !== 0 && this.yspeed === 0) {
            this.setAnimationState(this.spriteIndexWalk);
        }
        if (this.yspeed !== 0 || this.falling) {
            //this.clearAnimationInterval("runningAnimationInterval");
            this.setAnimationState(this.spriteIndexJump);
        }

        if((this.wallJumpRight || this.wallJumpLeft) && this.yspeed > 0) {
            //this.activateAnimationInterval("walljumpAnimationInterval", 0, -12);
        }
        else {
            //this.clearAnimationInterval("walljumpAnimationInterval");
        }

        const animationLength = this.animationLengths[this.currentSpriteIndex];

        const frameDuration = this.currentSpriteIndex === this.spriteIndexIdle
            ? AnimationHelper.defaultFrameDuration
            : AnimationHelper.walkingFrameDuration;

        this.currentAnimationIndex++;
        if (this.currentAnimationIndex >= frameDuration * animationLength || Game.playMode === Game.BUILD_MODE) {
            this.currentAnimationIndex = 0;
        }

        /*
            First, normal facing sprites are rendered, then mirrored sprites
            If we want to display mirrored sprites, we need to start at the end of the normal animation index
        */
        const loop = this.facingDirection === AnimationHelper.facingDirections.left ? animationLength : 0;

        //Animation index in regards to "FPS" (animation frame duration)
        const animationIndex = (Math.floor(this.currentAnimationIndex / frameDuration) + loop) || 0;

        AnimationHelper.checkSquishUpdate(this);

        Display.drawImage(this.spriteCanvas, animationIndex * this.tileSize,
            this.currentSpriteIndex * this.tileSize, this.tileSize,
            this.tileSize - 1, this.x - this.squishXOffset, this.y - 2 - this.squishYOffset,
            this.drawWidth, this.drawHeight);
    }

    checkWallJumpReady() {
        const wallJumpRightPos = tileMapHandler.getTileValueForPosition(this.x + this.width + 1);
        const wallJumpLeftPos = tileMapHandler.getTileValueForPosition(this.x - 1);
        const wallJumpTopRightTile = tileMapHandler.getTileLayerValueByIndex(this.top, wallJumpRightPos);
        const wallJumpBottomRightTile = tileMapHandler.getTileLayerValueByIndex(this.bottom, wallJumpRightPos);
        const wallJumpTopLeftTile = tileMapHandler.getTileLayerValueByIndex(this.top, wallJumpLeftPos);
        const wallJumpBottomLeftTile = tileMapHandler.getTileLayerValueByIndex(this.bottom, wallJumpLeftPos);
        this.wallJumpRight = wallJumpTopRightTile !== 0 && wallJumpTopRightTile !== 5 || wallJumpBottomRightTile !== 0 && wallJumpBottomRightTile !== 5;
        this.wallJumpLeft = wallJumpTopLeftTile !== 0 && wallJumpTopLeftTile !== 5 || wallJumpBottomLeftTile !== 0 && wallJumpBottomLeftTile !== 5;
    }

    hitWall(direction) {
        switch (direction) {
            case AnimationHelper.facingDirections.bottom:
                this.hitBottom();
                break;
            case AnimationHelper.facingDirections.top:
                this.hitTop();
                break;
            case AnimationHelper.facingDirections.left:
                this.xspeed = 0;
                break;
            case AnimationHelper.facingDirections.right:
                this.xspeed = 0;
        }
    }

    verticalHit() {
        this.yspeed = 0;
        this.falling = false;
        this.jumpframes = 0;
        this.wallJumpFrames = this.maxJumpFrames;
        this.currentCoyoteJumpFrame = 0;
    }

    hitBottom() {
        this.verticalHit();
        this.jumpframes = 0;
        this.setSquishAnimation();
    }

    hitTop() {
        this.verticalHit();
        this.onTrampoline = false;
        this.jumpframes = this.maxJumpFrames;
        this.jumpPressedToTheMax = true;
    }

    setSquishAnimation() {
        AnimationHelper.setSquishValues(this, this.tileSize * 1.2, this.tileSize * 0.8);
    }

    setStretchAnimation() {
        AnimationHelper.setSquishValues(this, this.tileSize * 0.8, this.tileSize * 1.2);
    }
}class PlayMode {

    static staticConstructor(player, tilemapHandler) {
        this.player = player;
        this.tilemapHandler = tilemapHandler;
        this.deathPauseFrames = 24;
        this.animationFrames = 48;
        this.currentPauseFrames = 0;
        this.animateToNextLevel = false;
        this.customExit;
    }

    static runStartScreenLogic() {
        this.player.x = 0;
        this.player.y = 0;
        if (Controller.enter) {
            Controller.enterReleased = false;
            this.startGame();
            SoundHandler.guiSelect.stopAndPlay();
        }
    }

    static startGame() {
        GameStatistics.resetPermanentObjects();
        tileMapHandler.currentLevel = 1;
        if (typeof LevelNavigationHandler === 'function') {
            LevelNavigationHandler.updateLevel();
        }
        else {
            if (SoundHandler?.song?.sound?.src && !WorldDataHandler.insideTool) {
                SoundHandler.song.stopAndPlay();
            }
            tileMapHandler.resetLevel(tileMapHandler.currentLevel);
        }
        GameStatistics.resetPlayerStatistics();
        GameStatistics.startTimer();
    }

    static runPlayLogic() {
        const { player } = this;

        PauseHandler.checkPause();

        if (!player.death && this.currentPauseFrames === 0 && !DialogueHandler.active && !PauseHandler.paused) {
            this.updateGeneralFrameCounter();

            var walking = false;
            if (!player.dashing) {
                //const newMaxSpeed = Controller.alternativeActionButton && player.runChecked ? player.maxSpeed * 1.65 : player.maxSpeed;
                const newMaxSpeed = player.maxSpeed;
                if (Controller.left) {
                    //check should be player.xspeed + player.acceleration and an else with player.xspeed = player.maxSpeed
                    if (player.xspeed > newMaxSpeed * -1) {
                        player.xspeed -= player.speed;
                    }
                    walking = true;
                }
                if (Controller.right) {
                    if (player.xspeed < newMaxSpeed) {
                        player.xspeed += player.speed;
                    }
                    walking = true;
                }
            }

            //if player releases jump button while in the air (doesn't matter if jumping or falling)
            if (!Controller.jump && player.falling) {
                //if he is falling, give player some extra frames where he is able to jump
                if (player.yspeed >= 0) {
                    player.currentCoyoteJumpFrame++;
                }
                //if he went up once, jumping, or on trampoline, set those frames to max immediatly
                else {
                    player.currentCoyoteJumpFrame = player.coyoteJumpFrames;
                }
            }
            //if player touched a wall, allow him to walljump
            if (player.wallJumpChecked && !player.jumping && !player.wallJumping && player.falling) {
                if (player.wallJumpLeft) {
                    this.resetWallJump(1);
                }
                else if (player.wallJumpRight) {
                    this.resetWallJump(-1);
                }
            }

            if (player.onTrampoline) {
                this.jumpHandler(player.jumpSpeed + (player.jumpSpeed / 3.75), player.maxJumpFrames + player.extraTrampolineJumpFrames);
            }

            this.dashHandler();

            Controller.alternativeActionButtonReleased = Controller.alternativeActionButton ? false : true;

            if (Controller.jump && !player.collidingWithNpcId && !PauseHandler.justClosedPauseScreen) {
                if (!player.jumpPressedToTheMax &&
                    player.jumpChecked && !player.dashing && !player.onTrampoline &&
                    player.currentCoyoteJumpFrame < player.coyoteJumpFrames && player.jumpframes < player.maxJumpFrames) {
                    if (!player.jumping && player.jumpframes === 0) {
                        this.jumpInitialized();
                    }
                    this.jumpHandler(player.jumpSpeed, player.maxJumpFrames);
                    player.jumping = true;
                }
                if (player.jumpframes === player.maxJumpFrames && player.yspeed <= 0) {
                    player.jumpPressedToTheMax = true;
                }
                if (player.wallJumpChecked && !player.dashing && player.wallJumpFrames < player.maxJumpFrames
                    && player.currentWallJumpCoyoteFrame < player.coyoteJumpFrames) {
                    if (!player.wallJumping && player.wallJumpFrames === 0) {
                        this.jumpInitialized(player.wallJumpLeft ? AnimationHelper.facingDirections.left : AnimationHelper.facingDirections.right);
                    }
                    player.wallJumpFrames++;
                    var currentJumpSpeed = -(player.maxJumpFrames - player.wallJumpFrames) * player.jumpSpeed;
                    if (currentJumpSpeed !== 0) {
                        player.yspeed = currentJumpSpeed;
                    }
                    if (player.wallJumpFrames < player.pushToSideWhileWallJumpingFrames) {
                        player.xspeed -= currentJumpSpeed * player.wallJumpDirection;

                        if (player.wallJumpDirection === 1 && player.xspeed > player.maxSpeed) {
                            player.xspeed = player.maxSpeed;
                        }
                        else if (player.wallJumpDirection === -1 && player.xspeed < player.maxSpeed * -1) {
                            player.xspeed = player.maxSpeed * -1;
                        }
                    }
                    player.wallJumping = true;
                }
            }
            else {
                if (player.wallJumping) {
                    player.wallJumpFrames = player.maxJumpFrames;
                    player.wallJumping = false;
                }
                if (player.jumping) {
                    player.jumping = false;
                    if (player.yspeed !== 0 && !player.onTrampoline) {
                        player.jumpframes = player.maxJumpFrames;
                    }
                }
                player.jumpPressedToTheMax = false;
            }
            //If player released jump button, slowly de-accelarate the jump
            if (player.yspeed < 0 && !player.jumping && !player.wallJumping && !player.onTrampoline) {
                if (Math.abs(player.yspeed) < 0.5) {
                    player.yspeed = 0;
                }
                else {
                    player.yspeed *= 0.75;
                }
            }
            if (!player.dashing) {
                //const runButtonReleased = this.isRunButtonReleased();

                if (!walking) {
                    player.xspeed *= player.friction;
                    if (Math.abs(player.xspeed) < 0.5) {
                        player.xspeed = 0;
                    }
                }
                if (player.falling) {
                    //If player is falling and pressing against the wall, he will stick to the wall
                    if (player.wallJumpChecked && player.yspeed > 0 && (player.wallJumpLeft && Controller.left ||
                        player.wallJumpRight && Controller.right)) {
                        player.yspeed = player.wallJumpGravity;
                    }
                    else {
                        !player.wallJumping && player.currentWallJumpCoyoteFrame++;
                        if (!player.onTrampoline) {
                            player.yspeed += player.gravity;
                        }
                    }
                }
            }

            if (!player.falling && player.jumpframes === 0) {
                player.yspeed = 0;
            }
            if (player.yspeed > player.maxFallSpeed) {
                player.yspeed = player.maxFallSpeed;
            }
            CharacterCollision.checkCollisionsWithWorld(player, true);
        }
    }

    static isRunButtonReleased() {
        const { player } = this;
        return player.runChecked && !Controller.alternativeActionButton && (Math.abs(player.xspeed) > Math.abs(player.maxSpeed));
    }

    static jumpInitialized(direction = AnimationHelper.facingDirections.bottom) {
        SoundHandler.shortJump.stopAndPlay();
        SFXHandler.createSFX(player.x, player.y, 0, direction);
        this.player.setStretchAnimation();
    }

    static updateGeneralFrameCounter() {
        tileMapHandler.currentGeneralFrameCounter++;
        if (tileMapHandler.currentGeneralFrameCounter > tileMapHandler.generalFrameCounterMax) {
            tileMapHandler.currentGeneralFrameCounter = 0;
        }
    }

    static jumpHandler(jumpSpeed, maxFrames) {
        player.jumpframes++;
        var currentJumpSpeed = -(maxFrames - player.jumpframes) * jumpSpeed;
        if (currentJumpSpeed !== 0) {
            //easing: currentJumpSpeed * currentJumpSpeed * -1 (and jumpspeed much smaller)
            player.yspeed = currentJumpSpeed;
        }
    }

    static dashHandler() {
        const { player } = this;

        if (player.dashChecked) {
            player.currentCoyoteDashFrame++;
            if (Controller.alternativeActionButtonReleased && Controller.alternativeActionButton) {
                player.currentCoyoteDashFrame = 0;
            }
            if (!player.jumping && !player.falling && player.currentDashFrame >= player.maxDashFrames) {
                player.currentDashFrame = 0;
            }

            if (player.currentCoyoteDashFrame < player.coyoteDashFrames && !player.dashing && player.currentDashFrame === 0) {
                player.currentCoyoteDashFrame = player.coyoteDashFrames;
                player.dashing = true;
                player.onTrampoline = false;
                player.dashDirection = AnimationHelper.facingDirections.left;

                //if player faces right, or he is stuck to the left wall and wants to push away by pressing x immediatly
                if (player.xspeed === 0 && player.facingDirection === AnimationHelper.facingDirections.right && !player.wallJumpRight
                    || Controller.right && !player.wallJumpRight
                    || player.wallJumpLeft && player.yspeed !== 0
                    || player.wallJumpRight && player.yspeed === 0
                    || player.dashing && player.xspeed > 0 && !player.wallJumpRight) {
                    player.dashDirection = AnimationHelper.facingDirections.right;
                }
            }

            if (player.dashing) {
                if (player.currentDashFrame < player.maxDashFrames) {
                    player.yspeed = 0;

                    if (player.currentDashFrame === 0) {
                        SoundHandler.dash.stopAndPlay();
                    }
                    if (player.currentDashFrame < player.dashCooldown) {
                        player.xspeed = 0;
                    }
                    else {
                        if (player.dashDirection === AnimationHelper.facingDirections.left) {
                            player.xspeed = player.maxSpeed * 3.8 * -1;
                        }
                        else if (player.dashDirection === AnimationHelper.facingDirections.right) {
                            player.xspeed = player.maxSpeed * 3.8;
                        }
                        if (player.currentDashFrame % 3 === 0) {
                            SFXHandler.createSFX(player.x, player.y, 2);
                        }
                    }
                }
                if (player.currentDashFrame === player.maxDashFrames - 1) {
                    player.dashing = false;
                    player.xspeed = 0;
                    //deactivate the variables, in case they were activated shortly before dash
                    player.wallJumpFrames = player.maxJumpFrames;
                    player.jumpFrames = player.maxJumpFrames;
                }
                player.currentDashFrame++;
            }
        }
    }

    static pauseFramesHandler() {
        if(PauseHandler.paused) {
            PauseHandler.handlePause();
        }
        else if (this.currentPauseFrames > 0) {
            this.currentPauseFrames--
            if (player.death) {
                if (this.currentPauseFrames === this.deathPauseFrames / 2) {
                    this.player.resetPosition(true);
                    this.player.death = false;
                    tileMapHandler.resetDynamicObjects();
                }
            }
            if (this.animateToNextLevel) {
                const halfAnimationFrames = this.animationFrames / 2;
                const totalBlackFrames = 4;
                if (tileMapHandler.checkIfStartOrEndingLevel()) {
                    this.currentPauseFrames = 0;
                }
                const fadeInFrames = halfAnimationFrames + totalBlackFrames;
                const fadeOutFrames = halfAnimationFrames - totalBlackFrames;

                if (this.currentPauseFrames > fadeInFrames) {
                    //fade in
                    Display.animateFade(fadeInFrames - (this.currentPauseFrames - fadeInFrames),
                        fadeInFrames);
                }
                else if (this.currentPauseFrames < fadeOutFrames) {
                    //fade out
                    Display.animateFade(this.currentPauseFrames,
                        fadeOutFrames);
                }
                else {
                    //stay black for some frames
                    Display.animateFade(halfAnimationFrames,
                        halfAnimationFrames);
                }
                if (this.currentPauseFrames === halfAnimationFrames) {
                    tileMapHandler.switchToNextLevel();
                }
            }
        }
        else {
            if (this.animateToNextLevel) {
                this.animateToNextLevel = false;
            }
            this.currentPauseFrames = 0;
        }
    }

    static resetWallJump(wallJumpDirection) {
        this.player.wallJumpFrames = 0;
        this.player.currentWallJumpCoyoteFrame = 0;
        //if not in dashing cooldown
        if (this.player.currentDashFrame > this.player.dashCooldown) {
            this.player.dashing = false;
            this.player.currentDashFrame = 0;
        }
        this.player.wallJumpDirection = wallJumpDirection;
    }

    static playerDeath() {
        SoundHandler.hit.stopAndPlay();
        this.currentPauseFrames = this.deathPauseFrames;
        this.player.death = true;
        const direction = AnimationHelper.facingDirections.bottom;
        for (var i = 0; i < 7; i++) {
            SFXHandler.createSFX(player.x, player.y, 2, direction, MathHelpers.getSometimesNegativeRandomNumber(0, 2, false), MathHelpers.getSometimesNegativeRandomNumber(0, 2, false), true, 22);
        }
        this.player.resetAttributes();
        GameStatistics.deathCounter++;
        tileMapHandler.currentGeneralFrameCounter = 0;
    }

    static checkActiveCheckPoints() {
        let checkPointPos = null;
        this.tilemapHandler && this.tilemapHandler.levelObjects.forEach(levelObject => {
            if (levelObject.type === ObjectTypes.CHECKPOINT && levelObject?.active) {
                checkPointPos = {
                    x: levelObject.initialX * this.tilemapHandler.tileSize,
                    y: levelObject.initialY * this.tilemapHandler.tileSize
                }
            }
        });
        return checkPointPos;
    }
}class LevelObject {

    constructor(x, y, tileSize, type) {
        this.initialX = x;
        this.initialY = y;
        this.x = x * tileSize;
        this.y = y * tileSize;
        this.width = tileSize;
        this.height = tileSize;
        this.type = type;
        this.tileSize = tileSize;
        this.xspeed = 0;
        this.yspeed = 0;
        this.setSpriteAttributes(this.type);
        AnimationHelper.setInitialSquishValues(this, this.tileSize);
    }

    setSpriteAttributes(type) {
        this.spriteIndex = SpritePixelArrays.getIndexOfSprite(type);
        this.spriteObject = SpritePixelArrays.getSpritesByName(type);
        this.canvasYSpritePos = this.spriteIndex * this.tileSize;
        this.canvasXSpritePos = 0;
    }

    makeid(length) {
        return TilemapHelpers.makeid(length);
    }

    drawSingleFrame(spriteCanvas, canvasXSpritePos, canvasYSpritePos = this.canvasYSpritePos) {
        Display.drawImage(spriteCanvas, canvasXSpritePos, canvasYSpritePos,
            this.tileSize, this.tileSize, this.x, this.y, this.tileSize, this.tileSize);
    }

    draw(spriteCanvas, canvasYSpritePos) {
        const drawFunction = (canvasXSpritePos) => this.drawSingleFrame(spriteCanvas, canvasXSpritePos, canvasYSpritePos);
        this.checkFrameAndDraw(drawFunction);
    }

    drawSingleSquishingFrame(spriteCanvas, canvasXSpritePos) {
        AnimationHelper.checkSquishUpdate(this);
        Display.drawImage(spriteCanvas, canvasXSpritePos, this.canvasYSpritePos,
            this.tileSize, this.tileSize, this.x - this.squishXOffset, this.y - this.squishYOffset, this.drawWidth, this.drawHeight);
    }

    drawWithSquishing(spriteCanvas) {
        const drawFunction = (canvasXSpritePos) => this.drawSingleSquishingFrame(spriteCanvas, canvasXSpritePos);
        this.checkFrameAndDraw(drawFunction);
    }

    drawSingleAlphaFrame(spriteCanvas, alpha, canvasXSpritePos) {
        AnimationHelper.checkSquishUpdate(this);
        Display.drawImageWithAlpha(spriteCanvas, canvasXSpritePos, this.canvasYSpritePos,
            this.tileSize, this.tileSize, this.x, this.y, this.tileSize, this.tileSize, alpha);
    }

    drawWithAlpha(spriteCanvas, alpha) {
        const drawFunction = (canvasXSpritePos) => this.drawSingleAlphaFrame(spriteCanvas, alpha, canvasXSpritePos);
        this.checkFrameAndDraw(drawFunction);
    }

    drawWithRotation(spriteCanvas, angle = 0) {
        let drawFunction = (canvasXSpritePos) => Display.drawImageWithRotation(spriteCanvas, canvasXSpritePos, this.canvasYSpritePos,
            this.tileSize, this.tileSize, this.x, this.y, this.tileSize, this.tileSize, angle);
        //Included squishing function right here, because rotating enemies are so rare
        if (this.spriteObject?.[0].squishAble) {
            AnimationHelper.checkSquishUpdate(this);
            drawFunction = (canvasXSpritePos) => Display.drawImageWithRotation(spriteCanvas, canvasXSpritePos, this.canvasYSpritePos,
                this.tileSize, this.tileSize, this.x - this.squishXOffset, this.y - this.squishYOffset, this.drawWidth, this.drawHeight, angle);
        }
        this.checkFrameAndDraw(drawFunction);
    }

    checkFrameAndDraw(drawFunction) {
        if (this?.spriteObject?.[0].animation.length > 1 && Game.playMode === Game.PLAY_MODE) {
            const frameModulo = tileMapHandler.currentGeneralFrameCounter % 40;
            if (frameModulo < AnimationHelper.defaultFrameDuration) {
                drawFunction(this.canvasXSpritePos);
            }
            else {
                drawFunction(this.canvasXSpritePos + this.tileSize);
            }
        }
        else {
            drawFunction(this.canvasXSpritePos);
        }
    }
}class InteractiveLevelObject extends LevelObject {

    constructor(x, y, tileSize, type, hitBoxOffset = 0, extraAttributes = {}) {
        super(x,y,tileSize,type);
        this.hitBoxOffset = hitBoxOffset;
        this.changeableInBuildMode = false;
        if (this.spriteObject?.[0]?.directions) {
            this.facingDirections = this.spriteObject?.[0]?.directions;
            this.changeableInBuildMode = true;
            this.currentFacingDirection = this.facingDirections[0];
        }
        if (this.spriteObject?.[0]?.changeableAttributes) {
            this.changeableInBuildMode = true;
            this.spriteObject?.[0]?.changeableAttributes.forEach(attribute => {
                this[attribute.name] = attribute.defaultValue;
            });
        }
        this.extraAttributes = extraAttributes;
        if (extraAttributes) {
            for (const [key, value] of Object.entries(extraAttributes)) {
                this[key] = value;
                if (key === "currentFacingDirection" && this.facingDirections) {
                    this.canvasXSpritePos = this.facingDirections.indexOf(value) * this.spriteObject[0].animation.length * this.tileSize;
                }
            }

        }
    }

    turnObject() {
        var currentIndex = this.facingDirections.indexOf(this.currentFacingDirection);
        currentIndex++;
        if (currentIndex > this.facingDirections.length - 1) {
            currentIndex = 0;
        }
        this.canvasXSpritePos = currentIndex * this.spriteObject[0].animation.length * this.tileSize;
        this.addChangeableAttribute("currentFacingDirection", this.facingDirections[currentIndex]);
    }

    addChangeableAttribute(attribute, value, levelToChange = null) {
        const levelIndex = levelToChange || tileMapHandler.currentLevel;
        this[attribute] = value;
        if (WorldDataHandler.levels[levelIndex].levelObjects) {
            WorldDataHandler.levels[levelIndex].levelObjects.forEach(levelObject => {
                if (levelObject.x === this.initialX && levelObject.y === this.initialY && levelObject.type === this.type) {
                    if(!levelObject.extraAttributes) {
                        levelObject.extraAttributes = {};
                    }
                    levelObject.extraAttributes[attribute] = value;
                }
            });
        }
    }
    
    deleteObjectFromLevel(tilemapHandler, showSfx = true) {
        showSfx && SFXHandler.createSFX(this.x, this.y, 1)
        for (var i = tilemapHandler.levelObjects.length - 1; i >= 0; i--) {
            var levelObject = tilemapHandler.levelObjects[i];
            if (this.key === levelObject.key && levelObject.initialX === this.initialX && levelObject.initialY === this.initialY && levelObject.type === this.type) {
                tilemapHandler.levelObjects.splice(i, 1);
                break;
            }
        }
    }
}class Spike extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        const hitBoxOffset = -tileSize / 6;
        super(x, y, tileSize, type, hitBoxOffset, extraAttributes);
    }

    collisionEvent() {
        PlayMode.playerDeath();
    }
}class FinishFlag extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, 0, extraAttributes);
        this.collidedWithPlayer = false;
        this.tilemapHandler = tilemapHandler;
        this.changeableInBuildMode = true;
        this.closedFinishedFlagSpriteIndex = SpritePixelArrays.getIndexOfSprite(ObjectTypes.FINISH_FLAG_CLOSED);
        this.closedFinishedFlagYSpritePos = this.closedFinishedFlagSpriteIndex * this.tileSize;
        this.closed = false;
        if (!WorldDataHandler.insideTool) {
            this.persistentCollectibles = WorldDataHandler.levels[this.tilemapHandler.currentLevel].levelObjects.filter(
                levelObject => levelObject.type === ObjectTypes.COLLECTIBLE
            );
        }
    }

    collisionEvent() {
        if (!this.collidedWithPlayer && !this.closed) {
            this.collidedWithPlayer = true;
            SoundHandler.win.stopAndPlay();
            PlayMode.animateToNextLevel = true;
            PlayMode.currentPauseFrames = PlayMode.animationFrames;
            PlayMode.customExit = this.customExit;

            if (this.tilemapHandler.currentLevel === WorldDataHandler.levels.length - 2 && !this.customExit
                && !WorldDataHandler.insideTool) {
                SoundHandler.fadeAudio("mainSong");
            }
        }
    }

    changeExit(text) {
        if (text) {
            if (text === 'finishLevel') {
                this.addChangeableAttribute("customExit", { levelIndex: WorldDataHandler.levels.length - 1 });
            }
            else {
                const valueArray = text.split(",");
                valueArray.length === 2 && this.addChangeableAttribute("customExit", { levelIndex: parseInt(valueArray[0]), flagIndex: valueArray[1] });
            }
        }
        else {
            this.addChangeableAttribute("customExit", null);
        }
    }

    checkIfAllCollectiblesCollected(collectibles) {
        if (WorldDataHandler.insideTool) {
            return collectibles.every(collectible => collectible.touched);
        }
        else {
            return this.persistentCollectibles.every(persistentCollectible => persistentCollectible.extraAttributes.collected);
        }
    }

    draw(spriteCanvas) {
        if (!this.collectiblesNeeded) {
            super.draw(spriteCanvas);
            this.closed = false;
        }
        else {
            const collectibles = this.tilemapHandler.filterObjectsByTypes(ObjectTypes.COLLECTIBLE);
            if (!collectibles || this.checkIfAllCollectiblesCollected(collectibles)) {
                super.draw(spriteCanvas);
                this.closed = false;
            }
            else {
                super.draw(spriteCanvas, this.closedFinishedFlagYSpritePos)
                this.closed = true;
            }
        }
    }
}class Checkpoint extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler) {
        super(x, y, tileSize, type);
        this.active = false;
        this.tilemapHandler = tilemapHandler;
    }

    collisionEvent() {
        if (!this.active) {
            this.tilemapHandler.levelObjects.forEach(levelObject => {
                if (levelObject.type === ObjectTypes.CHECKPOINT) {
                    levelObject.active = false;
                }
            });
            this.active = true;
            SoundHandler.checkpoint.play();
        }
    }

    draw(spriteCanvas) {
        const showSecond = this.active && this?.spriteObject?.[0].animation.length > 1;
        super.drawSingleFrame(spriteCanvas, showSecond ? this.canvasXSpritePos + this.tileSize : this.canvasXSpritePos);
    }
}class StartFlag extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, 0, extraAttributes);
        this.tilemapHandler = tilemapHandler;
        this.changeableInBuildMode = true;

        const startFlagsInLevel = WorldDataHandler.levels[this.tilemapHandler.currentLevel].levelObjects.filter(levelObject => levelObject.type === ObjectTypes.START_FLAG);
        
        if(!extraAttributes?.levelStartFlag && startFlagsInLevel.length === 1) {
            this.levelStartFlag = true;
            this.addChangeableAttribute("levelStartFlag", true, this.tilemapHandler.currentLevel);
        }
        if(!extraAttributes?.flagIndex) {
            this.flagIndex = this.makeid(3);
            this.addChangeableAttribute("flagIndex", this.flagIndex, this.tilemapHandler.currentLevel);
        }

        const customEntryFlag = startFlagsInLevel.find(startFlag =>
            PlayMode?.customExit?.flagIndex && startFlag?.extraAttributes?.flagIndex === PlayMode.customExit.flagIndex
        );
        const levelStartFlag = startFlagsInLevel.find(startFlag =>
            startFlag?.extraAttributes?.levelStartFlag
        );

        if (customEntryFlag?.extraAttributes?.flagIndex === this.flagIndex || levelStartFlag?.extraAttributes?.flagIndex === this.flagIndex) {
            this.setPlayerInitialPosition();
        }
        else if (!levelStartFlag && !customEntryFlag) {
            const lastFlag = startFlagsInLevel[startFlagsInLevel.length - 1];
            if (lastFlag.x === this.initialX && lastFlag.y === this.initialY) {
                this.setPlayerInitialPosition();
            }
        }
    }

    setPlayerInitialPosition() {
        if (this.tilemapHandler?.player) {
            this.tilemapHandler.player.initialX = this.x;
            this.tilemapHandler.player.initialY = this.y;
        }
    }

    updateLevelStartValue(levelStartValue) {
        const startFlagsInTileMapHandler = this.tilemapHandler.filterObjectsByTypes(ObjectTypes.START_FLAG);

        if (levelStartValue) {
            //reset all other start flags, because there can only be 1 level starting flag
            startFlagsInTileMapHandler.forEach(startFlagInTileMapHandler => {
                startFlagInTileMapHandler.addChangeableAttribute("levelStartFlag", false);
            });
            this.addChangeableAttribute("levelStartFlag", true);
        }
        else {
            this.addChangeableAttribute("levelStartFlag", false);
        }
    }

    collisionEvent() {
    }
}class Trampoline extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler) {
        super(x, y, tileSize, type);
        this.player = tilemapHandler.player;
        this.tilemapHandler = tilemapHandler;
        this.unfoldedAnimationDuration = 5 * AnimationHelper.walkingFrameDuration;
        this.currentAnimationFrame = this.unfoldedAnimationDuration;
    }

    collisionEvent() {
        if (this.player.yspeed > 0) {
            this.tilemapHandler.levelObjects.forEach(levelObject => {
                if (levelObject.type === ObjectTypes.TRAMPOLINE) {
                    levelObject.currentAnimationFrame = this.unfoldedAnimationDuration;
                }
            });
            AnimationHelper.setSquishValues(this, this.tileSize * 0.8,
                this.tileSize * 1.2, 7);
            this.player.setStretchAnimation();
            this.player.onTrampoline = true;
            this.player.jumpframes = 0;
            this.player.currentDashFrame = 0;
            this.currentAnimationFrame = 0;
            SoundHandler.longJump.stopAndPlay();
        }
    }

    draw(spriteCanvas) {
        this.currentAnimationFrame++;
        if (this.currentAnimationFrame < this.unfoldedAnimationDuration) {
            if (this.currentAnimationFrame === this.player.maxJumpFrames + this.player.extraTrampolineJumpFrames || this.currentAnimationFrame === this.unfoldedAnimationDuration - 1) {
                this.player.onTrampoline = false;
            }
            super.drawSingleSquishingFrame(spriteCanvas, this.tileSize);
        }
        else {
            super.drawSingleSquishingFrame(spriteCanvas, 0);
            this.currentAnimationFrame = this.unfoldedAnimationDuration;
        }
    }
}class Npc extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, 0, extraAttributes);
        this.upReleased = true;
        this.key = this.makeid(5);
        this.arrowUpFrameIndex = 0;
        this.upButtonReleased = false;
    }

    collisionEvent() {
        player.collidingWithNpcId = this.key;

        this.arrowUpFrameIndex++;
        const frameModulo = this.arrowUpFrameIndex % 60;
        if (frameModulo < 30) {
            DialogueHandler.showDialogueUpArrow(this.x, this.y - this.tileSize);
        }
        if (!Controller.jump) {
            this.upButtonReleased = true;
        }
        else {
            if (this.upButtonReleased && !DialogueHandler.active) {
                const parsedDialogue = [];
                this.dialogue.forEach(singleDialogue => {
                    const singleDialogueObject = DialogueHandler.createDialogObject(singleDialogue);
                    if (singleDialogueObject.textLength > 0) {
                        parsedDialogue.push(singleDialogueObject);
                    }
                });
                if (parsedDialogue.length > 0) {
                    DialogueHandler.dialogue = parsedDialogue;
                    DialogueHandler.active = true;
                    DialogueHandler.calculateDialogueWindowPosition();
                    SoundHandler.dialogueSound.stopAndPlay();
                    player.xspeed = 0;
                    player.yspeed = 0;
                }
            }
            this.upButtonReleased = false;
        }
    }

    draw(spriteCanvas) {
        if (player.collidingWithNpcId === this.key && !Collision.objectsColliding(player, this)) {
            player.collidingWithNpcId = null;
            this.arrowUpFrameIndex = 0;
            this.upButtonReleased = false;
        }
        super.draw(spriteCanvas);
    }
}class ShootingObject extends InteractiveLevelObject{

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, 0, extraAttributes);
        this.tileMapHandler = tilemapHandler;
    }

    getShootFrames() {
        const frequency = this[SpritePixelArrays.changeableAttributeTypes.frequency];
        const step = this.tileMapHandler.generalFrameCounterMax / frequency;
        const shootFrames = [];
        for (var i = 1; i <= frequency; i++) {
            shootFrames.push(Math.round(step * i));
        }
        this.shootFrames = shootFrames;
    }
}class Canon extends ShootingObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, tilemapHandler, extraAttributes);
        this.tileMapHandler.tileMap[this.y / this.tileSize][this.x / this.tileSize] = ObjectTypes.SPECIAL_BLOCK_VALUES.canon;
        this.getShootFrames();
    }

    draw(spriteCanvas) {
        super.drawWithSquishing(spriteCanvas);
        if (this.shootFrames.includes(this.tileMapHandler.currentGeneralFrameCounter)) {
            var canonBallX = this.initialX - 1;
            var canonBallY = this.initialY;
            var { top, right, bottom } = AnimationHelper.facingDirections;
            if (this.currentFacingDirection === top) {
                canonBallX = this.initialX;
                canonBallY = this.initialY - 1;
            }
            else if (this.currentFacingDirection === right) {
                canonBallX = this.initialX + 1;
                canonBallY = this.initialY;
            }
            else if (this.currentFacingDirection === bottom) {
                canonBallX = this.initialX;
                canonBallY = this.initialY + 1;
            }
            var canonBallStartingTile = this.tileMapHandler.getTileLayerValueByIndex(canonBallY, canonBallX);
            if (canonBallStartingTile === 0 || canonBallStartingTile === 5) {
                const canonBall = new CanonBall(canonBallX, canonBallY, this.tileSize, ObjectTypes.CANON_BALL,
                    this.tileMapHandler, this.currentFacingDirection, this[SpritePixelArrays.changeableAttributeTypes.speed]);
                this.tileMapHandler.levelObjects.push(canonBall);
                AnimationHelper.setSquishValues(this, this.tileSize * 1.2,
                    this.tileSize * 0.8, 5, this.currentFacingDirection);
            }
        }
    }
}class CanonBall extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tileMapHandler, facingDirection, speed = 3) {
        const hitBoxOffset = -tileSize / 6;
        super(x, y, tileSize, type, hitBoxOffset, { currentFacingDirection: facingDirection });
        this.tileMapHandler = tileMapHandler;
        this.facingDirection = facingDirection;
        this.movingSpeed = speed;
        this.yCenter = tileSize / 2;
        this.key = this.makeid(5);
    }

    collisionEvent() {
        PlayMode.playerDeath();
    }

    draw() {
        super.draw(spriteCanvas);
        if (Game.playMode === Game.PLAY_MODE) {

            var { left, top, right } = AnimationHelper.facingDirections;
            if (this.facingDirection === left) {
                this.x -= this.movingSpeed;
                this.checkWallCollission(this.x, this.y + this.yCenter);
            }
            else if (this.facingDirection === top) {
                this.y -= this.movingSpeed;
                this.checkWallCollission(this.x + this.yCenter, this.y);
            }
            else if (this.facingDirection === right) {
                this.x += this.movingSpeed;
                this.checkWallCollission(this.x + this.tileSize, this.y + this.yCenter);
            }
            else {
                this.y += this.movingSpeed;
                this.checkWallCollission(this.x + this.yCenter, this.y + this.tileSize, [0]);
            }
        }
    }

    getTilePositions(x, y) {
        return { xPos: this.tileMapHandler.getTileValueForPosition(x), yPos: this.tileMapHandler.getTileValueForPosition(y) };
    }

    checkWallCollission(x, y, tileArray = [0, 5]) {
        const { xPos, yPos } = this.getTilePositions(x, y);
        var currentTileValue = this.tileMapHandler.getTileLayerValueByIndex(yPos, xPos);
        if (!!typeof currentTileValue === 'undefined' || !tileArray.includes(currentTileValue)) {
            if(currentTileValue === ObjectTypes.SPECIAL_BLOCK_VALUES.redBlueSwitch) {
                const switchBlock = this.tileMapHandler.levelObjects.find(levelObject => levelObject.initialX === xPos && levelObject.initialY === yPos);
                switchBlock && switchBlock.switchWasHit(this.facingDirection);
            }
            this.deleteObjectFromLevel(this.tileMapHandler);
        }
    }
}class Stomper extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, -1, extraAttributes);
        this.tilemapHandler = tilemapHandler;
        this.distanceToCheckCollission = tileSize / 2;
        this.speed = 6;
        this.pauseFrames = 20;
        this.currentPauseFrame = 0;
        this.yCheckDistance = this.distanceToCheckCollission;
        this.xCheckDistance = 0;
        this.yspeed = this.speed;
        this.xspeed = 0;
        //can't pass through other stompers
        this.unpassableObjects = [ObjectTypes.STOMPER];
        this.key = this.makeid(5);
        this.resetObject();
        this.handleFacingDirection();
    }

    collisionEvent() {
        PlayMode.playerDeath();
    }

    turnObject() {
        super.turnObject();
        this.handleFacingDirection();
        BuildMode.rearrangeLevelObjectsByXAndYPos();
    }

    updateMovingValues(yCheckDistance, yspeed, xCheckDistance, xspeed) {
        this.yCheckDistance = yCheckDistance;
        this.yspeed = yspeed;
        this.xCheckDistance = xCheckDistance;
        this.xspeed = xspeed;
    }

    handleFacingDirection() {
        if (this.currentFacingDirection === AnimationHelper.facingDirections.bottom) {
            this.updateMovingValues(Math.abs(this.distanceToCheckCollission),
                Math.abs(this.speed), 0, 0);
        }
        else if (this.currentFacingDirection === AnimationHelper.facingDirections.left) {
            this.updateMovingValues(0, 0, -Math.abs(this.distanceToCheckCollission),
                -Math.abs(this.speed));
        }
        else if (this.currentFacingDirection === AnimationHelper.facingDirections.top) {
            this.updateMovingValues(-Math.abs(this.distanceToCheckCollission), -Math.abs(this.speed), 0,
                0);
        }
        else if (this.currentFacingDirection === AnimationHelper.facingDirections.right) {
            this.updateMovingValues(0, 0, Math.abs(this.distanceToCheckCollission),
                Math.abs(this.speed));
        }
    }

    getCenterPosition() {
        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
    }

    checkIfSwitchWasHit() {
        let positionToCheck = this.getCenterPosition();
        if (this.currentFacingDirection === AnimationHelper.facingDirections.bottom) {
            positionToCheck.y = positionToCheck.y + this.tileSize;
        }
        else if (this.currentFacingDirection === AnimationHelper.facingDirections.left) {
            positionToCheck.x = positionToCheck.x - this.tileSize;
        }
        else if (this.currentFacingDirection === AnimationHelper.facingDirections.top) {
            positionToCheck.y = positionToCheck.y - this.tileSize;
        }
        else if (this.currentFacingDirection === AnimationHelper.facingDirections.right) {
            positionToCheck.x = positionToCheck.x + this.tileSize;
        }
        this.tilemapHandler.levelObjects.forEach(levelObject => {
            /*if(levelObject.type === ObjectTypes.RED_BLOCK || levelObject.type === ObjectTypes.BLUE_BLOCK
                && Collision.pointAndObjectColliding(this.getCenterPosition(), levelObject)) {
                this.deleteObjectFromLevel(this.tilemapHandler, false);
            }*/
            if (levelObject.type === ObjectTypes.RED_BLUE_BLOCK_SWITCH
                && Collision.pointAndObjectColliding(positionToCheck, levelObject)) {
                levelObject.switchWasHit(this.currentFacingDirection);
            }
        });
    }

    resetObject() {
        this.resetAttributes();
        this.x = this.initialX * this.tileSize;
        this.y = this.initialY * this.tileSize;
        this.resetSpeed();
    }

    resetAttributes() {
        this.goingBack = false;
        this.active = false;
        this.currentPauseFrame = 0;
    }

    checkIfTileFree(x, y) {
        const currentTile = tileMapHandler.getTileLayerValueByIndex(tileMapHandler.getTileValueForPosition(y),
            tileMapHandler.getTileValueForPosition(x));
        if (this.currentFacingDirection === AnimationHelper.facingDirections.top && !this.goingBack) {
            return currentTile === 0 || currentTile === 5;
        }
        return currentTile === 0;
    }

    checkIfPlayerInTheWay() {
        const startX = this.x + this.distanceToCheckCollission;
        const startY = this.y + this.distanceToCheckCollission;
        //check 200 times if player or a solid tile is in the way. 200 because max level width and height are 99. checkdistance is half a tile
        for (let i = 0; i < 200; i++) {
            const xPosToCheck = startX + i * this.xCheckDistance;
            const yPosToCheck = startY + i * this.yCheckDistance;
            if (Collision.pointAndObjectColliding({ x: xPosToCheck, y: yPosToCheck }, player)) {
                this.active = true;
                break;
            }
            if (!this.checkIfTileFree(xPosToCheck, yPosToCheck)) {
                break;
            }
        }
    }

    resetSpeed() {
        if (this.xspeed !== 0 && Math.abs(this.xspeed) !== this.speed
            || this.yspeed !== 0 && Math.abs(this.yspeed) !== this.speed) {
            this.handleFacingDirection();
        }
    }

    reduceSpeed() {
        this.xspeed = this.xspeed * -1 / 3;
        this.yspeed = this.yspeed * -1 / 3;
    }

    hitWall() {
        if (this.active && !this.goingBack && this.currentPauseFrame === 0) {
            AnimationHelper.setSquishValues(this, this.tileSize * 1.2,
                this.tileSize * 0.8, 7 , this.currentFacingDirection);
            SFXHandler.createSFX(this.x + this.xspeed, this.y + this.yspeed, 1);
            this.currentPauseFrame = this.pauseFrames;
            this.checkIfSwitchWasHit();
            this.reduceSpeed();
        }
        else if (this.goingBack) {
            this.resetAttributes();
            this.resetSpeed();
        }
    }

    hitUnpassableObject(direction, objectCollidedWith) {
        const attacking = this.isAttacking(this);
        const otherObjectStill = this.isStill(objectCollidedWith);
        /*  !(attacking && objectCollidedWith.currentPauseFrame === 0 &&
            this.currentFacingDirection === objectCollidedWith.currentFacingDirection)*/
        if (attacking || (this.goingBack && otherObjectStill)) {
            this.hitWall();
        }
    }

    pauseAfterWallHit() {
        this.currentPauseFrame--;
        if (this.currentPauseFrame === 0) {
            this.goingBack = true;
        }
    }

    goBack() {
        CharacterCollision.checkTileCollisions(this);
        CharacterCollision.checkMovementBasedObjectCollission(this);

        if (this.goingBack) {
            switch (this.currentFacingDirection) {
                case AnimationHelper.facingDirections.bottom:
                    this.y + this.yspeed < this.initialY * this.tileSize && this.resetObject();
                    break;
                case AnimationHelper.facingDirections.top:
                    this.y + this.yspeed > this.initialY * this.tileSize && this.resetObject();
                    break;
                case AnimationHelper.facingDirections.left:
                    this.x + this.xspeed > this.initialX * this.tileSize && this.resetObject();
                    break;
                case AnimationHelper.facingDirections.right:
                    this.x + this.xspeed < this.initialX * this.tileSize && this.resetObject();
            }
        }
    }

    drawSprite(spriteCanvas, secondSprite = false) {
        const showSecond = secondSprite && this?.spriteObject?.[0].animation.length > 1;
        super.drawSingleSquishingFrame(spriteCanvas, showSecond ? this.canvasXSpritePos + this.tileSize : this.canvasXSpritePos);
    }

    stomperActive() {
        CharacterCollision.checkTileCollisions(this);
        CharacterCollision.checkMovementBasedObjectCollission(this);
    }

    isStill(obj) {
        return !obj.active && !obj.goingBack;
    }

    isAttacking(obj) {
        return obj.active && !obj.goingBack && obj.currentPauseFrame === 0;
    }

    draw(spriteCanvas) {
        if (this.isStill(this)) {
            Game.playMode === Game.PLAY_MODE && this.checkIfPlayerInTheWay();
            this.drawSprite(spriteCanvas);
        }
        else if (this.isAttacking(this)) {
            Game.playMode === Game.PLAY_MODE && this.stomperActive();
            this.drawSprite(spriteCanvas, true);
        }
        else if (this.currentPauseFrame > 0) {
            Game.playMode === Game.PLAY_MODE && this.pauseAfterWallHit();
            this.drawSprite(spriteCanvas);
        }
        else if (this.goingBack) {
            Game.playMode === Game.PLAY_MODE && this.goBack();
            this.drawSprite(spriteCanvas);
        }
    }
}class ToggleMine extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tileMapHandler) {
        super(x, y, tileSize, type);
        this.resetObject();
        this.player = tileMapHandler.player;
        this.totalPauseFrames = 12;
    }

    collisionEvent() {
        if (!this.collidedFirstTime) {
            this.collidedFirstTime = true;
        }
        else if (this.deadly) {
            PlayMode.playerDeath();
        }
    }

    resetObject() {
        this.hitBoxOffset = Math.floor(-this.tileSize / 3);
        this.currentPauseFrame = 0;
        this.collidedFirstTime = false;
        this.deadly = false;
    }

    draw() {
        if (this.collidedFirstTime && !Collision.objectsColliding(this.player, this) && !this.currentPauseFrame < this.totalPauseFrames) {
            this.currentPauseFrame++;
        }
        if(this.currentPauseFrame >= this.totalPauseFrames && !this.deadly) {
            this.deadly = true;
            this.hitBoxOffset = Math.floor(-this.tileSize / 6);
        }
        super.drawSingleFrame(spriteCanvas, this.deadly ? this.canvasXSpritePos + this.tileSize : this.canvasXSpritePos);
    }
}class RocketLauncher extends ShootingObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, tilemapHandler, extraAttributes);
        this.getShootFrames();
        this.resetObject();
        const angle = this.tileMapHandlerplayer ? MathHelpers.getAngle(this.tileMapHandlerplayer.x, this.tileMapHandler.player.y, this.x, this.y) : 0;
        this.seeingPlayer = TilemapHelpers.doTwoObjectsSeeEachOther(this, player, this.tileMapHandler, angle);
    }

    resetObject() {
        this.currentShootCounter = 0;
        this.currentShootCounterWhileInactive = this.shootFrames[0];
        this.active = false;
    }

    collisionEvent() {
    }

    draw(spriteCanvas) {
        if (Game.playMode === Game.PLAY_MODE) {
            const angle = this.tileMapHandler.player ? MathHelpers.getAngle(this.tileMapHandler.player.x, this.tileMapHandler.player.y, this.x, this.y) : 0;
            //Check if rocket launcher sees player only every x frames because it's cost-intensive
            if(this.tileMapHandler?.currentGeneralFrameCounter % 6 === 0) {
                this.seeingPlayer = TilemapHelpers.doTwoObjectsSeeEachOther(this, player, this.tileMapHandler, angle);
            }

            if (this.active) {
                this.currentShootCounter++;
                if(!this.seeingPlayer) {
                    this.active = false;
                    if (this.currentShootCounterWhileInactive === this.shootFrames[0]) {
                        this.currentShootCounterWhileInactive = 0;
                    }
                }
                if (this.currentShootCounter === this.shootFrames[0]) {
                    this.currentShootCounter = 0;
                    this.shoot(angle);
                }
            }
            else {
                if (this.seeingPlayer) {
                    this.active = true;
                    this.currentShootCounter = 0;
                    if (this.currentShootCounterWhileInactive === this.shootFrames[0]) {
                        this.shoot(angle);
                    }
                }
                if (this.currentShootCounterWhileInactive < this.shootFrames[0]) {
                    this.currentShootCounterWhileInactive++;
                }
            }
            this.spriteObject?.[0].rotateable ? super.drawWithRotation(spriteCanvas, MathHelpers.getRadians(angle)) : super.drawWithSquishing(spriteCanvas);
        }
        else {
            super.draw(spriteCanvas);
        }
    }

    shoot(angle) {
        this.currentShootCounter = 0;
        const rocket = new Rocket(this.x / this.tileSize, this.y / this.tileSize, this.tileSize, ObjectTypes.ROCKET,
            this.tileMapHandler, this[SpritePixelArrays.changeableAttributeTypes.speed], angle, this[SpritePixelArrays.changeableAttributeTypes.rotationSpeed]);
        this.tileMapHandler.levelObjects.push(rocket);
        AnimationHelper.setSquishValues(this, this.tileSize * 1.2,
            this.tileSize * 0.8, 5, AnimationHelper.facingDirections.left);
    }
}class Rocket extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tileMapHandler, speed = 3, angle = 0, rotationSpeed) {
        const hitBoxOffset = -tileSize / 6;
        super(x, y, tileSize, type, hitBoxOffset);
        this.tileMapHandler = tileMapHandler;
        this.movingSpeed = speed;
        this.key = this.makeid(5);
        this.angle = angle;
        this.rotationSpeed = rotationSpeed;
        this.rotationCounter = 0;
        this.maxRotationCounter = 3;
        this.setInitialPosition();
    }

    setInitialPosition() {
        const radians = MathHelpers.getRadians(this.angle);
        this.x -= Math.cos(radians) * (this.tileSize / 2);
        this.y -= Math.sin(radians) * (this.tileSize / 2);
    }

    collisionEvent() {
        PlayMode.playerDeath();
    }

    checkIfRotationClockWiseFaster(currentAngle, targetAngle) {
        let aroundTheClockFaster = false;
        if (currentAngle > targetAngle) {
            const counterClockWiseDistance = currentAngle - targetAngle;
            const clockWiseDistance = 360 - counterClockWiseDistance;
            if (clockWiseDistance < counterClockWiseDistance) {
                aroundTheClockFaster = true;
            }
        }
        return (currentAngle < targetAngle && targetAngle - currentAngle < 180) || aroundTheClockFaster;
    }
    
    checkCornerCollission(corners, tiles) {
        const foundSolidTileInCollission = corners.find(corner => {
            const xPos = this.tileMapHandler.getTileValueForPosition(corner.x);
            const yPos = this.tileMapHandler.getTileValueForPosition(corner.y);

            const cornerTile = this.tileMapHandler.getTileLayerValueByIndex(yPos, xPos)
            if(cornerTile === ObjectTypes.SPECIAL_BLOCK_VALUES.redBlueSwitch) {
                const switchBlock = this.tileMapHandler.levelObjects.find(levelObject => levelObject.initialX === xPos && levelObject.initialY === yPos);
                switchBlock && switchBlock.switchWasHit();
            }
            return !tiles.includes(cornerTile);
        });
        if (foundSolidTileInCollission) {
            this.deleteObjectFromLevel(this.tileMapHandler);
            return true;
        }
        return false;
    }

    draw(spriteCanvas) {
        this.rotationCounter++;
        const newAngle = this.tileMapHandler?.player ?
            MathHelpers.getAngle(this.tileMapHandler.player.x, this.tileMapHandler.player.y, this.x, this.y) : 0;

        if (this.rotationCounter > this.maxRotationCounter) {
            this.rotationCounter = 0;
            if (Math.abs(newAngle - this.angle) < this.rotationSpeed) {
                this.angle = newAngle;
            }
            else {
                this.angle = MathHelpers.normalizeAngle(this.checkIfRotationClockWiseFaster(this.angle, newAngle) ?
                    this.angle + this.rotationSpeed : this.angle - this.rotationSpeed);
            }
        }

        const radians = MathHelpers.getRadians(this.angle);
        const left = this.x - Math.cos(radians) * this.movingSpeed;
        const top = this.y - Math.sin(radians) * this.movingSpeed;
        const right = left + this.tileSize;
        const bottom = top + this.tileSize;
        const cornerHitBox = 2;

        const corners = [
            { x: left + cornerHitBox, y: top + cornerHitBox },
            { x: right - cornerHitBox, y: top + cornerHitBox },
            { x: right - cornerHitBox, y: bottom - cornerHitBox },
            { x: left + cornerHitBox, y: bottom - cornerHitBox }
        ];
        if (!this.checkCornerCollission(corners, this.angle <= 200 || this.angle >= 340 ? [0, 5] : [0])) {
            super.drawWithRotation(spriteCanvas, radians);
            this.x = left;
            this.y = top;
        }
    }
}class SwitchableBlock extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, color) {
        super(x, y, tileSize, type, -4);
        this.tilemapHandler = tilemapHandler;
        this.color = color;
        this.activeTileIndex = ObjectTypes.SPECIAL_BLOCK_VALUES.switchableBlock;
    }

    setBlockState(tileIndex, activeState) {
        this.tilemapHandler.tileMap[this.y / this.tileSize][this.x / this.tileSize] = tileIndex;
        this.active = activeState;
        this.checkIfPlayerIsInTheWay(activeState);
    }

    checkIfPlayerIsInTheWay(activeState) {
        if (activeState) {
            const { top, right, bottom, left } = this.tilemapHandler.player;
            const positions = [{ y: top, x: right }, { y: top, x: left }, { y: bottom, x: right }, { y: bottom, x: left }];
            const playerAtPosition = positions.find(position => position.x === this.initialX && position.y === this.initialY);
            if (playerAtPosition && Collision.objectsColliding(this.tilemapHandler.player, this)) {
                PlayMode.playerDeath();
            }
        }
    }

    switchActiveState(tileIndex, activeState) {
        this.setBlockState(tileIndex, activeState);
        //Check if colliding with canons at the moment where block became solid.
        //That's more performant than checking if canon collides with it all the time
        this.tilemapHandler.levelObjects.forEach(levelObject => {
            if ((levelObject.type === ObjectTypes.CANON_BALL || levelObject.type === ObjectTypes.ROCKET) && Collision.objectsColliding(levelObject, this)) {
                levelObject.deleteObjectFromLevel(this.tilemapHandler);
            }
        });
    }

    switchChanged(color) {
        color === this.color ? this.switchActiveState(this.activeTileIndex, true) : this.switchActiveState(0, false);
    }

    collisionEvent() {
    }

    draw(spriteCanvas) {
        super.drawSingleFrame(spriteCanvas, this.active ? this.canvasXSpritePos : this.canvasXSpritePos + this.tileSize);
    }
}class RedBlueSwitch extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler) {
        super(x, y, tileSize, type, 2);
        this.tilemapHandler = tilemapHandler;
        this.collided = false;
        this.bottomLineHitBox = { x: this.x, y: this.y + this.height, width: this.width, height: 2 };
        this.checkOtherSwitchesCurrentColor();
        this.tilemapHandler.tileMap[this.y / this.tileSize][this.x / this.tileSize] = ObjectTypes.SPECIAL_BLOCK_VALUES.redBlueSwitch;
        this.key = this.makeid(5);
    }

    checkOtherSwitchesCurrentColor() {
        const result = this?.tilemapHandler?.levelObjects && this.tilemapHandler.levelObjects.find(levelObject => levelObject.type === ObjectTypes.RED_BLUE_BLOCK_SWITCH);
        this.currentlyActiveColor = result?.currentlyActiveColor ? result.currentlyActiveColor : AnimationHelper.switchableBlockColors.red;
    }

    collisionEvent() {
        if (!this.collided) {
            if (player.yspeed <= 0 && 
                (player?.top_right_pos && Collision.pointAndObjectColliding(player.top_right_pos, this.bottomLineHitBox) ||
                player?.top_left_pos && Collision.pointAndObjectColliding(player.top_left_pos, this.bottomLineHitBox))) {
                this.switchWasHit()
            }
        }
    }

    resetObject() {
        if (this.tilemapHandler && !PlayMode.checkActiveCheckPoints()) {
            this.currentlyActiveColor = AnimationHelper.switchableBlockColors.red;
        }
    }

    switchWasHit(direction = AnimationHelper.facingDirections.top) {
        let squishWidth = this.tileSize * 1.2;
        let squishHeight = this.tileSize * 0.8;
        AnimationHelper.setSquishValues(this, squishWidth, squishHeight, 5, direction);

        const { red, blue } = AnimationHelper.switchableBlockColors;
        this.currentlyActiveColor = this.currentlyActiveColor === red ? blue : red;
        this.collided = true;
        this?.tilemapHandler?.levelObjects && this.tilemapHandler.levelObjects.forEach(levelObject => {
            if (levelObject.type === ObjectTypes.RED_BLUE_BLOCK_SWITCH && levelObject.key !== this.key) {
                levelObject.collided = true;
                levelObject.currentlyActiveColor = this.currentlyActiveColor;
                AnimationHelper.setSquishValues(levelObject, squishWidth, squishHeight, 5, direction);
            }
            else if (levelObject.type === ObjectTypes.RED_BLOCK || levelObject.type === ObjectTypes.BLUE_BLOCK) {
                levelObject.switchChanged(this.currentlyActiveColor);
            }
        });
    }

    draw(spriteCanvas) {
        if (this.collided && !Collision.objectsColliding(player, this)) {
            this.collided = false;
        }
        const showSecond = this.currentlyActiveColor === AnimationHelper.switchableBlockColors.blue;
        super.drawSingleSquishingFrame(spriteCanvas, showSecond ? this.canvasXSpritePos + this.tileSize : this.canvasXSpritePos);
    }
}class RedBlock extends SwitchableBlock {

    constructor(x, y, tileSize, type, tilemapHandler) {
        super(x, y, tileSize, type, tilemapHandler, AnimationHelper.switchableBlockColors.red);
        this.setBlockState(this.activeTileIndex, true);
        this.checkCurrentlyActiveBlock();
    }

    resetObject() {
        if(this.tilemapHandler && !PlayMode.checkActiveCheckPoints()) {
            this.setBlockState(this.activeTileIndex, true);
        }
    }

    checkCurrentlyActiveBlock(){
        const result = this?.tilemapHandler?.levelObjects && this.tilemapHandler.levelObjects.find(levelObject => levelObject.type === ObjectTypes.RED_BLUE_BLOCK_SWITCH);
        if(!result) {
            this.setBlockState(this.activeTileIndex, true);
        }
        else if(result.currentlyActiveColor === this.color) {
            this.setBlockState(this.activeTileIndex, true);
        }
        else {
            this.setBlockState(0, false);
        }
    }

    collisionEvent() {
    }
}class BlueBlock extends SwitchableBlock{

    constructor(x, y, tileSize, type, tilemapHandler) {
        super(x, y, tileSize, type, tilemapHandler, AnimationHelper.switchableBlockColors.blue);
        this.setBlockState(0, false);
        this.checkCurrentlyActiveBlock();
    }

    resetObject() {
        if(this.tilemapHandler && !PlayMode.checkActiveCheckPoints()) {
            this.setBlockState(0, false);
        }
    }

    checkCurrentlyActiveBlock(){
        const result = this?.tilemapHandler?.levelObjects && this.tilemapHandler.levelObjects.find(levelObject => levelObject.type === ObjectTypes.RED_BLUE_BLOCK_SWITCH);
        if(result?.currentlyActiveColor === this.color) {
            this.setBlockState(this.activeTileIndex, true);
        }
    }

    collisionEvent() {
    }
}class DisappearingBlock extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tileMapHandler) {
        super(x, y, tileSize, type, 2);
        this.tileMapHandler = tileMapHandler;
        this.player = tileMapHandler.player;
        this.disappearingFrameAmount = 200;
        this.blockNotSolidAt = 40;
        this.disappearingStepsAmount = 4;
        this.disappearingFrameSteps = this.blockNotSolidAt / this.disappearingStepsAmount;
        this.disappearingBoxHeight = this.tileSize / this.disappearingStepsAmount;
        this.resetObject();
    }

    collisionEvent() {
        this.collidedWithPlayer = true;
    }

    resetObject() {
        this.tileMapHandler.tileMap[this.y / this.tileSize][this.x / this.tileSize] = ObjectTypes.SPECIAL_BLOCK_VALUES.disappearingBlock;
        this.currentDisappearingFrame = 0;
        this.collidedWithPlayer = false;
    }

    draw(spriteCanvas) {
        if (this.collidedWithPlayer) {
            this.currentDisappearingFrame++;
            let currentDisappearingDrawFrame = Math.floor((this.blockNotSolidAt - this.currentDisappearingFrame)
                / this.disappearingFrameSteps);

            if (currentDisappearingDrawFrame <= 0) {
                currentDisappearingDrawFrame = 0;
            }

            const currentHeight = currentDisappearingDrawFrame * this.disappearingBoxHeight;
            
            Display.drawImage(spriteCanvas, 0, this.canvasYSpritePos,
                this.tileSize, currentHeight,
                this.x, this.y, this.tileSize, currentHeight);

            if (this.currentDisappearingFrame === this.blockNotSolidAt) {
                this.tileMapHandler.tileMap[this.y / this.tileSize][this.x / this.tileSize] = 0;
            }
            if (this.currentDisappearingFrame >= this.disappearingFrameAmount) {
                let currentlyCollidingWithInteractiveObject = false;
                if (Collision.objectsColliding(this.player, this)) {
                    currentlyCollidingWithInteractiveObject = true;
                }
                this.tileMapHandler.levelObjects.forEach(levelObject => {
                    if (levelObject?.type === ObjectTypes.STOMPER && (levelObject.active || levelObject.goingBack)) {
                        if (Collision.objectsColliding(levelObject, this)) {
                            currentlyCollidingWithInteractiveObject = true;
                        }
                    }
                });
                !currentlyCollidingWithInteractiveObject && this.resetObject();
            }
        }
        else {
            super.draw(spriteCanvas);
        }
    }
}class Portal extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes) {
        const hitBoxOffset = -tileSize / 3;
        super(x, y, tileSize, type, hitBoxOffset);
        this.tilemapHandler = tilemapHandler;
        this.portalTypes = { blue: "blue", orange: "orange" };
        this.portalType = this.portalTypes.blue;
        this.active = true;
        this.maxInactiveFrames = 60;
        this.currentInactiveFrame = this.maxInactiveFrames;
        this.key = this.makeid(5);
        this.touchingPlayer = false;

        const portalsInLevel = this.tilemapHandler.filterObjectsByTypes([ObjectTypes.PORTAL, ObjectTypes.PORTAL2]);

        if (portalsInLevel.length % 2 !== 0 || (extraAttributes && extraAttributes?.portalType === this.portalTypes.orange)) {
            this.setSpriteAttributes(ObjectTypes.PORTAL2)
            this.portalType = this.portalTypes.orange;
        }
        this.updatePortalInWorldDataHandler();
    }

    updatePortalInWorldDataHandler() {
        const currentLevelObjects = WorldDataHandler.levels[this.tilemapHandler.currentLevel].levelObjects;
        for (var i = 0; i < currentLevelObjects.length; i++) {
            if (currentLevelObjects[i].x === this.initialX && currentLevelObjects[i].y === this.initialY) {
                currentLevelObjects[i].extraAttributes = { portalType: this.portalType };
            }
        }
    }

    findOtherExit() {
        const portalsInLevel = this.tilemapHandler.filterObjectsByTypes([ObjectTypes.PORTAL, ObjectTypes.PORTAL2]);
        let indexOfCurrentPortal = portalsInLevel.findIndex(portalInArray => portalInArray.key === this.key);
        let otherExit;

        if (this.portalType === this.portalTypes.blue && portalsInLevel[indexOfCurrentPortal + 1]) {
            otherExit = portalsInLevel[indexOfCurrentPortal + 1];
        }
        else if (this.portalType === this.portalTypes.orange && portalsInLevel[indexOfCurrentPortal - 1]) {
            otherExit = portalsInLevel[indexOfCurrentPortal - 1];
        }
        return otherExit;
    }

    collisionEvent() {
        this.touchingPlayer = true;
        if (this.active && !this.touchingOtherPortals()) {
            AnimationHelper.setSquishValues(this, this.tileSize * 1.2,
                this.tileSize * 0.8, 5, this.currentFacingDirection);
            this.setToInactive();
            const otherExit = this.findOtherExit();
            if (otherExit) {
                otherExit.setToInactive();
                this.tilemapHandler.player.x = otherExit.x + 2;
                this.tilemapHandler.player.y = otherExit.y + 2;
                otherExit.touchingPlayer = true;
                AnimationHelper.setSquishValues(otherExit, this.tileSize * 1.2,
                    this.tileSize * 0.8, 5, this.currentFacingDirection);
            }
        }
    }

    touchingOtherPortals() {
        return this.tilemapHandler.levelObjects.find(levelObject =>
            levelObject.type === ObjectTypes.PORTAL && levelObject.key !== this.key && levelObject.touchingPlayer);
    }

    setToInactive() {
        this.currentInactiveFrame = 0;
        this.active = false;
    }

    draw(spriteCanvas) {
        if (this.touchingPlayer && !Collision.objectsColliding(this.tilemapHandler.player, this)) {
            this.touchingPlayer = false;
        }
        if (this.currentInactiveFrame < this.maxInactiveFrames) {
            AnimationHelper.checkSquishUpdate(this);
            Display.drawImageWithAlpha(spriteCanvas, this.canvasXSpritePos, this.canvasYSpritePos,
                this.tileSize, this.tileSize, this.x - this.squishXOffset, this.y - this.squishYOffset, this.drawWidth, this.drawHeight, 0.5);
            if (this.currentInactiveFrame === this.maxInactiveFrames - 1) {
                this.active = true;
            }
            this.currentInactiveFrame++;
        }
        else {
            super.draw(spriteCanvas);
        }
    }
}class Collectible extends InteractiveLevelObject {

    constructor(x, y, tileSize, type, tilemapHandler, extraAttributes = {}) {
        super(x, y, tileSize, type, 2, extraAttributes);
        this.tileMapHandler = tilemapHandler;
        this.touched = false;
        this.hide = false;
    }

    resetObject() {
        this.hide = false;
        this.touched = false;
    }

    collisionEvent() {
        if (!this.touched && !this.collected) {
            this.touched = true;
            SFXHandler.createSFX(this.x, this.y, 4);
            SoundHandler.pickup.stopAndPlay();
            AnimationHelper.setSquishValues(this, this.tileSize * 1.2,
                this.tileSize * 0.8, 8, AnimationHelper.facingDirections.left);
            if (WorldDataHandler.insideTool) {
                this.hide = true;
            }
            else {
                this.setPersistentAttribute();
            }
        }
    }

    setPersistentAttribute() {
        WorldDataHandler.levels[this.tileMapHandler.currentLevel].levelObjects.forEach(levelObject => {
            if(levelObject.x === this.initialX && levelObject.y === this.initialY && levelObject.type === this.type) {
                levelObject.extraAttributes = { collected: true };
            }
        });
        this.collected = true;
    }

    draw(spriteCanvas) {
        if(this.hide || this.collected) {
            super.drawWithAlpha(spriteCanvas, 0.1);
        }
        else {
            super.draw(spriteCanvas);
        }
    }
}class Deko extends LevelObject {

    constructor(x, y, tileSize, index) {
        super(x,y,tileSize,ObjectTypes.DEKO);
        this.spriteIndex = SpritePixelArrays.getIndexOfSprite(this.type, index);
        this.spriteObject = [SpritePixelArrays.getSpritesByIndex(this.spriteIndex)];
        this.canvasYSpritePos = this.spriteIndex * this.tileSize;
    }
}class SFX {
    constructor(x, y, tileSize, sfxIndex, direction, xspeed = 0, yspeed = 0, reduceAlpha = false, animationLength = 8, growByTimes = 0) {
        this.x = x;
        this.y = y;
        this.width = tileSize;
        this.height = tileSize;
        this.type = ObjectTypes.SFX;
        this.tileSize = tileSize;
        this.xspeed = xspeed;
        this.yspeed = yspeed;
        this.spriteIndex = SpritePixelArrays.getIndexOfSprite(this.type, sfxIndex);
        const sprite = SpritePixelArrays.getSpritesByIndex(this.spriteIndex);
        this.animationFrames = sprite.animation.length;
        this.xCanvasOffset = 0;
        if (direction && sprite.directions) {
            this.xCanvasOffset = sprite.directions.indexOf(direction) * this.animationFrames * this.tileSize;
        }
        this.canvasYSpritePos = this.spriteIndex * this.tileSize;
        this.animationLength = animationLength;
        this.totalAnimationFrames = this.animationLength * this.animationFrames;
        this.currentFrame = 0;
        this.ended = false;
        this.alpha = 1;
        this.alphaReductionStep = 1 / (this.animationFrames * this.animationLength);
        this.reduceAlpha = reduceAlpha;
        this.growByTimes = growByTimes;
        this.growStep = 0;
        this.growAmountByStep = 0;
        if (this.growByTimes > 0) {
            const widthToGrow = this.width * this.growByTimes - this.width;
            this.growAmountByStep = widthToGrow / (this.animationFrames * this.animationLength);
        }
    }

    draw(spriteCanvas) {
        if (this.currentFrame < this.totalAnimationFrames) {
            this.x += this.xspeed;
            this.y += this.yspeed;
            this.alpha -= this.alphaReductionStep;
            if (this.growAmountByStep > 0) {
                this.width += this.growAmountByStep;
                this.height += this.growAmountByStep;
                this.x -= this.growAmountByStep / 2
                this.y -= this.growAmountByStep / 2
            }
            this.reduceAlpha ?
                Display.drawImageWithAlpha(spriteCanvas, Math.floor(this.currentFrame / this.animationLength) * this.tileSize + this.xCanvasOffset,
                    this.canvasYSpritePos, this.tileSize, this.tileSize, this.x, this.y, this.width,
                    this.height, this.alpha) :
                Display.drawImage(spriteCanvas, Math.floor(this.currentFrame / this.animationLength) * this.tileSize + this.xCanvasOffset,
                    this.canvasYSpritePos, this.tileSize, this.tileSize, this.x, this.y, this.width,
                    this.height);
            this.currentFrame++;
        }
        else {
            this.ended = true;
        }
    }
}class SpriteSheetCreator {

    constructor(tileMapHandler, spriteCanvas) {
        this.tileMapHandler = tileMapHandler;
        this.spriteCanvas = spriteCanvas;
        this.spriteCanvasWidth = this.spriteCanvas.width;
        this.spriteCanvasHeight = this.spriteCanvas.height;
        this.flipDirection = {horizontally: "horizontally", vertically: "vertically"};
        this.spriteCtx = this.spriteCanvas.getContext("2d");
        this.createSpriteSheet();
    }

    createSpriteSheet() {
        this.spriteCtx.clearRect(0, 0, this.spriteCanvasWidth, this.spriteCanvasHeight);
        SpritePixelArrays.allSprites().forEach((SpriteObject, spriteObjectIndex) => {
            if (SpriteObject.animation) {
                this.createSprite(SpriteObject, spriteObjectIndex)
            }
        });
    }

    redrawSprite(SpriteObject, spriteObjectIndex) {
        const { tileSize } = this.tileMapHandler;
        this.spriteCtx.clearRect(0, spriteObjectIndex * tileSize, this.spriteCanvasWidth, spriteObjectIndex * tileSize + tileSize);
        this.createSpriteSheet(SpriteObject, spriteObjectIndex)
    }

    createSprite(SpriteObject, spriteObjectIndex){
        if (SpriteObject?.directions) {
            const { right, left, top, bottom } = AnimationHelper.facingDirections;
            if(SpriteObject.directions[0] === bottom || SpriteObject.directions[0] === top) {
                for (var i = 0; i < SpriteObject.directions.length; i++) {
                    if (SpriteObject.directions[i] === left) {
                        let flipppedSprite = i === 0 ? SpriteObject : this.turnSprite(SpriteObject);
                        this.drawAnimation(flipppedSprite.animation, spriteObjectIndex, i);
                    }
                    if (SpriteObject.directions[i] === top) {
                        const turnedSprite = i === 0 ? SpriteObject : this.flipSprite(SpriteObject, this.flipDirection.vertically);
                        this.drawAnimation(turnedSprite.animation, spriteObjectIndex, i);
                    }
                    if (SpriteObject.directions[i] === bottom) {
                        const turnedBottomSprite = i === 0 ? SpriteObject : this.flipSprite(SpriteObject, this.flipDirection.vertically);
                        this.drawAnimation(turnedBottomSprite.animation, spriteObjectIndex, i);
                    }
                    if (SpriteObject.directions[i] === right) {
                        const flipppedSprite = i === 0 ? SpriteObject : this.turnSprite(SpriteObject, true);
                        this.drawAnimation(flipppedSprite.animation, spriteObjectIndex, i);
                    }
                }
            }
            else {
                for (var i = 0; i < SpriteObject.directions.length; i++) {
                    if (SpriteObject.directions[i] === left) {
                        let flipppedSprite = i === 0 ? SpriteObject : this.flipSprite(SpriteObject, this.flipDirection.horizontally);
                        this.drawAnimation(flipppedSprite.animation, spriteObjectIndex, i);
                    }
                    if (SpriteObject.directions[i] === top) {
                        const turnedSprite = i === 0 ? SpriteObject : this.turnSprite(SpriteObject);
                        this.drawAnimation(turnedSprite.animation, spriteObjectIndex, i);
                    }
                    if (SpriteObject.directions[i] === bottom) {
                        const turnedBottomSprite = i === 0 ? SpriteObject : this.turnSprite(SpriteObject, true);
                        this.drawAnimation(turnedBottomSprite.animation, spriteObjectIndex, i);
                    }
                    if (SpriteObject.directions[i] === right) {
                        const flipppedSprite = i === 0 ? SpriteObject : this.flipSprite(SpriteObject, this.flipDirection.horizontally);
                        this.drawAnimation(flipppedSprite.animation, spriteObjectIndex, i);
                    }
                }
            }
        }
        else {
            this.drawAnimation(SpriteObject.animation, spriteObjectIndex);
        }
    }

    //loop variable is there, so you can add more sprite on the same y-axis (f.e. for flipped sprites)
    drawAnimation(animation, yIndex, loop = 0) {
        const { tileSize, pixelArrayUnitSize, pixelArrayUnitAmount } = this.tileMapHandler;
        animation.forEach((SpritePixelArray, spriteIndex) => {
            Display.drawPixelArray(SpritePixelArray.sprite, (spriteIndex + (animation.length * loop)) * tileSize,
                yIndex * tileSize, pixelArrayUnitSize,
                pixelArrayUnitAmount, this.spriteCtx);
        });
    }

    flipSprite(SpritePixelArrayAnimation, flipDirection) {
        let flippedAnimation = [];
        SpritePixelArrayAnimation.animation.map((animationFrame) => {
            if(flipDirection === this.flipDirection.horizontally){
                let  flippedSprite = this.hflip(animationFrame.sprite);
                flippedAnimation.push({ sprite: flippedSprite });
            }
            if(flipDirection === this.flipDirection.vertically){
                let  flippedSprite = this.vflip(animationFrame.sprite);
                flippedAnimation.push({ sprite: flippedSprite });
            }
        });

        let flippedSpriteObject = JSON.parse(JSON.stringify(SpritePixelArrayAnimation));
        flippedSpriteObject.animation = flippedAnimation;
        return flippedSpriteObject;
    }

    turnSprite(SpritePixelArrayAnimation, bigRotation = false) {
        let turnedAnimation = [];
        SpritePixelArrayAnimation.animation.map((animationFrame) => {

            var newArray = [];

            if (bigRotation) {
                newArray = this.rotate270(animationFrame.sprite);
            }
            if (!bigRotation) {
                newArray = this.rotate90(animationFrame.sprite);
            }
            turnedAnimation.push({ sprite: newArray });
        });
        let turnedSpriteObject = JSON.parse(JSON.stringify(SpritePixelArrayAnimation));
        turnedSpriteObject.animation = turnedAnimation;
        return turnedSpriteObject;
    }
    
    hflip(a) {
        const h = a.length;
        let b = new Array(h);

        for (let y = 0; y < h; y++) {
            let w = a[y].length;
            b[y] = new Array(w);
            b[y] = a[y].slice().reverse();
        }

        return b;
    }

    vflip(a) {
        const h = a.length;
        let b = new Array(h);
      
        for (let y = 0; y < h; y++) {
          let w = a[y].length;
          let n = h - 1 - y;
          b[n] = new Array(w);
      
          for (let x = 0; x < w; x++) {
            b[n][x] = a[y][x];
          }
        }
      
        return b;
      }

    rotate90(a) {
        const w = a.length;
        const h = a[0].length;
        let b = new Array(h);

        for (let y = 0; y < h; y++) {
            b[y] = new Array(w);

            for (let x = 0; x < w; x++) {
                b[y][x] = a[w - 1 - x][y];
            }
        }

        return b;
    }

    rotate270(a) {
        const w = a.length;
        const h = a[0].length;
        let b = new Array(h);

        for (let y = 0; y < h; y++) {
            b[y] = new Array(w);

            for (let x = 0; x < w; x++) {
                b[y][x] = a[x][h - 1 - y];
            }
        }

        return b;
    }
}class ObjectTypes {
  static get SPIKE() {
    return 'spike';
  }

  static get TRAMPOLINE() {
    return 'trampoline';
  }

  static get FINISH_FLAG() {
    return 'finishFlag';
  }

  static get FINISH_FLAG_CLOSED() {
    return 'finishFlagClosed';
  }

  static get START_FLAG() {
    return 'startFlag';
  }

  static get PLAYER_IDLE() {
    return 'playerIdle';
  }

  static get PLAYER_JUMP() {
    return 'playerJump';
  }

  static get PLAYER_WALK() {
    return 'playerWalk';
  }

  static get DISAPPEARING_BLOCK() {
    return 'disappearingBlock';
  }

  static get CANON() {
    return 'canon';
  }

  static get CANON_BALL() {
    return 'canonBall';
  }

  static get DEKO() {
    return 'deco';
  }

  static get SFX() {
    return 'sfx';
  }

  static get STOMPER() {
    return 'stomper';
  }

  static get ROCKET_LAUNCHER() {
    return 'rocketLauncher'
  }

  static get ROCKET() {
    return 'rocket'
  }

  static get PORTAL() {
    return 'portal'
  }

  static get PORTAL2() {
    return 'portal2'
  }

  static get CHECKPOINT() {
    return 'checkpoint';
  }

  static get RED_BLUE_BLOCK_SWITCH() {
    return 'redblueblockswitch';
  }

  static get RED_BLOCK() {
    return 'redBlock';
  }

  static get BLUE_BLOCK() {
    return 'blueBlock';
  }

  static get TOGGLE_MINE() {
    return 'toggleMine';
  }

  static get NPC() {
    return 'npc';
  }

  static get PATH() {
    return 'path';
  }

  static get PATH_POINT() {
    return 'pathPoint';
  }

  static get COLLECTIBLE() {
    return 'collectible';
  }

  static get SPECIAL_BLOCK_VALUES() {
    return {
      canon: 14,
      redBlueSwitch: 13,
      switchableBlock: 12,
      disappearingBlock: 11,
    }
  };

  static get objectToClass() {
    return {
      [this.SPIKE]: Spike,
      [this.FINISH_FLAG]: FinishFlag,
      [this.CHECKPOINT]: Checkpoint,
      [this.START_FLAG]: StartFlag,
      [this.TRAMPOLINE]: Trampoline,
      [this.NPC]: Npc,
      [this.DISAPPEARING_BLOCK]: DisappearingBlock,
      [this.DEKO]: Deko,
      [this.STOMPER]: Stomper,
      [this.CANON]: Canon,
      [this.CANON_BALL]: CanonBall,
      [this.SFX]: SFX,
      [this.RED_BLUE_BLOCK_SWITCH]: RedBlueSwitch,
      [this.RED_BLOCK]: RedBlock,
      [this.BLUE_BLOCK]: BlueBlock,
      [this.TOGGLE_MINE]: ToggleMine,
      [this.ROCKET_LAUNCHER]: RocketLauncher,
      [this.PORTAL]: Portal,
      [this.COLLECTIBLE]: Collectible
    };
  }
}class SpritePixelArrays {

  static staticConstructor() {

    this.pathMovementMapper = {
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 6,
      6: 8,
      7: 12,
    };

    this.changeableAttributeFormElements = {
      toggle: "toggle",
    }

    this.changeableAttributeTypes = {
      frequency: "frequency",
      speed: "speed",
      dialogue: "dialogue",
      stopFrames: "stopFrames",
      movementDirection: "movementDirection",
      rotationSpeed: "rotationSpeed",
      collectiblesNeeded: "collectiblesNeeded"
    };

    this.TILE_1 = {
      name: 1,
      descriptiveName: "Left top",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00"],
            ["00AA00", "005500", "005500", "005500", "005500", "005500", "005500", "005500"],
            ["AAFF55", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["00AA00", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["00AA00", "005500", "c26241", "c26241", "e1a45b", "e1a45b", "e1a45b", "e1a45b"],
          ]
      }
      ]
    };

    this.TILE_2 = {
      name: 2,
      descriptiveName: "Middle top",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00"],
            ["005500", "005500", "005500", "005500", "005500", "005500", "005500", "005500"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["c26241", "c26241", "c26241", "c26241", "e1a45b", "e1a45b", "e1a45b", "e1a45b"],
          ]
      }
      ]
    };

    this.TILE_3 = {
      name: 3,
      descriptiveName: "Right top",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00"],
            ["005500", "005500", "005500", "005500", "005500", "005500", "005500", "AAFF55"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "00AA00"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "AAFF55"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "00AA00"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "AAFF55"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "00AA00"],
            ["c26241", "c26241", "c26241", "c26241", "e1a45b", "e1a45b", "005500", "AAFF55"],
          ]
      }
      ]
    };

    this.TILE_4 = {
      name: 4,
      descriptiveName: "Left",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "005500", "fbe7cf", "fbe7cf", "eeb39e", "eeb39e", "eeb39e", "eeb39e"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["AAFF55", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["00AA00", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["00AA00", "005500", "c26241", "c26241", "e1a45b", "e1a45b", "e1a45b", "e1a45b"],
          ]
      }
      ]
    };

    this.TILE_6 = {
      name: 6,
      descriptiveName: "Middle",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["fbe7cf", "fbe7cf", "fbe7cf", "fbe7cf", "eeb39e", "eeb39e", "eeb39e", "eeb39e"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["c26241", "c26241", "c26241", "c26241", "e1a45b", "e1a45b", "e1a45b", "e1a45b"],
          ]
      }
      ]
    };

    this.TILE_7 = {
      name: 7,
      descriptiveName: "Right",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["fbe7cf", "fbe7cf", "fbe7cf", "fbe7cf", "eeb39e", "eeb39e", "005500", "00AA00"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "AAFF55"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "00AA00"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "AAFF55"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "00AA00"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "AAFF55"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "00AA00"],
            ["c26241", "c26241", "c26241", "c26241", "e1a45b", "e1a45b", "005500", "AAFF55"],
          ]
      }
      ]
    };

    this.TILE_8 = {
      name: 8,
      descriptiveName: "Left bottom",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "005500", "fbe7cf", "fbe7cf", "eeb39e", "eeb39e", "eeb39e", "eeb39e"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["AAFF55", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["00AA00", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["AAFF55", "005500", "005500", "005500", "005500", "005500", "005500", "005500"],
            ["00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55"],
          ]
      }
      ]
    };


    this.TILE_9 = {
      name: 9,
      descriptiveName: "Middle bottom",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["fbe7cf", "fbe7cf", "fbe7cf", "fbe7cf", "eeb39e", "eeb39e", "eeb39e", "eeb39e"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["005500", "005500", "005500", "005500", "005500", "005500", "005500", "005500"],
            ["00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55"],
          ]
      }
      ]
    };

    this.TILE_10 = {
      name: 10,
      descriptiveName: "Right bottom",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["fbe7cf", "fbe7cf", "fbe7cf", "fbe7cf", "eeb39e", "eeb39e", "005500", "00AA00"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "AAFF55"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "00AA00"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "AAFF55"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "00AA00"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "AAFF55"],
            ["005500", "005500", "005500", "005500", "005500", "005500", "005500", "00AA00"],
            ["00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55"],
          ]
      }
      ]
    };

    this.TILE_11 = {
      name: 15,
      descriptiveName: "Top and bottom",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00"],
            ["005500", "005500", "005500", "005500", "005500", "005500", "005500", "005500"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["fbe7cf", "f6c992", "f6c992", "f6c992", "ee8764", "ee8764", "ee8764", "c26241"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["eeb39e", "ee8764", "ee8764", "ee8764", "f6c992", "f6c992", "f6c992", "e1a45b"],
            ["005500", "005500", "005500", "005500", "005500", "005500", "005500", "005500"],
            ["AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00"],
          ]
      }
      ]
    };

    this.TILE_12 = {
      name: 16,
      descriptiveName: "Left and right",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "005500", "fbe7cf", "fbe7cf", "eeb39e", "eeb39e", "005500", "AAFF55"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "00AA00"],
            ["AAFF55", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "AAFF55"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "00AA00"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "AAFF55"],
            ["00AA00", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "00AA00"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "AAFF55"],
            ["00AA00", "005500", "c26241", "c26241", "e1a45b", "e1a45b", "005500", "00AA00"],
          ]
      }
      ]
    };

    this.TILE_13 = {
      name: 17,
      descriptiveName: "All sides",
      description: "Just a solid block",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00"],
            ["00AA00", "005500", "005500", "005500", "005500", "005500", "005500", "AAFF55"],
            ["AAFF55", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "00AA00"],
            ["00AA00", "005500", "f6c992", "f6c992", "ee8764", "ee8764", "005500", "AAFF55"],
            ["AAFF55", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "00AA00"],
            ["00AA00", "005500", "ee8764", "ee8764", "f6c992", "f6c992", "005500", "AAFF55"],
            ["AAFF55", "005500", "005500", "005500", "005500", "005500", "005500", "00AA00"],
            ["00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55", "00AA00", "AAFF55"],
          ]
      }
      ]
    };

    this.TILE_5 = {
      name: 5,
      descriptiveName: "One way block",
      description: "The player can jump through it, but will land on it when he falls",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["transp", "e97977", "e97977", "transp", "transp", "e97977", "e97977", "transp"],
            ["d55c5a", "d55c5a", "d55c5a", "e97977", "d55c5a", "d55c5a", "d55c5a", "e97977"],
            ["ba3d3b", "d55c5a", "d55c5a", "e97977", "ba3d3b", "d55c5a", "d55c5a", "e97977"],
            ["transp", "ba3d3b", "ba3d3b", "transp", "transp", "ba3d3b", "ba3d3b", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.TILE_edge = {
      name: "edge",
      descriptiveName: "Edge block",
      description: "Will display on the edge of the game screen",
      animation: [{
        sprite:
          [
            ["b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4"],
            ["6c686c", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "6c686c"],
            ["6c686c", "6c686c", "b3a1b4", "b3a1b4", "b3a1b4", "b3a1b4", "6c686c", "6c686c"],
            ["6c686c", "6c686c", "6c686c", "b3a1b4", "b3a1b4", "6c686c", "6c686c", "6c686c"],
            ["6c686c", "6c686c", "6c686c", "524f52", "524f52", "6c686c", "6c686c", "6c686c"],
            ["6c686c", "6c686c", "524f52", "524f52", "524f52", "524f52", "6c686c", "6c686c"],
            ["6c686c", "524f52", "524f52", "524f52", "524f52", "524f52", "524f52", "6c686c"],
            ["524f52", "524f52", "524f52", "524f52", "524f52", "524f52", "524f52", "524f52"],
          ]
      }
      ]
    };


    this.SPIKE_SPRITE = {
      name: ObjectTypes.SPIKE,
      descriptiveName: "Spike",
      directions: [AnimationHelper.facingDirections.bottom, AnimationHelper.facingDirections.left, AnimationHelper.facingDirections.top, AnimationHelper.facingDirections.right],
      description: "A spike. If you touch it, you die",
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "b3a1b4", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "b3a1b4", "b3a1b4", "transp", "transp", "transp"],
            ["transp", "transp", "b3a1b4", "6c686c", "6c686c", "b3a1b4", "transp", "transp"],
            ["b3a1b4", "b3a1b4", "6c686c", "524f52", "FFFFFF", "6c686c", "b3a1b4", "transp"],
            ["transp", "b3a1b4", "6c686c", "524f52", "524f52", "6c686c", "b3a1b4", "b3a1b4"],
            ["transp", "transp", "b3a1b4", "6c686c", "6c686c", "b3a1b4", "transp", "transp"],
            ["transp", "transp", "transp", "b3a1b4", "b3a1b4", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "b3a1b4", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.CANON_SPRITE = {
      name: ObjectTypes.CANON,
      changeableAttributes: [
        { name: this.changeableAttributeTypes.speed, defaultValue: 3, minValue: 1, maxValue: 10 },
        { name: this.changeableAttributeTypes.frequency, defaultValue: 3, minValue: 1, maxValue: 8 }
      ],
      descriptiveName: "Cannon",
      description: "A cannon. It shoots <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Cannon ball'} }, true)\">cannonballs</span> at certain time intervals. Click on it after placing it again, to change the attributes of the individual cannon.",
      type: this.SPRITE_TYPES.object,
      squishAble: false,
      directions: [AnimationHelper.facingDirections.left, AnimationHelper.facingDirections.top, AnimationHelper.facingDirections.right, AnimationHelper.facingDirections.bottom],
      animation: [{
        sprite:
          [
            ["FFFFFF", "transp", "transp", "transp", "FFFFFF", "FFFFFF", "FFFFFF", "transp"],
            ["FFFFFF", "FFFFFF", "transp", "FFFFFF", "000000", "000000", "000000", "FFFFFF"],
            ["FFFFFF", "000000", "FFFFFF", "000000", "000000", "000000", "000000", "FFFFFF"],
            ["FFFFFF", "000000", "000000", "000000", "000000", "000000", "000000", "FFFFFF"],
            ["FFFFFF", "000000", "000000", "000000", "000000", "000000", "000000", "FFFFFF"],
            ["FFFFFF", "000000", "FFFFFF", "000000", "000000", "000000", "000000", "FFFFFF"],
            ["FFFFFF", "FFFFFF", "transp", "FFFFFF", "000000", "000000", "000000", "FFFFFF"],
            ["FFFFFF", "transp", "transp", "transp", "FFFFFF", "FFFFFF", "FFFFFF", "transp"],
          ]
      }
      ]
    };

    this.FINISH_FLAG_SPRITE = {
      name: ObjectTypes.FINISH_FLAG,
      descriptiveName: "Finish flag",
      changeableAttributes: [
        { name: this.changeableAttributeTypes.collectiblesNeeded, defaultValue: false },
      ],
      description: "The goal of a level. If you touch it, by default you continue to the next level. If you want to specify a custom exit to a different level, click on a set finish flag again. <br/>" +
      "<span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Finish flag closed'} }, true)\">Closed finish flag sprite</span>",
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ["fdfdfd", "208220", "208220", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "208220", "208220", "208220", "208220", "transp", "transp", "transp"],
            ["fdfdfd", "208220", "208220", "208220", "208220", "208220", "208220", "transp"],
            ["fdfdfd", "208220", "208220", "208220", "208220", "transp", "transp", "transp"],
            ["fdfdfd", "208220", "208220", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.FINISH_FLAG_CLOSED_SPRITE = {
      name: ObjectTypes.FINISH_FLAG_CLOSED,
      descriptiveName: "Finish flag closed",
      description: "This sprite will be displayed if the player needs to collect collectibles to access the <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Finish flag'} }, true)\">Finish flag</span> (Can be configured by clicking on a set finish flag in the game screen).",
      hiddenSprite: true,
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ["fdfdfd", "8E8E8E", "8E8E8E", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "8E8E8E", "8E8E8E", "8E8E8E", "8E8E8E", "transp", "transp", "transp"],
            ["fdfdfd", "8E8E8E", "8E8E8E", "8E8E8E", "8E8E8E", "8E8E8E", "8E8E8E", "transp"],
            ["fdfdfd", "8E8E8E", "8E8E8E", "8E8E8E", "8E8E8E", "transp", "transp", "transp"],
            ["fdfdfd", "8E8E8E", "8E8E8E", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.CHECKPOINT_FLAG = {
      name: ObjectTypes.CHECKPOINT,
      descriptiveName: "Checkpoint",
      description: "If the player touches the checkpoint, he will respawn here after a death. If there are multiple checkpoints, the latest one the player touched will become the respawn point.",
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ["fdfdfd", "E3E300", "E3E300", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "E3E300", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "E3E300", "E3E300", "transp", "transp", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "E3E300", "E3E300", "E3E300", "transp", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "E3E300", "E3E300", "E3E300", "E3E300", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      },
      {
        sprite:
          [
            ["fdfdfd", "E3E300", "E3E300", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "E3E300", "E3E300", "transp", "transp", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "E3E300", "E3E300", "E3E300", "E3E300", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "E3E300", "E3E300", "transp", "transp", "transp"],
            ["fdfdfd", "E3E300", "E3E300", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.START_FLAG_SPRITE = {
      name: ObjectTypes.START_FLAG,
      descriptiveName: "Start flag",
      description: "The starting point of a level. You also respawn here, if you die. <br/> If you create multiple start-flags, for non-linear games, you can click on a set start flag again, to declare it as the default start of a level.",
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ["fdfdfd", "d55c5a", "d55c5a", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "transp", "transp", "transp"],
            ["fdfdfd", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "transp"],
            ["fdfdfd", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "transp", "transp", "transp"],
            ["fdfdfd", "d55c5a", "d55c5a", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["fdfdfd", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.RED_BLUE_BLOCK_SWITCH = {
      name: ObjectTypes.RED_BLUE_BLOCK_SWITCH,
      descriptiveName: "Red/blue switch",
      description: "A switch for red/blue tiles. Can be activated by hitting it with your head, or if a stomper/cannon-ball/rocket hits it.",
      type: this.SPRITE_TYPES.object,
      squishAble: false,
      animNotEditale: true,
      animation: [{
        sprite:
          [
            ['FF8E8E', 'FF8E8E', 'FF8E8E', 'FF8E8E', 'FF8E8E', 'FF8E8E', 'FF8E8E', 'FF8E8E'],
            ['FF8E8E', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'AA0000'],
            ['FF8E8E', 'FF1C1C', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FF1C1C', 'FF1C1C', 'AA0000'],
            ['FF8E8E', 'FF1C1C', 'FFFFFF', 'FF1C1C', 'FF1C1C', 'FFFFFF', 'FF1C1C', 'AA0000'],
            ['FF8E8E', 'FF1C1C', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FF1C1C', 'FF1C1C', 'AA0000'],
            ['FF8E8E', 'FF1C1C', 'FFFFFF', 'FF1C1C', 'FF1C1C', 'FFFFFF', 'FF1C1C', 'AA0000'],
            ['FF8E8E', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'FF1C1C', 'AA0000'],
            ['FF8E8E', 'AA0000', 'AA0000', 'AA0000', 'AA0000', 'AA0000', 'AA0000', 'AA0000']

          ]
      },
      {
        sprite:
          [
            ['8E8EFF', '8E8EFF', '8E8EFF', '8E8EFF', '8E8EFF', '8E8EFF', '8E8EFF', '8E8EFF'],
            ['8E8EFF', '1C1CFF', '1C1CFF', '1C1CFF', '1C1CFF', '1C1CFF', '1C1CFF', '0000AA'],
            ['8E8EFF', '1C1CFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', '1C1CFF', '0000AA'],
            ['8E8EFF', '1C1CFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', '1C1CFF', '1C1CFF', '0000AA'],
            ['8E8EFF', '1C1CFF', 'FFFFFF', '1C1CFF', '1C1CFF', 'FFFFFF', '1C1CFF', '0000AA'],
            ['8E8EFF', '1C1CFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', '1C1CFF', '1C1CFF', '0000AA'],
            ['8E8EFF', '1C1CFF', '1C1CFF', '1C1CFF', '1C1CFF', '1C1CFF', '1C1CFF', '0000AA'],
            ['8E8EFF', '0000AA', '0000AA', '0000AA', '0000AA', '0000AA', '0000AA', '0000AA']
          ]
      }
      ]
    };

    this.DISAPPEARING_BLOCK_SPRITE = {
      name: ObjectTypes.DISAPPEARING_BLOCK,
      descriptiveName: "Disappearing block",
      description: "A block that will disappear upon touching it. It will reappear after a certain time.",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["804c51", "9c6853", "f6c992", "f6c992", "9c6853", "804c51", "804c51", "804c51"],
            ["9c6853", "f6c992", "f6c992", "f6c992", "f6c992", "804c51", "f6c992", "9c6853"],
            ["f6c992", "f6c992", "f6c992", "f6c992", "9c6853", "804c51", "9c6853", "9c6853"],
            ["9c6853", "f6c992", "f6c992", "9c6853", "9c6853", "804c51", "804c51", "804c51"],
            ["9c6853", "9c6853", "9c6853", "9c6853", "804c51", "9c6853", "f6c992", "9c6853"],
            ["804c51", "9c6853", "9c6853", "804c51", "9c6853", "f6c992", "f6c992", "9c6853"],
            ["804c51", "804c51", "804c51", "804c51", "9c6853", "9c6853", "9c6853", "804c51"],
            ["804c51", "9c6853", "9c6853", "804c51", "804c51", "804c51", "804c51", "804c51"],
          ]
      }
      ]
    };

    this.RED_BLOCK = {
      name: ObjectTypes.RED_BLOCK,
      descriptiveName: "Red block",
      description: "There are red blocks and blue blocks. Only one them can be active at a time. By touching the switch (in the objects tab), the active tiles can be switched.",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["FF8E8E", "FF8E8E", "FF8E8E", "FF8E8E", "FF8E8E", "FF8E8E", "FF8E8E", "FF8E8E"],
            ["FF8E8E", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "AA0000"],
            ["FF8E8E", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "AA0000"],
            ["FF8E8E", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "AA0000"],
            ["FF8E8E", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "AA0000"],
            ["FF8E8E", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "AA0000"],
            ["FF8E8E", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "FF1C1C", "AA0000"],
            ["FF8E8E", "AA0000", "AA0000", "AA0000", "AA0000", "AA0000", "AA0000", "AA0000"],
          ]
      },
      {
        sprite:
          [
            ["FF1C1C", "FF1C1C", "transp", "FF1C1C", "FF1C1C", "transp", "FF1C1C", "FF1C1C"],
            ["FF1C1C", "transp", "transp", "transp", "transp", "transp", "transp", "FF1C1C"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["FF1C1C", "transp", "transp", "transp", "transp", "transp", "transp", "FF1C1C"],
            ["FF1C1C", "transp", "transp", "transp", "transp", "transp", "transp", "FF1C1C"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["FF1C1C", "transp", "transp", "transp", "transp", "transp", "transp", "FF1C1C"],
            ["FF1C1C", "FF1C1C", "transp", "FF1C1C", "FF1C1C", "transp", "FF1C1C", "FF1C1C"],
          ]
      }
      ]
    };

    this.BLUE_BLOCK = {
      name: ObjectTypes.BLUE_BLOCK,
      descriptiveName: "Blue block",
      description: "There are red blocks and blue blocks. Only one them can be active at a time. By touching the switch (in the objects tab), the active tiles can be switched.",
      type: this.SPRITE_TYPES.tile,
      animation: [{
        sprite:
          [
            ["8E8EFF", "8E8EFF", "8E8EFF", "8E8EFF", "8E8EFF", "8E8EFF", "8E8EFF", "8E8EFF"],
            ["8E8EFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "0000AA"],
            ["8E8EFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "0000AA"],
            ["8E8EFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "0000AA"],
            ["8E8EFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "0000AA"],
            ["8E8EFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "0000AA"],
            ["8E8EFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "1C1CFF", "0000AA"],
            ["8E8EFF", "0000AA", "0000AA", "0000AA", "0000AA", "0000AA", "0000AA", "0000AA"],
          ]
      },
      {
        sprite:
          [
            ["1C1CFF", "1C1CFF", "transp", "1C1CFF", "1C1CFF", "transp", "1C1CFF", "1C1CFF"],
            ["1C1CFF", "transp", "transp", "transp", "transp", "transp", "transp", "1C1CFF"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["1C1CFF", "transp", "transp", "transp", "transp", "transp", "transp", "1C1CFF"],
            ["1C1CFF", "transp", "transp", "transp", "transp", "transp", "transp", "1C1CFF"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["1C1CFF", "transp", "transp", "transp", "transp", "transp", "transp", "1C1CFF"],
            ["1C1CFF", "1C1CFF", "transp", "1C1CFF", "1C1CFF", "transp", "1C1CFF", "1C1CFF"],
          ]
      }
      ]
    };

    this.DEKO_SPRITE = {
      name: ObjectTypes.DEKO,
      type: this.SPRITE_TYPES.deko,
      descriptiveName: "Deco 1",
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "40BF40", "transp", "transp", "transp", "40BF40"],
            ["transp", "40BF40", "transp", "40BF40", "transp", "40BF40", "transp", "40BF40"],
            ["transp", "40BF40", "40BF40", "40BF40", "40BF40", "40BF40", "transp", "40BF40"],
            ["40BF40", "40BF40", "40BF40", "40BF40", "40BF40", "40BF40", "transp", "40BF40"],
          ]
      }
      ]
    };

    this.DEKO_SPRITE2 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 2",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "FF55FF", "FF55FF", "transp"],
            ["transp", "FF5555", "FF5555", "transp", "FF00FF", "transp", "transp", "FF00FF"],
            ["FF5555", "transp", "transp", "FF5555", "transp", "FF00FF", "FF00FF", "transp"],
            ["transp", "FF5555", "FF5555", "transp", "transp", "2B802B", "2B802B", "transp"],
          ]
      }
      ]
    };

    this.DEKO_SPRITE3 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 3",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["FFFFFF", "FFFFFF", "transp", "FFFFFF", "FFFFFF", "transp", "FFFFFF", "FFFFFF"],
            ["FFFFFF", "FFFFFF", "FFFFFF", "0000FF", "0000FF", "FFFFFF", "FFFFFF", "FFFFFF"],
            ["transp", "transp", "transp", "0000FF", "0000FF", "transp", "transp", "transp"],
            ["FFFFFF", "FFFFFF", "55AAFF", "transp", "transp", "55AAFF", "FFFFFF", "FFFFFF"],
            ["FFFFFF", "FFFFFF", "FFFFFF", "55AAFF", "55AAFF", "FFFFFF", "FFFFFF", "FFFFFF"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.DEKO_SPRITE4 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 4",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ["transp", "2B8055", "transp", "15402A", "15402A", "transp", "2B8055", "transp"],
            ["transp", "2B8055", "2B8055", "15402A", "15402A", "2B8055", "2B8055", "transp"],
            ["transp", "transp", "2B8055", "15402A", "15402A", "2B8055", "transp", "transp"],
            ["transp", "transp", "transp", "15402A", "15402A", "transp", "transp", "transp"],
            ["transp", "2B8055", "transp", "15402A", "15402A", "transp", "2B8055", "transp"],
            ["transp", "2B8055", "2B8055", "15402A", "15402A", "2B8055", "2B8055", "transp"],
            ["transp", "transp", "2B8055", "15402A", "15402A", "2B8055", "transp", "transp"],
            ["transp", "transp", "transp", "15402A", "15402A", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.DEKO_SPRITE5 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 5",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["713900", "transp", "transp", "transp", "transp", "transp", "transp", "AA5500"],
            ["713900", "E37100", "E37100", "E37100", "E37100", "E37100", "E37100", "AA5500"],
            ["713900", "transp", "transp", "transp", "transp", "transp", "transp", "AA5500"],
            ["713900", "E37100", "E37100", "E37100", "E37100", "E37100", "E37100", "AA5500"],
            ["713900", "transp", "transp", "transp", "transp", "transp", "transp", "AA5500"],
            ["713900", "E37100", "E37100", "E37100", "E37100", "E37100", "E37100", "AA5500"],
          ]
      }
      ]
    };

    this.DEKO_SPRITE6 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 6",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "55AAFF", "55AAFF", "55AAFF", "55AAFF", "transp", "transp", "transp"],
            ["transp", "55AAFF", "55AAFF", "transp", "55AAFF", "transp", "transp", "transp"],
            ["FFFF8E", "FFFF8E", "55AAFF", "55AAFF", "55AAFF", "transp", "transp", "transp"],
            ["transp", "55AAFF", "55AAFF", "55AAFF", "55AAFF", "55AAFF", "55AAFF", "55AAFF"],
            ["transp", "transp", "55AAFF", "55AAFF", "55AAFF", "55AAFF", "55AAFF", "transp"],
            ["transp", "transp", "transp", "FFFF8E", "FFFF8E", "transp", "transp", "transp"],
          ]
      },
      {
        sprite: [
          ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ['transp', '55AAFF', '55AAFF', '55AAFF', '55AAFF', 'transp', 'transp', 'transp'],
          ['FFFF8E', '55AAFF', '55AAFF', 'transp', '55AAFF', 'transp', 'transp', 'transp'],
          ['transp', 'FFFF8E', '55AAFF', '55AAFF', '55AAFF', 'transp', 'transp', 'transp'],
          ['FFFF8E', '55AAFF', '55AAFF', '55AAFF', '55AAFF', '55AAFF', '55AAFF', '55AAFF'],
          ['transp', 'transp', '55AAFF', '55AAFF', '55AAFF', '55AAFF', '55AAFF', 'transp'],
          ['transp', 'transp', 'transp', 'transp', 'FFFF8E', 'transp', 'transp', 'transp'],
          ['transp', 'transp', 'transp', 'FFFF8E', 'FFFF8E', 'transp', 'transp', 'transp']
        ]
      }
      ]
    };

    this.DEKO_SPRITE7 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 7",
      type: this.SPRITE_TYPES.deko,
      animation: [
        {
          sprite:
            [
              ["2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A"],
              ["transp", "2A2A2A", "transp", "transp", "2A2A2A", "transp", "2A2A2A", "transp"],
              ["transp", "2A2A2A", "transp", "2A2A2A", "transp", "transp", "2A2A2A", "transp"],
              ["transp", "2A2A2A", "transp", "2A2A2A", "2A2A2A", "transp", "2A2A2A", "transp"],
              ["transp", "2A2A2A", "transp", "transp", "2A2A2A", "transp", "2A2A2A", "transp"],
              ["transp", "2A2A2A", "transp", "2A2A2A", "transp", "transp", "2A2A2A", "transp"],
              ["transp", "2A2A2A", "transp", "2A2A2A", "2A2A2A", "transp", "2A2A2A", "transp"],
              ["2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A"],
            ]
        }
      ]
    };

    this.DEKO_SPRITE8 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 8",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ["2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "transp", "2A2A2A", "2A2A2A"],
            ["2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "transp", "2A2A2A", "2A2A2A"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["2A2A2A", "2A2A2A", "transp", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A"],
            ["2A2A2A", "2A2A2A", "transp", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "transp", "2A2A2A", "2A2A2A"],
            ["2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "2A2A2A", "transp", "2A2A2A", "2A2A2A"],
          ]
      }
      ]
    };

    this.DEKO_SPRITE9 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 9",
      type: this.SPRITE_TYPES.deko,
      animation: [
        {
          sprite: [
            ['transp', 'transp', 'transp', 'FF8E1C', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'FF8E1C', 'FFC68E', 'FF8E1C', 'transp', 'transp', 'transp'],
            ['transp', 'FF8E1C', 'FFC68E', 'FFFFC6', 'FFC68E', 'FF8E1C', 'transp', 'transp'],
            ['transp', 'FF8E1C', 'FFC68E', 'FFFFC6', 'FFC68E', 'FF8E1C', 'transp', 'transp'],
            ['transp', '8E8E8E', 'AAAAAA', 'AAAAAA', 'AAAAAA', '8E8E8E', 'transp', 'transp'],
            ['transp', 'transp', '8E8E8E', 'AAAAAA', '8E8E8E', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', '8E8E8E', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', '8E8E8E', 'transp', 'transp', 'transp', 'transp']
          ]
        },
        {
          sprite:
            [
              ["transp", "transp", "transp", "AA5500", "transp", "transp", "transp", "transp"],
              ["transp", "transp", "AA5500", "FF8E1C", "AA5500", "transp", "transp", "transp"],
              ["transp", "AA5500", "FF8E1C", "FFFF8E", "FF8E1C", "AA5500", "transp", "transp"],
              ["transp", "AA5500", "FF8E1C", "FFFF8E", "FF8E1C", "AA5500", "transp", "transp"],
              ["transp", "8E8E8E", "AAAAAA", "AAAAAA", "AAAAAA", "8E8E8E", "transp", "transp"],
              ["transp", "transp", "8E8E8E", "AAAAAA", "8E8E8E", "transp", "transp", "transp"],
              ["transp", "transp", "transp", "8E8E8E", "transp", "transp", "transp", "transp"],
              ["transp", "transp", "transp", "8E8E8E", "transp", "transp", "transp", "transp"]
            ]
        }
      ]
    };

    this.DEKO_SPRITE10 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 10",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', 'transp', 'transp'],
            ['transp', '8EC6FF', 'FFFFFF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', 'transp'],
            ['8EC6FF', 'FFFFFF', '8EC6FF', 'FFFFFF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF'],
            ['8EC6FF', '8EC6FF', 'FFFFFF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF'],
            ['8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', 'FFFFFF', '8EC6FF'],
            ['8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', 'FFFFFF', '8EC6FF', '8EC6FF'],
            ['transp', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', 'transp'],
            ['transp', 'transp', '8EC6FF', '8EC6FF', '8EC6FF', '8EC6FF', 'transp', 'transp']
          ]
      }
      ]
    };

    this.DEKO_SPRITE11 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 11",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "FFC6FF", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "FFC6FF", "FFFFFF", "FFC6FF", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "FFC6FF", "transp", "transp", "FFC6FF", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "FFC6FF", "FFFFFF", "FFC6FF", "transp"],
            ["transp", "transp", "FFC6FF", "transp", "transp", "FFC6FF", "transp", "transp"],
            ["transp", "FFC6FF", "FFFFFF", "FFC6FF", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "FFC6FF", "transp", "transp", "transp", "transp", "transp"]
          ]
      },
      {
        sprite: [
          ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ['transp', 'transp', '393939', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ['transp', '393939', 'FFC6FF', '393939', 'transp', 'transp', 'transp', 'transp'],
          ['transp', 'transp', '393939', 'transp', 'transp', '393939', 'transp', 'transp'],
          ['transp', 'transp', 'transp', 'transp', '393939', 'FFC6FF', '393939', 'transp'],
          ['transp', 'transp', '393939', 'transp', 'transp', '393939', 'transp', 'transp'],
          ['transp', '393939', 'FFC6FF', '393939', 'transp', 'transp', 'transp', 'transp'],
          ['transp', 'transp', '393939', 'transp', 'transp', 'transp', 'transp', 'transp']

        ]
      }
      ]
    };

    this.DEKO_SPRITE12 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 12",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', '0055AA', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', '8EC6FF', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', '8EC6FF', 'C6E3FF', '8EC6FF', 'transp', 'transp', 'transp'],
            ['0055AA', '8EC6FF', 'C6E3FF', 'C6E3FF', 'C6E3FF', '8EC6FF', '0055AA', 'transp'],
            ['transp', 'transp', '8EC6FF', 'C6E3FF', '8EC6FF', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', '8EC6FF', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', '0055AA', 'transp', 'transp', 'transp', 'transp']
          ]
      },
      {
        sprite: [
          ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ['transp', 'transp', 'transp', '003971', 'transp', 'transp', 'transp', 'transp'],
          ['transp', 'transp', 'transp', '0055AA', 'transp', 'transp', 'transp', 'transp'],
          ['transp', 'transp', '0055AA', 'C6E3FF', '0055AA', 'transp', 'transp', 'transp'],
          ['003971', '0055AA', 'C6E3FF', 'C6E3FF', 'C6E3FF', '0055AA', '003971', 'transp'],
          ['transp', 'transp', '0055AA', 'C6E3FF', '0055AA', 'transp', 'transp', 'transp'],
          ['transp', 'transp', 'transp', '0055AA', 'transp', 'transp', 'transp', 'transp'],
          ['transp', 'transp', 'transp', '003971', 'transp', 'transp', 'transp', 'transp']
        ]
      }
      ]
    };

    this.DEKO_SPRITE13 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 13",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };

    this.DEKO_SPRITE14 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 14",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };

    this.DEKO_SPRITE15 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 15",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };

    this.DEKO_SPRITE16 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 16",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };

    this.DEKO_SPRITE17 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 17",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };

    this.DEKO_SPRITE18 = {
      name: ObjectTypes.DEKO,
      descriptiveName: "Deco 18",
      type: this.SPRITE_TYPES.deko,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };

    this.TRAMPOLINE_SRPITE = {
      name: ObjectTypes.TRAMPOLINE,
      descriptiveName: "Trampoline",
      description: "A trampoline. You will jump approximately twice as high when you land on it.",
      animNotEditale: true,
      squishAble: false,
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["e97977", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "e97977"],
            ["e97977", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "e97977"],
            ["transp", "transp", "6c686c", "6c686c", "b3a1b4", "fdfdfd", "transp", "transp"],
            ["transp", "transp", "524f52", "524f52", "524f52", "524f52", "transp", "transp"],
            ["transp", "transp", "6c686c", "6c686c", "b3a1b4", "fdfdfd", "transp", "transp"],
            ["transp", "transp", "524f52", "524f52", "524f52", "524f52", "transp", "transp"],
          ]
      },
      {
        sprite:
          [
            ["e97977", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "e97977"],
            ["e97977", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "e97977"],
            ["transp", "transp", "6c686c", "6c686c", "b3a1b4", "fdfdfd", "transp", "transp"],
            ["transp", "transp", "524f52", "524f52", "524f52", "524f52", "transp", "transp"],
            ["transp", "transp", "6c686c", "6c686c", "b3a1b4", "fdfdfd", "transp", "transp"],
            ["transp", "transp", "524f52", "524f52", "524f52", "524f52", "transp", "transp"],
            ["transp", "transp", "6c686c", "6c686c", "b3a1b4", "fdfdfd", "transp", "transp"],
            ["transp", "transp", "524f52", "524f52", "524f52", "524f52", "transp", "transp"],
          ]
      }
      ]
    };

    this.NPC_SPRITE = {
      name: ObjectTypes.NPC,
      changeableAttributes: [
        { name: this.changeableAttributeTypes.dialogue, defaultValue: [""] },
      ],
      descriptiveName: "Npc",
      description: "An object that can display a dialogue. Click on it again after placing it, to display the dialogue window.",
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['FFAA55', 'FFAA55', 'FFAA55', 'FFAA55', 'FFAA55', 'FFAA55', 'FFAA55', 'AA5500'],
            ['FFAA55', 'FF8E1C', 'FFFFFF', 'FFFFFF', 'FF8E1C', 'FFFFFF', 'FF8E1C', 'AA5500'],
            ['FFAA55', 'FF8E1C', 'FF8E1C', 'FF8E1C', 'FF8E1C', 'FF8E1C', 'FF8E1C', 'AA5500'],
            ['FFAA55', 'FF8E1C', 'FFFFFF', 'FF8E1C', 'FFFFFF', 'FFFFFF', 'FF8E1C', 'AA5500'],
            ['AA5500', 'AA5500', 'AA5500', 'AA5500', 'AA5500', 'AA5500', 'AA5500', 'AA5500'],
            ['transp', 'transp', 'transp', '713900', '713900', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', '713900', '713900', 'transp', 'transp', 'transp'],
          ]
      },
      ]
    };

    this.PATH_SPRITE = {
      name: ObjectTypes.PATH_POINT,
      changeableAttributes: [
        { name: this.changeableAttributeTypes.speed, defaultValue: 3, minValue: 1, maxValue: 7, mapper: this.pathMovementMapper },
        {
          name: this.changeableAttributeTypes.stopFrames, defaultValue: 10, minValue: 0, maxValue: 80, step: 5, descriptiveName: "wait <span data-microtip-size='large'aria-label='The objects on the path will wait that amount of time, if an object reaches the path´s end.'"
            + "data-microtip-position='top-left' role='tooltip' class='songInputInfo'>"
            + "<img src='images/icons/info.svg' alt='info' width='16' height='16'>"
        },
        {
          name: this.changeableAttributeTypes.movementDirection, formElement: this.changeableAttributeFormElements.toggle, defaultValue: AnimationHelper.possibleDirections.forwards,
          options: [{ "true": AnimationHelper.possibleDirections.forwards }, { "false": AnimationHelper.possibleDirections.backwards }]
        },
      ],
      directions: [AnimationHelper.facingDirections.top, AnimationHelper.facingDirections.right],
      descriptiveName: "Path",
      description: "<div>Draw paths, put objects on top and the objects will follow them. Click on an already set path-point to adjust the path's attributes."
        + "<div class='subSection'>"
        + "<details><summary>Compatible objects</summary><div class='marginTop8'><ul style='padding-left: 16px'><li>Finish flag</li><li>Spikes</li><li>Trampolines</li><li>Toggle mine</li><li>Rocket launchers</li><li>Portals</li><li>Collectibles</li></ul></div></details>"
        + "<details class='marginTop8'><summary>Rules</summary><div class='marginTop8'><ul style='padding-left: 16px'><li>Draw paths in a line or in an enclosed 'circle'</li><li>Place as many different objects on them as you want</li><li>You can't draw 2 paths above or beside each other. You need to leave 1 free space inbetween</li></ul></div></details>"
        + "</div></div>",
      type: this.SPRITE_TYPES.object,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['FFFFFF', 'FFFFFF', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'FFFFFF', 'FFFFFF'],
            ['1C1C1C', '1C1C1C', 'transp', '1C1C1C', '1C1C1C', 'transp', '1C1C1C', '1C1C1C'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      },
      ]
    };

    this.PLAYER_IDLE_SPRITE = {
      name: ObjectTypes.PLAYER_IDLE,
      descriptiveName: "Player idle",
      description: "The player sprite that is shown when you are not moving.",
      directions: [AnimationHelper.facingDirections.right, AnimationHelper.facingDirections.left],
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "4080BF", "4080BF", "4080BF", "4080BF", "transp", "transp"],
            ["transp", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF"],
            ["transp", "transp", "EABFBF", "FFFFFF", "80552B", "EABFBF", "80552B", "transp"],
            ["transp", "transp", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "transp"],
            ["transp", "transp", "d55c5a", "d55c5a", "d55c5a", "d55c5a", "transp", "transp"],
            ["transp", "f2cbc9", "transp", "d55c5a", "d55c5a", "transp", "f2cbc9", "transp"],
            ["transp", "transp", "BF8040", "transp", "transp", "BF8040", "transp", "transp"],
          ]
      }
      ]
    };

    this.PLAYER_JUMP_SPRITE = {
      name: ObjectTypes.PLAYER_JUMP,
      descriptiveName: "Player jump",
      description: "The player sprite that is shown when you are jumping.<br/>" +
      "<span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 1'} }, true)\">Jump SFX</span> will be displayed underneath.",
      squishAble: true,
      directions: [AnimationHelper.facingDirections.right, AnimationHelper.facingDirections.left],
      animation: [{
        sprite:
          [
            ["transp", "transp", "4080BF", "4080BF", "4080BF", "4080BF", "transp", "4080BF"],
            ["transp", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "transp"],
            ["transp", "transp", "EABFBF", "FFFFFF", "80552B", "EABFBF", "80552B", "transp"],
            ["transp", "transp", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "transp"],
            ["transp", "EABFBF", "BF4040", "BF4040", "BF4040", "BF4040", "EABFBF", "transp"],
            ["transp", "transp", "transp", "BF4040", "BF4040", "FFAA55", "transp", "transp"],
            ["transp", "transp", "FFAA55", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.PLAYER_WALL_JUMP_SPRITE = {
      name: ObjectTypes.PLAYER_WALL_JUMP,
      descriptiveName: "Player wall jump",
      description: "The player sprite that is shown when you are jumping.",
      squishAble: false,
      directions: [AnimationHelper.facingDirections.right, AnimationHelper.facingDirections.left],
      animation: [{
        sprite:
          [
            ["transp", "transp", "4080BF", "4080BF", "4080BF", "4080BF", "transp", "4080BF"],
            ["transp", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "transp"],
            ["transp", "transp", "EABFBF", "FFFFFF", "80552B", "EABFBF", "80552B", "transp"],
            ["transp", "transp", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "transp"],
            ["transp", "EABFBF", "BF4040", "BF4040", "BF4040", "BF4040", "EABFBF", "transp"],
            ["transp", "transp", "transp", "BF4040", "BF4040", "FFAA55", "transp", "transp"],
            ["transp", "transp", "FFAA55", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.PLAYER_WALK_SPRITE = {
      name: ObjectTypes.PLAYER_WALK,
      descriptiveName: "Player walk",
      description: "The player sprite that is shown when you are running.",
      directions: [AnimationHelper.facingDirections.right, AnimationHelper.facingDirections.left],
      animation: [{
        sprite:
          [
            ["transp", "transp", "4080BF", "4080BF", "4080BF", "4080BF", "transp", "transp"],
            ["transp", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF"],
            ["transp", "transp", "EABFBF", "FFFFFF", "80552B", "EABFBF", "80552B", "transp"],
            ["transp", "transp", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "transp"],
            ["transp", "transp", "BF4040", "BF4040", "BF4040", "BF4040", "EABFBF", "transp"],
            ["transp", "EABFBF", "BF4040", "BF4040", "BF4040", "BF8040", "transp", "transp"],
            ["transp", "transp", "BF8040", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      },
      {
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "4080BF", "4080BF", "4080BF", "4080BF", "transp", "transp"],
            ["transp", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF", "4080BF"],
            ["transp", "transp", "EABFBF", "FFFFFF", "80552B", "EABFBF", "80552B", "transp"],
            ["transp", "transp", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "EABFBF", "transp"],
            ["transp", "transp", "BF4040", "BF4040", "BF4040", "BF4040", "transp", "transp"],
            ["transp", "EABFBF", "BF8040", "BF4040", "BF4040", "transp", "EABFBF", "transp"],
            ["transp", "transp", "transp", "transp", "BF8040", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.CANON_BALL_SPRITE = {
      name: ObjectTypes.CANON_BALL,
      descriptiveName: "Cannon ball",
      directions: [AnimationHelper.facingDirections.left, AnimationHelper.facingDirections.top, AnimationHelper.facingDirections.right, AnimationHelper.facingDirections.bottom],
      description: "A cannonball. The <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Cannon'} }, true)\">cannon</span> shoots it. <br/>" + 
      "When it hits a wall, <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 2'} }, true)\">explosion</span> will be displayed.",
      animation: [{
        sprite:
          [
            ["transp", "transp", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "transp", "transp"],
            ["transp", "FFFFFF", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "FFFFFF", "transp"],
            ["FFFFFF", "ff5e7a", "ff5e7a", "ff5e7a", "FFFFFF", "ff5e7a", "ff5e7a", "FFFFFF"],
            ["FFFFFF", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "FFFFFF", "ff5e7a", "FFFFFF"],
            ["FFFFFF", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "FFFFFF"],
            ["FFFFFF", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "FFFFFF"],
            ["transp", "FFFFFF", "ff5e7a", "ff5e7a", "ff5e7a", "ff5e7a", "FFFFFF", "transp"],
            ["transp", "transp", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "transp", "transp"],
          ]
      }
      ]
    };

    this.STOMPER = {
      name: ObjectTypes.STOMPER,
      type: this.SPRITE_TYPES.object,
      descriptiveName: "Stomper",
      squishAble: false,
      directions: [AnimationHelper.facingDirections.bottom, AnimationHelper.facingDirections.left, AnimationHelper.facingDirections.top, AnimationHelper.facingDirections.right],
      description: "A deadly hazard, that will fly torwards the player, if he is in it's way and move back to it's initial place once it hits a solid block. Can be rotated by clicking on a placed object again.",
      animation: [{
        sprite:
          [
            ['AAAAAA', 'AAAAAA', 'transp', 'AAAAAA', 'AAAAAA', 'transp', 'AAAAAA', 'AAAAAA'],
            ['AAAAAA', '717171', 'transp', '717171', '717171', 'transp', '717171', 'AAAAAA'],
            ['transp', 'transp', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'transp', 'transp'],
            ['AAAAAA', '717171', 'FFFFFF', 'AAAAAA', 'AAAAAA', 'FFFFFF', '717171', 'AAAAAA'],
            ['AAAAAA', '717171', 'FF1C1C', 'AAAAAA', 'AAAAAA', 'FF1C1C', '717171', 'AAAAAA'],
            ['transp', 'transp', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'transp', 'transp'],
            ['AAAAAA', '717171', 'transp', '717171', '717171', 'transp', '717171', 'AAAAAA'],
            ['AAAAAA', 'AAAAAA', 'transp', 'AAAAAA', 'AAAAAA', 'transp', 'AAAAAA', 'AAAAAA']

          ]
      }
      ]
    };

    this.TOGGLE_MINE = {
      name: ObjectTypes.TOGGLE_MINE,
      type: this.SPRITE_TYPES.object,
      descriptiveName: "Toggle mine",
      description: "An object that is harmless at first, but once you step in and out of it, it becomes deadly.",
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'C6C6C6', 'C6C6C6', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'C6C6C6', 'transp', 'transp', 'C6C6C6', 'transp', 'transp'],
            ['transp', 'C6C6C6', 'transp', 'transp', 'transp', 'transp', 'C6C6C6', 'transp'],
            ['transp', 'C6C6C6', 'transp', 'transp', 'transp', 'transp', 'C6C6C6', 'transp'],
            ['transp', 'transp', 'C6C6C6', 'transp', 'transp', 'C6C6C6', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'C6C6C6', 'C6C6C6', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      },
      {
        sprite:
          [
            ['transp', 'transp', 'transp', 'FF1C1C', 'FF1C1C', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'FF1C1C', 'transp', 'transp', 'FF1C1C', 'transp', 'transp'],
            ['transp', 'FF1C1C', 'transp', 'transp', 'transp', 'transp', 'FF1C1C', 'transp'],
            ['FF1C1C', 'transp', 'FFFFFF', 'transp', 'transp', 'FFFFFF', 'transp', 'FF1C1C'],
            ['FF1C1C', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'FF1C1C'],
            ['transp', 'FF1C1C', 'transp', 'transp', 'transp', 'transp', 'FF1C1C', 'transp'],
            ['transp', 'transp', 'FF1C1C', 'transp', 'transp', 'FF1C1C', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FF1C1C', 'FF1C1C', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };

    this.ROCKET_LAUNCHER = {
      name: ObjectTypes.ROCKET_LAUNCHER,
      type: this.SPRITE_TYPES.object,
      descriptiveName: "Rocket launcher",
      changeableAttributes: [
        { name: this.changeableAttributeTypes.speed, defaultValue: 3, minValue: 1, maxValue: 10 },
        { name: this.changeableAttributeTypes.frequency, defaultValue: 3, minValue: 1, maxValue: 8 },
        {
          name: this.changeableAttributeTypes.rotationSpeed, defaultValue: 8, minValue: 0, maxValue: 24, descriptiveName: "rotation speed <span data-microtip-size='large'aria-label='Determines how fast the rockets will rotate to the players direction. 0 = rockets will decide direction once and not turn at all. 24 = basically following the player everywhere.'" 
        + "data-microtip-position='top-left' role='tooltip' class='songInputInfo'>"
            + "<img src='images/icons/info.svg' alt='info' width='16' height='16'>"
        }
      ],
      squishAble: false,
      rotateable: true,
      description: "A rocket-launcher. It shoots <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Rocket'} }, true)\">rockets</span> at certain time intervals that will follow the player. Click on it after placing it again, to change the attributes of the individual cannon.",
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'AAAAAA', 'AAAAAA', 'transp', 'transp'],
            ['AAAAAA', 'AAAAAA', 'FF1C1C', 'FF1C1C', 'AAAAAA', 'AAAAAA', '717171', 'transp'],
            ['AAAAAA', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'AAAAAA', '717171', '717171'],
            ['FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', '717171', '717171'],
            ['FFFFFF', 'FFFFFF', 'FF1C1C', 'FF1C1C', 'FFFFFF', 'FFFFFF', '717171', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      },
      ]
    };

    this.ROCKET = {
      name: ObjectTypes.ROCKET,
      descriptiveName: "Rocket",
      description: "A rocket. The <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Rocket launcher'} }, true)\">rocket launcher</span> shoots it.<br/>" + 
      "When it hits a wall, <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 2'} }, true)\">explosion</span> will be displayed.",
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'FFFFFF', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'transp'],
            ['FF1C1C', 'FF1C1C', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFF8E', 'FF8E1C'],
            ['FF1C1C', 'FF1C1C', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'FFFF8E', 'FF8E1C'],
            ['transp', 'transp', 'transp', 'transp', 'AAAAAA', 'AAAAAA', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'AAAAAA', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      },
      {
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'FFFFFF', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'transp'],
            ['FF1C1C', 'FF1C1C', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'transp', 'FF8E1C'],
            ['FF1C1C', 'FF1C1C', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'AAAAAA', 'transp', 'FF8E1C'],
            ['transp', 'transp', 'transp', 'transp', 'AAAAAA', 'AAAAAA', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'AAAAAA', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      }
      ]
    };
    
    this.PORTAL2 = {
      name: ObjectTypes.PORTAL2,
      type: this.SPRITE_TYPES.object,
      descriptiveName: "Portal 2",
      description: 
      "<b>First Sprite:</b> <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Portal'} }, true)\">Here</span>"
      +"<br/><br/>A portal with 2 exits. <br/>"
      + "Just draw 2 portals on the game screen. The odd one will automatically be the first, the even one the second.",
      squishAble: false,
      hiddenSprite: true,
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'E37100', 'E37100', 'E37100', 'E37100', 'transp', 'transp'],
            ['transp', 'E37100', 'E37100', 'FFAA55', 'FFAA55', 'E37100', 'E37100', 'transp'],
            ['FFFFFF', 'E37100', 'FFAA55', 'FFC68E', 'FFC68E', 'FFAA55', 'E37100', 'FFFFFF'],
            ['FFFFFF', 'E37100', 'FFAA55', 'FFC68E', 'FFC68E', 'FFAA55', 'E37100', 'FFFFFF'],
            ['transp', 'E37100', 'E37100', 'FFAA55', 'FFAA55', 'E37100', 'E37100', 'transp'],
            ['transp', 'transp', 'E37100', 'E37100', 'E37100', 'E37100', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'transp', 'transp'],
          ]
      },
      ]
    };

    this.PORTAL = {
      name: ObjectTypes.PORTAL,
      type: this.SPRITE_TYPES.object,
      descriptiveName: "Portal",
      squishAble: false,
      description: 
      "<b>Second Sprite:</b> <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Portal 2'} }, true)\">Here</span>"
      + "<br/><br/>A portal with 2 exits. <br/>"
      + "Just draw 2 portals on the game screen. The odd one will automatically be the first, the even one the second.",
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'transp', 'transp'],
            ['transp', 'transp', '0071E3', '0071E3', '0071E3', '0071E3', 'transp', 'transp'],
            ['transp', '0071E3', '0071E3', '55AAFF', '55AAFF', '0071E3', '0071E3', 'transp'],
            ['FFFFFF', '0071E3', '55AAFF', '8EC6FF', '8EC6FF', '55AAFF', '0071E3', 'FFFFFF'],
            ['FFFFFF', '0071E3', '55AAFF', '8EC6FF', '8EC6FF', '55AAFF', '0071E3', 'FFFFFF'],
            ['transp', '0071E3', '0071E3', '55AAFF', '55AAFF', '0071E3', '0071E3', 'transp'],
            ['transp', 'transp', '0071E3', '0071E3', '0071E3', '0071E3', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFFF', 'FFFFFF', 'transp', 'transp', 'transp'],
          ]
      },
      ]
    };

    this.COLLECTIBLE = {
      name: ObjectTypes.COLLECTIBLE,
      type: this.SPRITE_TYPES.object,
      descriptiveName: "Collectible",
      description: "They can be placed to give the player an additional challenge. <br/> Inside the tool, the collectibles will reappear if you die or reset the level, in the exported game they are gone forever, once " +
      "<span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 4'} }, true)\">collected</span>.",
      animation: [{
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFC6', 'FFFFC6', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'FFFFC6', 'FFFF8E', 'FFFF8E', 'FFFF55', 'transp', 'transp'],
            ['transp', 'transp', 'FFFFC6', 'FFFF8E', 'FFFF8E', 'FFFF55', 'transp', 'transp'],
            ['transp', 'transp', 'FFFFC6', 'FFFF8E', 'FFFF8E', 'FFFF55', 'transp', 'transp'],
            ['transp', 'transp', 'FFFFC6', 'FFFF8E', 'FFFF8E', 'FFFF55', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFF55', 'FFFF55', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      },
      {
        sprite:
          [
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFC6', 'FFFFC6', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFC6', 'FFFF55', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFC6', 'FFFF55', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFC6', 'FFFF55', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFFC6', 'FFFF55', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'FFFF55', 'FFFF55', 'transp', 'transp', 'transp'],
            ['transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp', 'transp'],
          ]
      },
      ]
    };

    this.SFX1 = {
      name: ObjectTypes.SFX,
      directions: [AnimationHelper.facingDirections.bottom, AnimationHelper.facingDirections.left, AnimationHelper.facingDirections.top, AnimationHelper.facingDirections.right],
      descriptiveName: "SFX 1",
      description: "SFX that shows when the <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Player jump'} }, true)\">player jumps</span>.",
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
          ]
      },
      {
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
          ]
      }
      ]
    };

    this.SFX2 = {
      name: ObjectTypes.SFX,
      descriptiveName: "SFX 2",
      description: "SFX when <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Cannon ball'} }, true)\">cannon ball</span> or " + 
      "<span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Rocket'} }, true)\">rocket</span> hit a wall.",
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      },
      {
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.SFX3 = {
      name: ObjectTypes.SFX,
      descriptiveName: "SFX 3",
      description: "SFX when player dashes",
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "393939", "393939", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "393939", "393939", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      },
      {
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "393939", "transp", "transp", "393939", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "393939", "transp", "transp", "393939", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.SFX4 = {
      name: ObjectTypes.SFX,
      descriptiveName: "Build SFX",
      hiddenEverywhere: true,
      description: "SFX when an object is placed in build mode",
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      },
      ]
    };

    this.SFX5 = {
      name: ObjectTypes.SFX,
      descriptiveName: "SFX 4",
      description: "Plays when the player touches a <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Collectible'} }, true)\">collectible</span>.",
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "transp", "transp", "FFFFFF", "FFFFFF", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      },
      {
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "FFFFFF", "transp", "transp", "transp", "transp", "FFFFFF", "transp"],
            ["transp", "transp", "FFFFFF", "transp", "transp", "FFFFFF", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      }
      ]
    };

    this.SFX6 = {
      name: ObjectTypes.SFX,
      descriptiveName: "SFX 5",
      description: "Used for shaders",
      animation: [{
        sprite:
          [
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "CC66E3", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
            ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ]
      },

      ]
    };
  }

  static allTileSprites() {
    return [
      this.TILE_1,
      this.TILE_2,
      this.TILE_3,
      this.TILE_4,
      this.TILE_6,
      this.TILE_7,
      this.TILE_8,
      this.TILE_9,
      this.TILE_10,
      this.TILE_11,
      this.TILE_12,
      this.TILE_13,
      this.TILE_5,
      this.TILE_edge,
    ];
  }

  static get SPRITE_TYPES() {
    return {
      tile: "tiles",
      object: "objects",
      deko: "deco"
    }
  }

  static get EMPTY_ANIMATION_FRAME() {
    return {
      sprite:
        [
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
          ["transp", "transp", "transp", "transp", "transp", "transp", "transp", "transp"],
        ]
    }
  }

  static getSpritesByIndex(index) {
    return this.allSprites()[index];
  }

  static getSpritesByName(name) {
    return this.allSprites().filter(sprite => sprite.name === name);
  }

  static getSpritesByType(type) {
    return this.allSprites().filter(sprite => sprite.type === type && !sprite.hiddenSprite);
  }

  static getSpritesByDescrpitiveName(descriptiveName) {
    return this.allSprites().filter(sprite => sprite.descriptiveName === descriptiveName);
  }

  static allSprites() {
    return [
      this.TILE_1,
      this.TILE_2,
      this.TILE_3,
      this.TILE_4,
      this.TILE_6,
      this.TILE_7,
      this.TILE_8,
      this.TILE_9,
      this.TILE_10,
      this.TILE_11,
      this.TILE_12,
      this.TILE_13,
      this.TILE_5,
      this.TILE_edge,
      this.START_FLAG_SPRITE,
      this.CHECKPOINT_FLAG,
      this.FINISH_FLAG_SPRITE,
      this.FINISH_FLAG_CLOSED_SPRITE,
      this.SPIKE_SPRITE,
      this.PLAYER_IDLE_SPRITE,
      this.PLAYER_JUMP_SPRITE,
      this.PLAYER_WALK_SPRITE,
      this.TRAMPOLINE_SRPITE,
      this.CANON_SPRITE,
      this.STOMPER,
      this.RED_BLUE_BLOCK_SWITCH,
      this.TOGGLE_MINE,
      this.ROCKET_LAUNCHER,
      this.ROCKET,
      this.NPC_SPRITE,
      this.PATH_SPRITE,
      this.PORTAL,
      this.PORTAL2,
      this.COLLECTIBLE,
      this.CANON_BALL_SPRITE,
      this.RED_BLOCK,
      this.BLUE_BLOCK,
      this.DISAPPEARING_BLOCK_SPRITE,
      this.DEKO_SPRITE,
      this.DEKO_SPRITE2,
      this.DEKO_SPRITE3,
      this.DEKO_SPRITE4,
      this.DEKO_SPRITE5,
      this.DEKO_SPRITE6,
      this.DEKO_SPRITE7,
      this.DEKO_SPRITE8,
      this.DEKO_SPRITE9,
      this.DEKO_SPRITE10,
      this.DEKO_SPRITE11,
      this.DEKO_SPRITE12,
      this.DEKO_SPRITE13,
      this.DEKO_SPRITE14,
      this.DEKO_SPRITE15,
      this.DEKO_SPRITE16,
      this.DEKO_SPRITE17,
      this.DEKO_SPRITE18,
      this.SFX1,
      this.SFX2,
      this.SFX3,
      this.SFX4,
      this.SFX5,
      this.SFX6,
    ];
  }

  static getIndexOfSprite(name, index = 0) {
    let indexInSpriteArray = 0;
    let currentIndexForSameSprites = 0;
    this.allSprites().every((sprite, spriteIndex) => {
      if (sprite.name === name) {
        if (currentIndexForSameSprites === index) {
          indexInSpriteArray = spriteIndex;
          return false;
        }
        else {
          currentIndexForSameSprites++;
        }
      }
      return true;
    });
    return indexInSpriteArray;
  }
}class Sound {

  constructor(src, id = "", loop = false) {
    this.sound = document.createElement("audio");
    this.sound.src = src;
    if(id) {
      this.sound.id = id; 
    }
    this.errorWhileLoading = false;
    this.sound.loop = loop;
    this.sound.setAttribute("preload", "auto");
    this.sound.setAttribute("controls", "none");
    this.sound.onloadeddata = () => this.loadedSrc()
    this.sound.onerror = () => { this.errorWhileLoading = true; };
    this.loaded = false;
    this.sound.style.display = "none";
    document.body.appendChild(this.sound);
  }

  loadedSrc() {
    this.loaded = true;
  }

  stopAndPlay() {
    if (this.loaded) {
      this.sound.currentTime > 0 && this.sound.pause();
      this.sound.currentTime = 0;
      this.sound.play();
    }
  }

  play() {
    if (this.loaded) {
      this.sound.play();
    }
  }

  stop() {
    if (this.loaded) {
      this.sound.pause();
    }
  }
}class SoundHandler {

  static staticConstructor() {
    this.sounds = [
      { key: "shortJump", value: "https://dl.dropbox.com/s/thhejj6335ynghw/jump.wav" },
      { key: "longJump", value: "https://dl.dropbox.com/s/thhejj6335ynghw/jump.wav" },
      { key: "hit", value: "https://dl.dropbox.com/s/geqmtaxvvbw6rot/deth.wav" },
      { key: "win", value: "https://dl.dropbox.com/s/u41lcj4ixq5n6mh/clear.wav" },
      { key: "pickup", value: "https://dl.dropbox.com/s/2mr7i20m43f3j09/pickup.wav" },
      { key: "guiSelect", value: "https://dl.dropbox.com/s/wyxgahb2wwc4hjd/start.wav" },
      { key: "dash", value: "https://dl.dropbox.com/s/3p0sfl4p0q3j0cn/dash.wav" },
      { key: "checkpoint", value: "https://drive.google.com/uc?export=download&id=1aM3MbC-D2lxTnIEqpLoevxsE1WiiAdKQ" },
      { key: "dialogueSound", value: "https://dl.dropbox.com/s/zrudqgqlxv4448t/boombox_speaks.wav" },
      //{ key: "build", value: "https://drive.google.com/uc?export=download&id=1hgwOVAX30LJ9A71xoAU8IGnXwcm6L2Fc"},
      { key: "song", value: "" },
    ];

    this.sounds.forEach(sound => {
      if (sound.key === "song" && WorldDataHandler.insideTool) {
        this.song = new Sound("", "mainSong", true);
      } else {
        this[sound.key] = new Sound(sound.value);
      }
    });
  }

  static setVolume(audoElementId, volume = 1) {
    const sound = document.getElementById(audoElementId);
    if (sound) {
      sound.volume = volume;
    }
  };

  static fadeAudio(audoElementId, interval = 200) {
    if (audoElementId) {
      const sound = document.getElementById(audoElementId);
      if (sound) {
        const fadeAudio = setInterval(() => {
          if ((sound.volume !== 0)) {
            sound.volume -= 0.1;
          }

          if (sound.volume < 0.11) {
            clearInterval(fadeAudio);
          }
        }, interval);
      }
    }
  }
}class EffectsHandler {

    static staticConstructor() {
        this.addEffectButton = document.getElementById("addEffectButton");
        this.existingEffectsEl = document.getElementById("existingEffects");
        this.editingEffects = document.getElementById("editingEffects");
    }

    static addEffect(event) {
        event.preventDefault();
        this.removeEffectTemplate();
    }

    static cancelEffect() {
        this.removeEffectTemplate();
    }

    static removeEffectTemplate() {
        this.editingEffects.innerHTML = "";
        this.addEffectButton.style.display = "block";
    }
    
    static addEffectTemplate() {
        this.addEffectButton.style.display = "none";
        const effectTemplate = CreateHtmlElementsHelper.createEffectTemplate();
        this.editingEffects.append(effectTemplate);
    }
}class DialogueHandler {

    static staticConstructor() {
        this.setDialogueWindowToInactive();
        const dialogueWidthRelativetoCamera = 90;
        const dialogueHeightRelativetoCamera = 70;
        this.dialogueWidth = Camera.viewport.width / 100 * dialogueWidthRelativetoCamera;
        this.dialogueHeight = Camera.viewport.halfHeight / 100 * dialogueHeightRelativetoCamera;
        this.paddingFromBorder = Camera.viewport.width / 100 * (100 - dialogueWidthRelativetoCamera) / 2;
        this.upButtonReleased = false;
        this.animationDurationFrames = 2;
        this.linesAmount = 4;
        this.maxLineLength = 60;
    }

    static setDialogueWindowToInactive() {
        this.active = false;
        this.dialogue = [];
        this.currentIndex = 0;
        this.currentAnimationFrame = 0;
        this.arrowUpFrameIndex = 0;
        this.calculateDialogueWindowPosition();
    }

    static calculateDialogueWindowPosition() {
        this.leftPos = Camera.viewport.left + this.paddingFromBorder;
        this.topPos = Camera.viewport.top + Camera.viewport.height - this.dialogueHeight - this.paddingFromBorder;
    }

    static handleDialogue() {
        if (this.active) {
            const animationLength = this.dialogue[this.currentIndex].textLength * this.animationDurationFrames
            const animationPlaying = this.currentAnimationFrame <= animationLength;
            if (animationPlaying) {
                this.currentAnimationFrame++;
            }
            if (this.upButtonReleased && Controller.jump) {
                //If not all text is visible, by pressing jump all text is shown right away. Otherwise go to next dialogue
                if (animationPlaying) {
                    this.currentAnimationFrame = animationLength;
                } else {
                    if (this.currentIndex < this.dialogue.length - 1) {
                        SoundHandler.dialogueSound.stopAndPlay();
                        this.currentIndex++;
                        this.currentAnimationFrame = 0;
                    }
                    else {
                        this.setDialogueWindowToInactive();
                    }
                }
                this.upButtonReleased = false;
            }
            if (!Controller.jump) {
                this.upButtonReleased = true;
            }
            if (this.active) {
                this.displayDialogue();
            }
        }
    }

    static displayDialogue() {
        const { leftPos, topPos } = this;
        const currentLine = Math.floor(this.currentAnimationFrame / this.animationDurationFrames / this.maxLineLength);

        Display.drawRectangle(leftPos, topPos,
            this.dialogueWidth, this.dialogueHeight, "000000");
        Display.drawRectangleBorder(leftPos, topPos,
            this.dialogueWidth, this.dialogueHeight, "FFFFFF");
        Display.drawLine(leftPos + this.dialogueWidth - 80, topPos, leftPos + this.dialogueWidth - 20, topPos,
            "000000", 2)

        for (var i = 0; i <= currentLine; i++) {
            if(i < this.dialogue[this.currentIndex].lines.length) {
                this.animateText(leftPos, topPos, i);
            }
        }

        this.displayArrowUpIcon();
    }

    static displayArrowUpIcon() {
        const { leftPos, topPos } = this;

        this.arrowUpFrameIndex++;
        const frameModulo = this.arrowUpFrameIndex % 60;
        if (frameModulo < 30) {
            this.showDialogueUpArrow(leftPos + this.dialogueWidth - 60, topPos - 15);
        }
    }

    static animateText(leftPos, topPos, lineIndex) {
        let previousLinesLength = 0;
        const dialoguesLines = this.dialogue[this.currentIndex].lines;
        for(var i = 0; i < lineIndex; i++) {
            previousLinesLength += dialoguesLines[i].length;
        }
        const currentText = dialoguesLines[lineIndex].substring(0,
            Math.ceil(this.currentAnimationFrame / this.animationDurationFrames - previousLinesLength));
        Display.displayText(currentText, leftPos + 20, topPos + 30 + (lineIndex * 30), 17, "#FFFFFF", "left");
    }

    static calculateTextLines(dialogue) {
        let text = dialogue;
        const lines = [];

        for (var i = 0; i < this.linesAmount; i++) {
            if (text.length > 0) {
                if (text.length > this.maxLineLength) {
                    for (let j = this.maxLineLength; j >= 0; j--) {
                        if (text.charAt(j) === " ") {
                            lines.push(text.substr(0, j));
                            text = text.slice(j + 1);
                            break;
                        }
                    }
                }
                else {
                    lines.push(text.substr(0, text.length).trimEnd());
                    text = text.slice(text.length).trimEnd();
                }
            }
        }
        return lines;
    }

    static showDialogueUpArrow(xPos, yPos) {
        const { pixelArrayUnitSize, tileSize } = tileMapHandler;
        const yAnchor = yPos + tileSize - pixelArrayUnitSize;

        Display.drawRectangle(xPos + pixelArrayUnitSize, yAnchor - pixelArrayUnitSize,
            pixelArrayUnitSize * 6, pixelArrayUnitSize, "FFFFFF")
        Display.drawRectangle(xPos + pixelArrayUnitSize * 2, yAnchor - pixelArrayUnitSize * 2,
            pixelArrayUnitSize * 4, pixelArrayUnitSize, "FFFFFF")
        Display.drawRectangle(xPos + pixelArrayUnitSize * 3, yAnchor - pixelArrayUnitSize * 3,
            pixelArrayUnitSize * 2, pixelArrayUnitSize, "FFFFFF")
    }

    static createDialogObject(dialogue) {
        return {
            textLength: dialogue.length,
            lines: this.calculateTextLines(dialogue)
        }
    }
}class SFXHandler {

    static staticConstructor(tileSize, spriteCanvas) {
        this.tileSize = tileSize;
        this.spriteCanvas = spriteCanvas;
        this.sfxAnimations = [];
    }

    static updateSfxAnimations() {
        for (var i = this.sfxAnimations.length - 1; i >= 0; i--) {
            this.sfxAnimations[i].draw(this.spriteCanvas);
            if (this.sfxAnimations[i].ended) { 
                this.sfxAnimations.splice(i, 1);
            }
        }
    }

    static createSFX(x, y, sfxIndex, direction, xspeed = 0, yspeed = 0, reduceAlpha = false, animationLength = 8, growByTimes = 0) {
        const sfxAnimation = new SFX(x, y, this.tileSize, sfxIndex, direction, xspeed, yspeed, reduceAlpha, animationLength, growByTimes);
        this.sfxAnimations.push(sfxAnimation);
    }
  }class ModalHandler {

    static showModal(id) {
        let el = document.getElementById(id);  
        if(Game.playMode === Game.PLAY_MODE){
            Game.changeGameMode();
            el.setAttribute('data-initial-game-mode', Game.PLAY_MODE);
        }
        else {
            el.setAttribute('data-initial-game-mode', Game.BUILD_MODE);
        }
        
        let body = document.querySelector("body");
        let bg = document.createElement("div");
        bg.className = "modal-js-overlay";
        el.classList.add('on');
        body.appendChild(bg);

        const closeButton = document.createElement("img");
        Helpers.addAttributesToHTMLElement(closeButton, { "src": "images/icons/close.svg", 
        "width": 16, "height": 16, "class": "tooltipClose", "id": "modalCloseButton" });
        closeButton.onclick = () => {
            let overlay = body.querySelector(".modal-js-overlay");
            let closeButton = document.getElementById("modalCloseButton");
            body.removeChild(overlay);
            el.classList.remove('on');
            el.removeChild(closeButton);
        };
        el.appendChild(closeButton);
    }

    static closeModal(id) {
        let body = document.querySelector("body");
        let el = document.getElementById(id);
        const initialGameMode = el.getAttribute('data-initial-game-mode');
        if(initialGameMode === Game.PLAY_MODE && Game.playMode === Game.BUILD_MODE) {
            Game.changeGameMode();
        }
        let overlay = body.querySelector(".modal-js-overlay");
        el.classList.remove('on');
        body.removeChild(overlay);
    }
}class PlayerAttributesHandler {

    static staticConstructor(player) {
        this.player = player;
        this.sliderValues = ["groundAcceleration", "air_acceleration", "maxSpeed", "groundFriction", "air_friction", "jumpSpeed"];
        this.checkBoxValues = ["jumpChecked", "wallJumpChecked", dashChecked, runChecked];

        this.sliderValues.forEach(sliderValue => {
            this.setInitialSliderValue(sliderValue);

            this[sliderValue + "Slider"].oninput = (event) => {
                let newValue = Number(event.target.value);
                //If value has decimals, put at least 2 decimals after coma
                this[sliderValue + "Value"].innerHTML = newValue % 1 != 0 ? newValue.toFixed(2) : newValue;

                if(sliderValue === "jumpSpeed") {
                    const jumpValueObj = this.mapJumpSliderValueToRealValue(newValue)[0];
                    newValue = Number(jumpValueObj.jumpSpeed);
                    this.player.maxJumpFrames = jumpValueObj.maxJumpFrames;
                }
                this.player[sliderValue] = newValue;
                this.adjustAccelerationRelatedToSpeed(sliderValue, newValue);
            };
        });

        this.checkBoxValues.forEach(checkBoxValue => {
            this.setInitialCheckboxValue(checkBoxValue);
        });
    }

    static setInitialSliderValue(sliderValue){
        let playerAttrValue = this.player[sliderValue];
        if(sliderValue === "jumpSpeed") {
            const jumpSliderValueObj = this.mapJumpValueToSliderValue(playerAttrValue)[0];
            playerAttrValue = jumpSliderValueObj.sliderValue;
        }
        this[sliderValue + "Slider"] = document.getElementById(sliderValue);
        this[sliderValue + "Slider"].value = playerAttrValue;
        this[sliderValue + "Value"] = document.getElementById(sliderValue + "Value");
        this[sliderValue + "Value"].innerHTML = playerAttrValue;
        this.adjustAccelerationRelatedToSpeed(sliderValue, playerAttrValue);
    }

    static adjustAccelerationRelatedToSpeed(sliderValue, playerAttrValue) {
        if (sliderValue === "maxSpeed") {
            ["groundAcceleration", "air_acceleration"].forEach(accelerationValue => {
                const sliderName = accelerationValue + "Slider"
                const sliderValueBeforeUpdate = this[sliderName].value;
                this[sliderName].max = playerAttrValue;
                this[sliderName].min = playerAttrValue / 100;
                this[sliderName].step = playerAttrValue / 100;
                const sliderValueAfterUpdate = this[sliderName].value;
    
                //if value was shrunk down, because max-speed is smaller then acceleration
                if(sliderValueBeforeUpdate !== sliderValueAfterUpdate) {
                    this[accelerationValue + "Value"].innerHTML = sliderValueAfterUpdate;
                }
            });
        }
    }

    static setInitialCheckboxValue(checkBoxValue) {
        let playerAttrValue = this.player[checkBoxValue];
        this[checkBoxValue + "CheckBox"] = document.getElementById(checkBoxValue);
        this[checkBoxValue + "CheckBox"].checked = playerAttrValue;

        this[checkBoxValue + "CheckBox"].onclick = (event) => {
            if (event.target.checked)
            {
                this.player[checkBoxValue] = true;
                this.updateUniqueCheckboxes(checkBoxValue);
            }
            else {
                this.player[checkBoxValue] = false;
            }
        }
    }

    static updateUniqueCheckboxes(checkBoxValue) {
        if(checkBoxValue === dashChecked) {
            this.updateCheckboxValueFromOutside(runChecked, false);
        }
        else if(checkBoxValue === runChecked) {
            this.updateCheckboxValueFromOutside(dashChecked, false);
        }
    }

    static updateCheckboxValueFromOutside(checkBoxValue, value) {
        this[checkBoxValue + "CheckBox"] = document.getElementById(checkBoxValue);
        this[checkBoxValue + "CheckBox"].checked = value;
        this.player[checkBoxValue] = value;
    }

    static mapJumpValueToSliderValue(value){
        const jumpSpeedObj = jumpSpeedMapValues.filter(jumpSpeedObj => jumpSpeedObj.jumpSpeed === value);
        return jumpSpeedObj;
    }

    static mapJumpSliderValueToRealValue(value) {
        const jumpSpeedObj = jumpSpeedMapValues.filter(jumpSpeedObj => jumpSpeedObj.sliderValue === value);
        return jumpSpeedObj;
    }
}class MathHelpers {
  static getRandomNumberBetweenTwoNumbers(min, max, round = true) {
    const randomNumber = Math.random() * (max - min) + min;
    return round ? Math.floor(randomNumber) : randomNumber;
  }

  static getSometimesNegativeRandomNumber(min, max, round = true) {
    let randomNumber = this.getRandomNumberBetweenTwoNumbers(min, max, round);
    return randomNumber *= Math.round(Math.random()) ? 1 : -1;
  }

  static getAngle(x1, y1, x2, y2) {
    let result = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
    return result < 0 ? 360 + result : result; // range [0, 360)
  }

  static normalizeAngle(newAngle) {
    if (newAngle > 360) {
      return Math.abs(360 - newAngle);
    }
    else if (newAngle < 0) {
      return 360 - newAngle;
    }
    return newAngle;
  }

  static getRadians(angle) {
    return angle * Math.PI / 180;
  }
}class Path {

    constructor(tileMapHandler, speed = 3, stopFrames = 10, movementDirection = AnimationHelper.possibleDirections.forwards) {
        this.tileMapHandler = tileMapHandler;
        this.tileSize = tileMapHandler.tileSize;
        this.pathPoints = [];
        this.objectsOnPath = [];
        this.speed = speed;
        this.recalculateSteps();
        this.startPointKey;
        this.endPointKey;
        this.movementDirection = movementDirection;
        this.stopFrames = stopFrames;
        this.pathVariant = AnimationHelper.pathVariants.singlePoint;
        this.key = TilemapHelpers.makeid(5);
        this.resetAttributes();
    }

    recalculateSteps() {
        this.movementSteps = this.tileSize / this.speed;
        this.currentDirection = this.movementDirection;
    }

    resetAttributes() {
        this.currentMovementStep = 0;
        this.currentDirection = this.movementDirection;
        this.currentStopFrame = this.stopFrames;
    }

    resetObjectsToInitialPosition() {
        this.objectsOnPath.forEach(objectOnPath => {
            objectOnPath.xspeed = 0;
            objectOnPath.yspeed = 0;
            objectOnPath.x = objectOnPath.initialX * this.tileSize;
            objectOnPath.y = objectOnPath.initialY * this.tileSize;
        });
        this.resetAttributes();
    }

    rearrangePathPoints() {
        const endPoints = this.rearrangePathPointsAlignment();

        //line
        if (endPoints.length === 2) {
            const { startPoint, endPoint } = TilemapHelpers.findStartAndEndPointForLine(endPoints);
            this.startPointKey = startPoint.key;
            this.endPointKey = endPoint.key;
            this.pathVariant = AnimationHelper.pathVariants.line;
            this.pathPoints = TilemapHelpers.resortPath(this.pathPoints, startPoint, endPoint);
        }
        //enclosed
        else if (endPoints.length === 0 && this.pathPoints.length !== 1) {
            const { startPoint, endPoint } = TilemapHelpers.findStartAndEndPointForEnclosedPath(this.pathPoints);
            this.pathVariant = AnimationHelper.pathVariants.enclosed;
            this.pathPoints = TilemapHelpers.resortPath(this.pathPoints, startPoint, endPoint);
        }
        //singlepoint
        else {
            this.pathVariant = AnimationHelper.pathVariants.singlePoint;
        }
    }

    checkObjectsOnPath() {
        this.objectsOnPath = [];
        this.pathPoints.forEach(pathPoint => {
            const objectOnPath = this.tileMapHandler?.levelObjects && this.tileMapHandler.levelObjects.find(levelObject =>
                levelObject.initialX === pathPoint.initialX && levelObject.initialY === pathPoint.initialY
            );
            objectOnPath && this.objectsOnPath.push(objectOnPath)
        })
    }

    rearrangePathPointsAlignment() {
        let endPoints = [];
        this.pathPoints.forEach(pathPoint => {
            let rightTouched;
            let leftTouched;
            let topTouched;
            let bottomTouched;
            let neighboursAmount = 0;

            this.pathPoints.forEach(comparingPathPoint => {
                if (pathPoint.key !== comparingPathPoint.key) {
                    if (!rightTouched && (pathPoint.initialY === comparingPathPoint.initialY && pathPoint.initialX + 1 === comparingPathPoint.initialX)) {
                        neighboursAmount++;
                        rightTouched = true;
                    }
                    if (!leftTouched && (pathPoint.initialY === comparingPathPoint.initialY && pathPoint.initialX - 1 === comparingPathPoint.initialX)) {
                        neighboursAmount++;
                        leftTouched = true;
                    }
                    if (!topTouched && (pathPoint.initialX === comparingPathPoint.initialX && pathPoint.initialY - 1 === comparingPathPoint.initialY)) {
                        neighboursAmount++;
                        topTouched = true;
                    }
                    if (!bottomTouched && (pathPoint.initialX === comparingPathPoint.initialX && pathPoint.initialY + 1 === comparingPathPoint.initialY)) {
                        bottomTouched = true;
                        neighboursAmount++;
                    }

                    if (topTouched && bottomTouched) {
                        pathPoint.alignment = AnimationHelper.alignments.vertical;
                    }
                    else if (rightTouched && leftTouched) {
                        pathPoint.alignment = AnimationHelper.alignments.horizontal;
                    }
                    else {
                        pathPoint.alignment = AnimationHelper.alignments.corner;
                    }
                }
            })

            if (this.pathPoints.length !== 1 && neighboursAmount === 1) {
                endPoints.push(pathPoint);
            }
        });
        return endPoints;
    }

    draw(spriteCanvas) {
        this.pathPoints.forEach(pathPoint => {
            pathPoint.draw(spriteCanvas);
        });

        if (Game.playMode === Game.PLAY_MODE) {
            if (this.pathVariant !== AnimationHelper.pathVariants.singlePoint && this.currentStopFrame >= this.stopFrames) {
                if (this.currentMovementStep === 0 && this.pathVariant === AnimationHelper.pathVariants.line) {
                    this.checkIfReversalOfDirectionNeeded();
                }
                if (this.currentStopFrame >= this.stopFrames) {
                    this.getSpeedForObjectsOnPath();
                    this.currentMovementStep++;
                    if (this.currentMovementStep >= this.movementSteps) {
                        this.currentMovementStep = 0;
                    }
                }
            }
            if (this.currentStopFrame < this.stopFrames) {
                this.currentStopFrame++;
            }
        }
    }

    getSpeedForObjectsOnPath() {
        this.objectsOnPath.forEach(objectOnPath => {
            if (this.currentMovementStep === 0) {
                const { currentPathPoint, nextPathPoint } = this.getCurrentAndNextPathPointForObject(objectOnPath);
                this.getNeededSpeedForNextPathPoint(objectOnPath, currentPathPoint, nextPathPoint);
            }
            objectOnPath.x += objectOnPath.xspeed;
            objectOnPath.y += objectOnPath.yspeed;
        });
    }

    getCurrentPathPointIndexForObject(objectOnPath) {
        const tilePosY = this.tileMapHandler.getTileValueForPosition(objectOnPath.y);
        const tilePosX = this.tileMapHandler.getTileValueForPosition(objectOnPath.x);
        return this.pathPoints.findIndex(pathPoint =>
            pathPoint.initialX === tilePosX && pathPoint.initialY === tilePosY
        );
    }

    checkIfReversalOfDirectionNeeded() {
        const { forwards, backwards } = AnimationHelper.possibleDirections;
        loop1:
        for (var i = 0; i < this.objectsOnPath.length; i++) {
            const currentPathIndex = this.getCurrentPathPointIndexForObject(this.objectsOnPath[i]);
            if (currentPathIndex === this.pathPoints.length - 1 && this.currentDirection === forwards
                || currentPathIndex === 0 && this.currentDirection === backwards) {
                this.currentDirection = this.currentDirection === forwards ? backwards : forwards;
                this.currentStopFrame = 0;
                break loop1;
            }
        }
    }

    getCurrentAndNextPathPointForObject(objectOnPath) {
        const { forwards, backwards } = AnimationHelper.possibleDirections;
        const currentPathIndex = this.getCurrentPathPointIndexForObject(objectOnPath);
        let nextPathIndex = this.currentDirection === forwards ?
            currentPathIndex + 1 : currentPathIndex - 1;
        //loop path if at the end
        if (this.pathVariant === AnimationHelper.pathVariants.enclosed) {
            if (currentPathIndex === this.pathPoints.length - 1 && this.currentDirection === forwards) {
                nextPathIndex = 0;
            }
            else if (currentPathIndex === 0 && this.currentDirection === backwards) {
                nextPathIndex = this.pathPoints.length - 1;
            }
        }
        return { currentPathPoint: this.pathPoints[currentPathIndex], nextPathPoint: this.pathPoints[nextPathIndex] };
    }

    getNeededSpeedForNextPathPoint(objectOnPath, currentPathPoint, nextPathPoint) {
        objectOnPath.xspeed = 0;
        objectOnPath.yspeed = 0;

        if (currentPathPoint && nextPathPoint) {
            if (currentPathPoint.initialX < nextPathPoint.initialX) {
                objectOnPath.xspeed = this.speed;
            }
            else if (currentPathPoint.initialX > nextPathPoint.initialX) {
                objectOnPath.xspeed = this.speed * -1;
            }
            else if (currentPathPoint.initialY < nextPathPoint.initialY) {
                objectOnPath.yspeed = this.speed;
            }
            else if (currentPathPoint.initialY > nextPathPoint.initialY) {
                objectOnPath.yspeed = this.speed * -1;
            }
        }
    }
}class PathPoint extends LevelObject {

    constructor(x, y, tileSize, alignment = AnimationHelper.alignments.horizontal) {
        super(x, y, tileSize, ObjectTypes.PATH_POINT);
        this.alignment = alignment;
        this.changeableInBuildMode = true;
        this.key = this.makeid(5);
    }

    getPath() {
        return tileMapHandler?.paths.find(path => {
            return path?.pathPoints.find(pathPoint =>
                pathPoint.key === this.key
            )
        });
    }

    getPathValue(attributeName) {
        return this.getPath()?.[attributeName];
    }

    addChangeableAttribute(attributeName, value) {
        const currentPath = this.getPath();
        currentPath[attributeName] = value;
        currentPath.recalculateSteps();
        WorldDataHandler?.levels[tileMapHandler.currentLevel]?.paths.forEach(path => {
            path.pathPoints.forEach(pathPoint => {
                if (pathPoint.initialX === this.initialX && pathPoint.initialY === this.initialY) {
                    path[attributeName] = value;
                }
            })
        });
    }

    draw(spriteCanvas) {
        const animationLength = this?.spriteObject?.[0].animation.length || 0;
        const cornerAlignment = this.alignment === AnimationHelper.alignments.corner;
        const extraCanvasX = this.alignment === AnimationHelper.alignments.vertical || cornerAlignment
            ? animationLength * this.tileSize : 0;

        if (animationLength > 1 && Game.playMode === Game.PLAY_MODE) {
            const frameModulo = tileMapHandler.currentGeneralFrameCounter % 40;
            this.displaySprite(spriteCanvas, frameModulo < AnimationHelper.defaultFrameDuration ? this.canvasXSpritePos : this.canvasXSpritePos + this.tileSize, extraCanvasX, cornerAlignment);
        }
        else {
            this.displaySprite(spriteCanvas, this.canvasXSpritePos, extraCanvasX, cornerAlignment);
        }
    }

    displaySprite(spriteCanvas, canvasXSpritePos, extraCanvasX, showBothAlignedSpritesOnTop) {
        super.drawSingleFrame(spriteCanvas, canvasXSpritePos + extraCanvasX);
        if (showBothAlignedSpritesOnTop) {
            super.drawSingleFrame(spriteCanvas, canvasXSpritePos);
        }
    }
}class GameStatistics {

    static staticConstructor() {
        this.resetPlayerStatistics();
        this.alreadyStopped = false;
    }

    static resetPlayerStatistics() {
        this.resetTimer();
        this.deathCounter = 0;
    }

    static resetPermanentObjects() {
        WorldDataHandler.levels.forEach(level => {
            level.levelObjects.forEach(levelObject => {
                if (levelObject.type === ObjectTypes.COLLECTIBLE) {
                    levelObject.extraAttributes.collected = false;
                }
            });
        })
    }

    static resetTimer() {
        this.startTime = null;
        this.endTime = null;
        this.timeBetweenPauses = 0;
        this.timesPauseWasPressed = 0;
    }

    static startTimer() {
        if (!this.startTime) {
            this.startTime = new Date();
        }
    }

    static getTimeDifference() {
        const endTime = this.endTime.getTime();
        const startTime = this.startTime.getTime();
        if (startTime > endTime) {
            return null;
        }
        return endTime - startTime + this.timeBetweenPauses;
    }

    static updateTimeBetweenPauses() {
        if (!this.endTime || !this.startTime) {
            return null;
        }
        /*
            The cost of stopping and resuming the game is approximatley 17 milliseconds. Just to initialize date
            Therefore we substract 17 milliseconds the first 3 times the player presses pause.
            If he does it more often, it's "his fault", which is not realistic
        */
        this.timesPauseWasPressed++;
        this.timeBetweenPauses = this.timesPauseWasPressed <= 3 ? this.getTimeDifference() - 17 : this.getTimeDifference();
        this.startTime = null;
        this.endTime = null;
    }

    static getFinalTime() {
        if (!this.endTime || !this.startTime) {
            return null;
        }
        var diff = this.getTimeDifference();

        var msec = diff;
        var hh = Math.floor(msec / 1000 / 60 / 60);
        msec -= hh * 1000 * 60 * 60;
        var mm = Math.floor(msec / 1000 / 60);
        msec -= mm * 1000 * 60;
        var ss = Math.floor(msec / 1000);
        msec -= ss * 1000;
        return hh > 0 ? `${this.leadingZero(hh)}:${this.leadingZero(mm)}:${this.leadingZero(ss)}:${msec}` :
            `${this.leadingZero(mm)}:${this.leadingZero(ss)}:${msec}`;
    }

    static leadingZero(num) {
        return `0${num}`.slice(-2);
    }

    static stopTimer() {
        this.endTime = new Date();
        this.alreadyStopped = true;
    }
}class PauseHandler {

    static staticConstructor() {
        this.options = ["Continue", "Restart game"];
        this.resetPauseHandler();
        this.downArrowReleased = true;
        this.restartedGame = false;
        this.upArrowReleased = true;
        this.restartGameMaxFrames = 50;
        this.justClosedPauseScreen = false;
    }

    static resetPauseHandler() {
        this.paused = false;
        this.currentRestartGameFrameCounter = 0;
        this.currentOptionIndex = 0;
        this.restartedGame = false;
        this.justClosedPauseScreen = true;
    }

    static checkPause() {
        if(!this.paused) {
            if (Controller.enterReleased && Controller.enter && Controller.gamepadIndex !== null || 
                Controller.gamepadIndex === null && Controller.pause && Controller.pauseReleased) {
                this.paused = true;
                GameStatistics.stopTimer();
                GameStatistics.updateTimeBetweenPauses();
                //stop timer
            }
            Controller.pauseReleased = Controller.pause ? false : true;
            Controller.enterReleased = Controller.enter ? false : true;

            if(this.justClosedPauseScreen && !Controller.confirm) {
                this.justClosedPauseScreen = false;
            }
        }
    }

    static handlePause() {
        if(this.paused) {
            const { left, top, width, height } = Camera.viewport;
            Display.drawRectangle(left, top, width, height, WorldDataHandler.backgroundColor);
            Display.displayText("Paused", width / 2, height / 2 - 30, 30, '#' + WorldDataHandler.textColor);
            this.options.forEach((option, index) => {
                Display.displayText(option, width / 2, height / 2 + 20 + index * 30, 15, '#' + WorldDataHandler.textColor);
                if(this.currentOptionIndex === index) {
                    const optionTextLength = Display.measureText(option).width;
                    Display.displayText("►", width / 2 - optionTextLength / 2 - 20, height / 2 + 20 + index * 30, 15, '#' + WorldDataHandler.textColor);
                }
            });

            this.handleRestart();

            if (Controller.enterReleased && Controller.enter && Controller.gamepadIndex !== null || 
                Controller.gamepadIndex === null && Controller.pause && Controller.pauseReleased) {
                GameStatistics.startTimer();
                this.resetPauseHandler();
                //continue timer
            }
            Controller.pauseReleased = Controller.pause ? false : true;
            Controller.enterReleased = Controller.enter ? false : true;

            if(this.upArrowReleased && Controller.up) {
                this.currentOptionIndex--;
            }
            else if(this.downArrowReleased && Controller.down) {
                this.currentOptionIndex++;
            }

            if(this.currentOptionIndex > this.options.length - 1) {
                this.currentOptionIndex = 0;
            }
            else if(this.currentOptionIndex < 0) {
                this.currentOptionIndex = this.options.length - 1;
            }

            this.downArrowReleased = Controller.down ? false : true;
            this.upArrowReleased = Controller.up ? false : true;
            
            if((Controller.confirm || (Controller.gamepadIndex === null && Controller.enter)) && !this.restartedGame) {
                if(this.currentOptionIndex === 1) {
                    this.restartedGame = true;
                    this.currentRestartGameFrameCounter = this.restartGameMaxFrames;
                    SoundHandler.setVolume("mainSong", 0.3);
                    SoundHandler.guiSelect.stopAndPlay();
                }
                else {
                    GameStatistics.startTimer();
                    this.resetPauseHandler();
                }
            }
        }
    }

    static handleRestart() {
        const { left, top, width, height, context } = Camera.viewport;

        if(this.currentRestartGameFrameCounter > 0) {
            Display.drawRectangleWithAlpha(left, top, width, height, WorldDataHandler.backgroundColor, context, 1 - this.currentRestartGameFrameCounter / 100 * 2);
            this.currentRestartGameFrameCounter--;
            if(this.currentRestartGameFrameCounter === 0) {
                PlayMode.startGame();
                this.resetPauseHandler();
                SoundHandler.song.stopAndPlay();
                SoundHandler.setVolume("mainSong", 1);
            }
        }
    }
}class TilemapHelpers {

    static check8DirectionsNeighbours(oX, oY, nX, nY) {
        if (nX === oX && nY === oY - 1) {
            return { x: oX, y: oY - 1, alignment: AnimationHelper.alignments.vertical };
        }
        else if (nX === oX && nY === oY + 1) {
            return { x: oX, y: oY + 1, alignment: AnimationHelper.alignments.vertical };
        }
        else if (nX === oX - 1 && nY === oY) {
            return { x: oX - 1, y: oY + 1, alignment: AnimationHelper.alignments.horizontal };
        }
        else if (nX === oX + 1 && nY === oY) {
            return { x: oX + 1, y: oY + 1, alignment: AnimationHelper.alignments.horizontal };
        }
        else if (nX === oX - 1 && nY === oY - 1) {
            return { x: oX - 1, y: oY - 1, alignment: AnimationHelper.alignments.corner };
        }
        else if (nX === oX + 1 && nY === oY - 1) {
            return { x: oX + 1, y: oY - 1, alignment: AnimationHelper.alignments.corner };
        }
        else if (nX === oX + 1 && nY === oY + 1) {
            return { x: oX + 1, y: oY + 1, alignment: AnimationHelper.alignments.corner };
        }
        else if (nX === oX - 1 && nY === oY + 1) {
            return { x: oX - 1, y: oY + 1, alignment: AnimationHelper.alignments.corner };
        }
        return null;
    }

    static sortArrayByXandY(firstEl, secondEl, firstElDir, secondElDir, firstElPos, secondElPos) {
        const bothStompers = firstEl.type === ObjectTypes.STOMPER && secondEl.type === ObjectTypes.STOMPER;

        if (bothStompers) {
            const { left, top, right, bottom } = AnimationHelper.facingDirections;
            const bottomSame = firstElDir === bottom && secondElDir === bottom || !firstElDir && !secondElDir;
            const topSame = firstElDir === top && secondElDir === top;
            const rightSame = firstElDir === right && secondElDir === right;
            const leftSame = firstElDir === left && secondElDir === left;
            const { x: firstX, y: firstY } = firstElPos;
            const { x: secondX, y: secondY } = secondElPos;

            if (firstY < secondY && bottomSame ||
                firstY > secondY && topSame ||
                firstX < secondX && rightSame ||
                firstX > secondX && leftSame) {
                return -1;
            }
        }
        return 0;
    }

    static resortPath(pathPoints, startPoint, endPoint) {
        let arr = [...pathPoints];
        arr = arr.filter(item => item.key !== startPoint.key);
        arr.unshift(startPoint);

        for (var i = 0; i < arr.length - 1; i++) {
            for (var j = 0; j < arr.length; j++) {
                const neightbourAtDirection = TilemapHelpers.check8DirectionsNeighbours(arr[i].initialX, arr[i].initialY, arr[j].initialX, arr[j].initialY);
                if (!(arr[i].key === startPoint.key && arr[j].key === endPoint.key) &&
                    arr[i + 1].key !== arr[j].key && i + 1 !== j && j > i && neightbourAtDirection &&
                    (neightbourAtDirection.alignment === AnimationHelper.alignments.horizontal || neightbourAtDirection.alignment === AnimationHelper.alignments.vertical)) {
                    var temp = arr[j]
                    arr[j] = arr[i + 1]
                    arr[i + 1] = temp
                }
            }
        }
        return arr;
    }

    static findStartAndEndPointForLine(endpoints) {
        let startPoint = endpoints[0];
        let endPoint = endpoints[1];

        if (startPoint.initialX > endPoint.initialX || (startPoint.initialX === endPoint.initialX && startPoint.initialY > endPoint.initialY)) {
            startPoint = endpoints[1];
            endPoint = endpoints[0];
         }
        return { startPoint, endPoint };
    }

    static findStartAndEndPointForEnclosedPath(pathPoints) {
        //find the highest lane in a path
        const sortedByY = pathPoints.sort((a, b) => a.initialY - b.initialY);
        const highestLane = sortedByY.filter(pathPoint => pathPoint.initialY === sortedByY[0].initialY);

        //sort hightest lane by x
        const sortHightestLaneByX = highestLane.sort((a, b) => b.initialX - a.initialX);

        //idea behind that is, that the pathpoints going from left to right on the highest lane, go clockwise (forwards)
        return { startPoint: sortHightestLaneByX[0], endPoint: sortHightestLaneByX[1] };
    }

    static doTwoObjectsSeeEachOther(obj1, obj2, tilemapHandler, angle) {
        let objectsSeeEachOther = true;
        const dx = obj2.x - obj1.x;
        const dy = obj2.y - obj1.y;
        const checkDistance = tilemapHandler.tileSize / 2;
        const xFrames = Math.abs(Math.round(dx / checkDistance));
        const yFrames = Math.abs(Math.round(dy / checkDistance));
        const biggerFrames = Math.max(xFrames, yFrames);
        const incrementX = dx / biggerFrames;
        const incrementY = dy / biggerFrames;
        for (var frame = 0; frame < biggerFrames - 1; frame++) {
            const xStep = obj1.x + (incrementX * frame);
            const yStep = obj1.y + (incrementY * frame);
            const currentTile = tilemapHandler.getTileLayerValueByIndex(
                tilemapHandler.getTileValueForPosition(yStep),
                tilemapHandler.getTileValueForPosition(xStep));

            const zeroTo360 = (angle + 360) % 360;
            //if going up, can see through one-way platforms
            if (currentTile !== 0 && !(zeroTo360 > 0 && zeroTo360 < 180 && currentTile === 5)) {
                objectsSeeEachOther = false;
                break;
            }
        }
        return objectsSeeEachOther;
    }

    static makeid(length) {
        var result = '';
        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var charactersLength = characters.length;
        for (var i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        return result;
    }
}
        
        const canvas = document.getElementById("myCanvas");
        WorldDataHandler.staticConstructor();
        const spriteCanvas = document.getElementById("sprites");
        SoundHandler.staticConstructor();
        AnimationHelper.staticConstructor();
        SpritePixelArrays.staticConstructor();
        const player = new Player(WorldDataHandler.initialPlayerPosition.x,
            WorldDataHandler.initialPlayerPosition.y, WorldDataHandler.tileSize, spriteCanvas);
        Game.staticConstructor();

        const version = 1.1;
        //initialLevelDataStart
  WorldDataHandler.levels = 
  [{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,11,11,11,6,6,11,11,6,6,0,0,0,0,0,0,0,0,0,0,0,0,2],[1,0,0,0,0,0,0,0,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,5,5,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,1],[1,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":2,"y":15,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"aSv"}},{"x":29,"y":3,"type":"finishFlag","extraAttributes":{}},{"x":4,"y":15,"type":"npc","extraAttributes":{"dialogue":["You're wondering where you are right about now. Well, you're basically in a mysterious laboratory.","This only the beginning. Level 1 to be exact. I'm not sure of what exactly, but it seems like a game here.","Alright. Well, you better get going, eh? Gotta get through this somehow.","By the way, press \"C\" to jump, press \"X\" to dash. Good luck."]}},{"x":11,"y":6,"type":"disappearingBlock","extraAttributes":{}},{"x":12,"y":6,"type":"disappearingBlock","extraAttributes":{}},{"x":13,"y":6,"type":"disappearingBlock","extraAttributes":{}},{"x":16,"y":6,"type":"disappearingBlock","extraAttributes":{}},{"x":17,"y":6,"type":"disappearingBlock","extraAttributes":{}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,2],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,6,6,6,6,6,6,6,6,6,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,6,6,6,0,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,5,5,1],[1,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,0,0,1],[2,0,0,0,6,6,6,6,6,6,6,0,0,0,0,0,0,6,0,0,0,6,5,5,5,5,5,5,5,5,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,11,11,11,6,6,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,6,6,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":1,"y":2,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"ap4"}},{"x":19,"y":16,"type":"spike","extraAttributes":{}},{"x":20,"y":16,"type":"spike","extraAttributes":{}},{"x":21,"y":16,"type":"spike","extraAttributes":{}},{"x":29,"y":13,"type":"disappearingBlock","extraAttributes":{}},{"x":28,"y":13,"type":"disappearingBlock","extraAttributes":{}},{"x":27,"y":13,"type":"disappearingBlock","extraAttributes":{}},{"x":26,"y":16,"type":"spike","extraAttributes":{}},{"x":27,"y":16,"type":"spike","extraAttributes":{}},{"x":28,"y":16,"type":"spike","extraAttributes":{}},{"x":29,"y":16,"type":"spike","extraAttributes":{}},{"x":30,"y":16,"type":"spike","extraAttributes":{}},{"x":31,"y":16,"type":"spike","extraAttributes":{}},{"x":26,"y":15,"type":"spike","extraAttributes":{}},{"x":27,"y":15,"type":"spike","extraAttributes":{}},{"x":28,"y":15,"type":"spike","extraAttributes":{}},{"x":29,"y":15,"type":"spike","extraAttributes":{}},{"x":30,"y":15,"type":"spike","extraAttributes":{}},{"x":31,"y":15,"type":"spike","extraAttributes":{}},{"x":27,"y":14,"type":"spike","extraAttributes":{}},{"x":28,"y":14,"type":"spike","extraAttributes":{}},{"x":29,"y":14,"type":"spike","extraAttributes":{}},{"x":30,"y":14,"type":"spike","extraAttributes":{}},{"x":31,"y":14,"type":"spike","extraAttributes":{}},{"x":25,"y":15,"type":"spike","extraAttributes":{}},{"x":26,"y":14,"type":"spike","extraAttributes":{}},{"x":24,"y":16,"type":"spike","extraAttributes":{}},{"x":25,"y":16,"type":"spike","extraAttributes":{}},{"x":31,"y":7,"type":"finishFlag","extraAttributes":{}},{"x":16,"y":8,"type":"stomper","extraAttributes":{}},{"x":14,"y":8,"type":"stomper","extraAttributes":{}},{"x":18,"y":11,"type":"rocketLauncher","extraAttributes":{}},{"x":19,"y":11,"type":"rocketLauncher","extraAttributes":{}},{"x":20,"y":11,"type":"rocketLauncher","extraAttributes":{}},{"x":30,"y":1,"type":"spike","extraAttributes":{}},{"x":31,"y":2,"type":"spike","extraAttributes":{}},{"x":31,"y":1,"type":"spike","extraAttributes":{}},{"x":30,"y":2,"type":"spike","extraAttributes":{}},{"x":22,"y":8,"type":"spike","extraAttributes":{}},{"x":23,"y":8,"type":"spike","extraAttributes":{}},{"x":22,"y":9,"type":"spike","extraAttributes":{}},{"x":31,"y":10,"type":"spike","extraAttributes":{}},{"x":5,"y":2,"type":"npc","extraAttributes":{"dialogue":["Oh boy! Spikes and rocket launchers. Better be careful with these things.","They actually do kill you and thus you have to start at the beginning of the level"]}},{"x":9,"y":15,"type":"npc","extraAttributes":{"dialogue":["Thwomps?! Dafuq are they doing here?!","Better watch out for them too."]}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,11,11,11,1],[1,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,1],[1,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,11,11,11,1],[1,6,6,6,6,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,2],[1,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,11,11,11,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,6,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,11,11,11,1],[2,0,0,0,0,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,6,0,0,0,1],[1,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,1],[1,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,11,11,11,1],[1,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":6,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":7,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":8,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":9,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":10,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":11,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":12,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":13,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":14,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":15,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":16,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":17,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":18,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":19,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":20,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":21,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":22,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":23,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":24,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":25,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":26,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":27,"y":11,"type":"disappearingBlock","extraAttributes":{}},{"x":29,"y":7,"type":"disappearingBlock","extraAttributes":{}},{"x":30,"y":7,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":7,"type":"disappearingBlock","extraAttributes":{}},{"x":6,"y":13,"type":"spike","extraAttributes":{}},{"x":7,"y":13,"type":"spike","extraAttributes":{}},{"x":8,"y":13,"type":"spike","extraAttributes":{}},{"x":9,"y":13,"type":"spike","extraAttributes":{}},{"x":10,"y":13,"type":"spike","extraAttributes":{}},{"x":11,"y":13,"type":"spike","extraAttributes":{}},{"x":12,"y":13,"type":"spike","extraAttributes":{}},{"x":13,"y":13,"type":"spike","extraAttributes":{}},{"x":14,"y":13,"type":"spike","extraAttributes":{}},{"x":15,"y":13,"type":"spike","extraAttributes":{}},{"x":16,"y":13,"type":"spike","extraAttributes":{}},{"x":17,"y":13,"type":"spike","extraAttributes":{}},{"x":18,"y":13,"type":"spike","extraAttributes":{}},{"x":19,"y":13,"type":"spike","extraAttributes":{}},{"x":20,"y":13,"type":"spike","extraAttributes":{}},{"x":21,"y":13,"type":"spike","extraAttributes":{}},{"x":22,"y":13,"type":"spike","extraAttributes":{}},{"x":23,"y":13,"type":"spike","extraAttributes":{}},{"x":24,"y":13,"type":"spike","extraAttributes":{}},{"x":25,"y":13,"type":"spike","extraAttributes":{}},{"x":26,"y":13,"type":"spike","extraAttributes":{}},{"x":27,"y":13,"type":"spike","extraAttributes":{}},{"x":29,"y":10,"type":"disappearingBlock","extraAttributes":{}},{"x":30,"y":10,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":10,"type":"disappearingBlock","extraAttributes":{}},{"x":29,"y":13,"type":"disappearingBlock","extraAttributes":{}},{"x":30,"y":13,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":13,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":14,"type":"spike","extraAttributes":{}},{"x":29,"y":11,"type":"spike","extraAttributes":{}},{"x":31,"y":8,"type":"spike","extraAttributes":{}},{"x":29,"y":3,"type":"disappearingBlock","extraAttributes":{}},{"x":30,"y":3,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":3,"type":"disappearingBlock","extraAttributes":{}},{"x":29,"y":5,"type":"disappearingBlock","extraAttributes":{}},{"x":30,"y":5,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":5,"type":"disappearingBlock","extraAttributes":{}},{"x":2,"y":15,"type":"finishFlag","extraAttributes":{}},{"x":1,"y":3,"type":"portal","extraAttributes":{"portalType":"blue"}},{"x":31,"y":1,"type":"portal","extraAttributes":{"portalType":"orange"}},{"x":26,"y":5,"type":"spike","extraAttributes":{}},{"x":27,"y":5,"type":"spike","extraAttributes":{}},{"x":5,"y":6,"type":"canon","extraAttributes":{"currentFacingDirection":"right"}},{"x":2,"y":12,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"7Wb"}},{"x":11,"y":7,"type":"npc","extraAttributes":{"dialogue":["While you're here ducking away from cannon fire, I should note about portals.","See that blue thing? That is a portal.","It's connected to that orange thing over there.","You could in theory go back and forth between them, but I wouldn't recommend it."]}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,6,6,6,6,11,11,11,2],[1,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,6,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[2,6,6,6,6,0,0,0,0,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,6,6,6,6,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":1,"y":10,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"7g6"}},{"x":29,"y":6,"type":"disappearingBlock","extraAttributes":{}},{"x":30,"y":6,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":6,"type":"disappearingBlock","extraAttributes":{}},{"x":17,"y":11,"type":"finishFlag","extraAttributes":{}},{"x":20,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":20,"y":15,"type":"spike","extraAttributes":{}},{"x":21,"y":15,"type":"spike","extraAttributes":{}},{"x":22,"y":15,"type":"spike","extraAttributes":{}},{"x":1,"y":12,"type":"spike","extraAttributes":{}},{"x":2,"y":12,"type":"spike","extraAttributes":{}},{"x":3,"y":12,"type":"spike","extraAttributes":{}},{"x":4,"y":12,"type":"spike","extraAttributes":{}},{"x":5,"y":12,"type":"spike","extraAttributes":{}},{"x":6,"y":12,"type":"spike","extraAttributes":{}},{"x":7,"y":12,"type":"spike","extraAttributes":{}},{"x":8,"y":12,"type":"spike","extraAttributes":{}},{"x":9,"y":12,"type":"spike","extraAttributes":{}},{"x":10,"y":12,"type":"spike","extraAttributes":{}},{"x":11,"y":12,"type":"spike","extraAttributes":{}},{"x":12,"y":12,"type":"spike","extraAttributes":{}},{"x":13,"y":12,"type":"spike","extraAttributes":{}},{"x":14,"y":12,"type":"spike","extraAttributes":{}},{"x":15,"y":12,"type":"spike","extraAttributes":{}},{"x":5,"y":13,"type":"rocketLauncher","extraAttributes":{}},{"x":3,"y":10,"type":"npc","extraAttributes":{"dialogue":["Psst...use dash to get across.","Dashing also helps you get away from the missles."]}},{"x":26,"y":11,"type":"toggleMine","extraAttributes":{}},{"x":25,"y":11,"type":"toggleMine","extraAttributes":{}},{"x":24,"y":11,"type":"toggleMine","extraAttributes":{}},{"x":23,"y":11,"type":"toggleMine","extraAttributes":{}},{"x":27,"y":10,"type":"npc","extraAttributes":{"dialogue":["Watch out, you minesweeper!","Going back and forth between those mines could actually kill you","I think they're pretty rare in this game though, but just in case, be cautious about empty circles."]}}],"deko":[],"paths":[{"speed":3,"stopFrames":10,"pathVariant":"singlePoint","pathPoints":[{"initialX":1,"initialY":16,"alignment":"corner"}]},{"speed":3,"stopFrames":10,"pathVariant":"line","pathPoints":[{"initialX":20,"initialY":16,"alignment":"corner"},{"initialX":21,"initialY":16,"alignment":"horizontal"},{"initialX":22,"initialY":16,"alignment":"corner"}]},{"speed":3,"stopFrames":10,"pathVariant":"line","pathPoints":[{"initialX":5,"initialY":13,"alignment":"corner"},{"initialX":6,"initialY":13,"alignment":"horizontal"},{"initialX":7,"initialY":13,"alignment":"horizontal"},{"initialX":8,"initialY":13,"alignment":"corner"}]}]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,5,5,5,5,6,6,6,0,0,0,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,6,6,6,6,6,6,6,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":17,"y":15,"type":"finishFlag","extraAttributes":{"collectiblesNeeded":true}},{"x":2,"y":15,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"0td"}},{"x":8,"y":15,"type":"collectible","extraAttributes":{"collected":false}},{"x":4,"y":8,"type":"collectible","extraAttributes":{"collected":false}},{"x":1,"y":1,"type":"rocketLauncher","extraAttributes":{}},{"x":18,"y":4,"type":"collectible","extraAttributes":{"collected":false}},{"x":20,"y":16,"type":"spike","extraAttributes":{}},{"x":21,"y":16,"type":"spike","extraAttributes":{}},{"x":23,"y":16,"type":"spike","extraAttributes":{}},{"x":22,"y":16,"type":"spike","extraAttributes":{}},{"x":24,"y":16,"type":"spike","extraAttributes":{}},{"x":27,"y":16,"type":"spike","extraAttributes":{}},{"x":28,"y":16,"type":"spike","extraAttributes":{}},{"x":31,"y":16,"type":"spike","extraAttributes":{}},{"x":30,"y":16,"type":"spike","extraAttributes":{}},{"x":29,"y":16,"type":"spike","extraAttributes":{}},{"x":25,"y":16,"type":"spike","extraAttributes":{}},{"x":26,"y":16,"type":"spike","extraAttributes":{}},{"x":1,"y":8,"type":"trampoline","extraAttributes":{}},{"x":22,"y":13,"type":"collectible","extraAttributes":{"collected":false}},{"x":8,"y":13,"type":"trampoline","extraAttributes":{}},{"x":7,"y":11,"type":"trampoline","extraAttributes":{}},{"x":5,"y":15,"type":"npc","extraAttributes":{"dialogue":["Collectibles are pretty valuable. Good on the ol' deverino for adding a challenge","Just watch out for rockets in this one. Okay?"]}}],"deko":[],"paths":[{"speed":3,"stopFrames":10,"pathVariant":"line","pathPoints":[{"initialX":1,"initialY":1,"alignment":"corner"},{"initialX":2,"initialY":1,"alignment":"horizontal"},{"initialX":3,"initialY":1,"alignment":"horizontal"},{"initialX":4,"initialY":1,"alignment":"horizontal"},{"initialX":5,"initialY":1,"alignment":"horizontal"},{"initialX":6,"initialY":1,"alignment":"horizontal"},{"initialX":7,"initialY":1,"alignment":"horizontal"},{"initialX":8,"initialY":1,"alignment":"horizontal"},{"initialX":9,"initialY":1,"alignment":"horizontal"},{"initialX":10,"initialY":1,"alignment":"horizontal"},{"initialX":11,"initialY":1,"alignment":"horizontal"},{"initialX":12,"initialY":1,"alignment":"horizontal"},{"initialX":13,"initialY":1,"alignment":"horizontal"},{"initialX":14,"initialY":1,"alignment":"horizontal"},{"initialX":15,"initialY":1,"alignment":"horizontal"},{"initialX":16,"initialY":1,"alignment":"horizontal"},{"initialX":17,"initialY":1,"alignment":"horizontal"},{"initialX":18,"initialY":1,"alignment":"horizontal"},{"initialX":19,"initialY":1,"alignment":"horizontal"},{"initialX":20,"initialY":1,"alignment":"horizontal"},{"initialX":21,"initialY":1,"alignment":"horizontal"},{"initialX":22,"initialY":1,"alignment":"horizontal"},{"initialX":23,"initialY":1,"alignment":"horizontal"},{"initialX":24,"initialY":1,"alignment":"horizontal"},{"initialX":25,"initialY":1,"alignment":"horizontal"},{"initialX":26,"initialY":1,"alignment":"horizontal"},{"initialX":27,"initialY":1,"alignment":"horizontal"},{"initialX":28,"initialY":1,"alignment":"horizontal"},{"initialX":29,"initialY":1,"alignment":"horizontal"},{"initialX":30,"initialY":1,"alignment":"horizontal"},{"initialX":31,"initialY":1,"alignment":"corner"}]}]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,14,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,1],[2,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,6,6,6,6,6,6,1],[1,0,0,0,0,6,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,6,0,0,0,0,6,1],[1,0,0,0,6,6,0,0,6,6,0,12,12,12,12,12,6,6,6,6,6,5,5,5,5,0,6,0,0,0,0,6,1],[1,6,6,6,6,6,0,0,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":2,"y":15,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"PUB"}},{"x":11,"y":15,"type":"redBlock","extraAttributes":{}},{"x":12,"y":15,"type":"redBlock","extraAttributes":{}},{"x":13,"y":15,"type":"redBlock","extraAttributes":{}},{"x":14,"y":15,"type":"redBlock","extraAttributes":{}},{"x":15,"y":15,"type":"redBlock","extraAttributes":{}},{"x":12,"y":16,"type":"spike","extraAttributes":{}},{"x":11,"y":16,"type":"spike","extraAttributes":{}},{"x":13,"y":16,"type":"spike","extraAttributes":{}},{"x":14,"y":16,"type":"spike","extraAttributes":{}},{"x":15,"y":16,"type":"spike","extraAttributes":{}},{"x":16,"y":16,"type":"spike","extraAttributes":{}},{"x":21,"y":16,"type":"spike","extraAttributes":{}},{"x":22,"y":16,"type":"spike","extraAttributes":{}},{"x":23,"y":16,"type":"spike","extraAttributes":{}},{"x":24,"y":16,"type":"spike","extraAttributes":{}},{"x":25,"y":16,"type":"spike","extraAttributes":{}},{"x":25,"y":15,"type":"spike","extraAttributes":{}},{"x":25,"y":14,"type":"spike","extraAttributes":{}},{"x":25,"y":13,"type":"spike","extraAttributes":{}},{"x":31,"y":1,"type":"canon","extraAttributes":{}},{"x":27,"y":15,"type":"spike","extraAttributes":{}},{"x":27,"y":14,"type":"spike","extraAttributes":{}},{"x":29,"y":15,"type":"finishFlag","extraAttributes":{}},{"x":30,"y":14,"type":"spike","extraAttributes":{}},{"x":30,"y":15,"type":"spike","extraAttributes":{}},{"x":1,"y":1,"type":"spike","extraAttributes":{}},{"x":1,"y":2,"type":"spike","extraAttributes":{}},{"x":2,"y":1,"type":"portal","extraAttributes":{"portalType":"blue"}},{"x":28,"y":14,"type":"portal","extraAttributes":{"portalType":"orange"}},{"x":25,"y":12,"type":"spike","extraAttributes":{}},{"x":26,"y":12,"type":"spike","extraAttributes":{}},{"x":27,"y":12,"type":"spike","extraAttributes":{}},{"x":28,"y":12,"type":"spike","extraAttributes":{}},{"x":29,"y":12,"type":"spike","extraAttributes":{}},{"x":30,"y":12,"type":"spike","extraAttributes":{}},{"x":31,"y":12,"type":"spike","extraAttributes":{}},{"x":3,"y":2,"type":"blueBlock","extraAttributes":{}},{"x":3,"y":1,"type":"blueBlock","extraAttributes":{}},{"x":27,"y":1,"type":"redblueblockswitch","extraAttributes":{}},{"x":6,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":7,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":17,"y":16,"type":"spike","extraAttributes":{}},{"x":18,"y":16,"type":"spike","extraAttributes":{}},{"x":19,"y":16,"type":"spike","extraAttributes":{}},{"x":20,"y":16,"type":"spike","extraAttributes":{}},{"x":17,"y":14,"type":"npc","extraAttributes":{"dialogue":["You made it so far. This level obviously demonstrates the red and blue blocks.","Though, this one may be difficult to finish tbh."]}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,5,5,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,6,0,0,13,5,5,0,1],[1,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,1],[1,0,0,0,0,5,5,5,5,5,6,6,6,6,6,5,5,5,5,5,6,6,6,6,6,6,0,0,5,5,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,2],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,5,5,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,5,5,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,1],[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":1,"y":3,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"DvK"}},{"x":24,"y":4,"type":"portal","extraAttributes":{"portalType":"blue"}},{"x":22,"y":11,"type":"portal","extraAttributes":{"portalType":"orange"}},{"x":28,"y":11,"type":"blueBlock","extraAttributes":{}},{"x":29,"y":11,"type":"blueBlock","extraAttributes":{}},{"x":30,"y":11,"type":"blueBlock","extraAttributes":{}},{"x":31,"y":11,"type":"blueBlock","extraAttributes":{}},{"x":20,"y":13,"type":"redBlock","extraAttributes":{}},{"x":20,"y":12,"type":"redBlock","extraAttributes":{}},{"x":20,"y":11,"type":"redBlock","extraAttributes":{}},{"x":6,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":7,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":8,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":14,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":15,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":16,"y":16,"type":"rocketLauncher","extraAttributes":{}},{"x":29,"y":1,"type":"finishFlag","extraAttributes":{}},{"x":31,"y":1,"type":"spike","extraAttributes":{}},{"x":31,"y":2,"type":"spike","extraAttributes":{}},{"x":31,"y":3,"type":"spike","extraAttributes":{}},{"x":26,"y":1,"type":"spike","extraAttributes":{}},{"x":26,"y":2,"type":"spike","extraAttributes":{}},{"x":26,"y":3,"type":"spike","extraAttributes":{}},{"x":26,"y":4,"type":"spike","extraAttributes":{}},{"x":26,"y":5,"type":"spike","extraAttributes":{}},{"x":26,"y":6,"type":"spike","extraAttributes":{}},{"x":25,"y":6,"type":"spike","extraAttributes":{}},{"x":24,"y":6,"type":"spike","extraAttributes":{}},{"x":23,"y":6,"type":"spike","extraAttributes":{}},{"x":22,"y":6,"type":"spike","extraAttributes":{}},{"x":21,"y":6,"type":"spike","extraAttributes":{}},{"x":20,"y":10,"type":"redBlock","extraAttributes":{}},{"x":20,"y":9,"type":"redBlock","extraAttributes":{}},{"x":20,"y":8,"type":"redBlock","extraAttributes":{}},{"x":20,"y":7,"type":"redBlock","extraAttributes":{}},{"x":20,"y":6,"type":"redBlock","extraAttributes":{}},{"x":24,"y":3,"type":"spike","extraAttributes":{}},{"x":24,"y":2,"type":"spike","extraAttributes":{}},{"x":24,"y":1,"type":"spike","extraAttributes":{}},{"x":21,"y":13,"type":"spike","extraAttributes":{}},{"x":22,"y":13,"type":"spike","extraAttributes":{}},{"x":27,"y":13,"type":"blueBlock","extraAttributes":{}},{"x":28,"y":13,"type":"blueBlock","extraAttributes":{}},{"x":29,"y":13,"type":"blueBlock","extraAttributes":{}},{"x":30,"y":13,"type":"blueBlock","extraAttributes":{}},{"x":31,"y":13,"type":"blueBlock","extraAttributes":{}},{"x":13,"y":3,"type":"redblueblockswitch","extraAttributes":{}},{"x":28,"y":3,"type":"redblueblockswitch","extraAttributes":{}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,0,14,1],[1,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,11,11,11,11,11,11,11,11,11,11,11,11,11,11,6,6,6,6,6,6,6,6,5,5,0,0,0,0,1],[1,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,6,5,5,0,0,0,0,1],[1,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,6,5,5,0,0,0,0,2],[1,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,6,5,5,0,0,0,0,1],[1,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,6,6,6,6,0,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,1],[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,1],[1,0,0,0,0,0,0,0,0,0,0,12,12,0,0,12,12,0,0,12,12,6,6,6,6,6,6,6,6,6,6,6,1],[1,6,6,6,6,0,0,0,6,6,6,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":5,"y":16,"type":"spike","extraAttributes":{}},{"x":6,"y":16,"type":"spike","extraAttributes":{}},{"x":7,"y":16,"type":"spike","extraAttributes":{}},{"x":11,"y":16,"type":"spike","extraAttributes":{}},{"x":12,"y":16,"type":"spike","extraAttributes":{}},{"x":13,"y":16,"type":"spike","extraAttributes":{}},{"x":15,"y":16,"type":"spike","extraAttributes":{}},{"x":14,"y":16,"type":"spike","extraAttributes":{}},{"x":16,"y":16,"type":"spike","extraAttributes":{}},{"x":19,"y":16,"type":"spike","extraAttributes":{}},{"x":20,"y":16,"type":"spike","extraAttributes":{}},{"x":11,"y":15,"type":"redBlock","extraAttributes":{}},{"x":12,"y":15,"type":"redBlock","extraAttributes":{}},{"x":19,"y":15,"type":"redBlock","extraAttributes":{}},{"x":20,"y":15,"type":"redBlock","extraAttributes":{}},{"x":29,"y":10,"type":"spike","extraAttributes":{}},{"x":31,"y":10,"type":"spike","extraAttributes":{}},{"x":31,"y":1,"type":"canon","extraAttributes":{}},{"x":26,"y":1,"type":"redblueblockswitch","extraAttributes":{}},{"x":4,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":5,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":6,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":7,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":8,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":9,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":10,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":11,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":12,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":13,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":14,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":15,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":16,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":17,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":30,"y":9,"type":"collectible","extraAttributes":{"collected":false}},{"x":30,"y":12,"type":"collectible","extraAttributes":{"collected":false}},{"x":31,"y":12,"type":"spike","extraAttributes":{}},{"x":29,"y":14,"type":"collectible","extraAttributes":{"collected":false}},{"x":29,"y":8,"type":"collectible","extraAttributes":{"collected":false}},{"x":31,"y":14,"type":"spike","extraAttributes":{}},{"x":2,"y":15,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"iG2"}},{"x":17,"y":16,"type":"spike","extraAttributes":{}},{"x":18,"y":16,"type":"spike","extraAttributes":{}},{"x":3,"y":3,"type":"blueBlock","extraAttributes":{}},{"x":3,"y":2,"type":"blueBlock","extraAttributes":{}},{"x":3,"y":1,"type":"blueBlock","extraAttributes":{}},{"x":4,"y":7,"type":"spike","extraAttributes":{}},{"x":5,"y":7,"type":"spike","extraAttributes":{}},{"x":6,"y":7,"type":"spike","extraAttributes":{}},{"x":7,"y":7,"type":"spike","extraAttributes":{}},{"x":8,"y":7,"type":"spike","extraAttributes":{}},{"x":9,"y":7,"type":"spike","extraAttributes":{}},{"x":11,"y":7,"type":"spike","extraAttributes":{}},{"x":12,"y":7,"type":"spike","extraAttributes":{}},{"x":10,"y":7,"type":"spike","extraAttributes":{}},{"x":13,"y":7,"type":"spike","extraAttributes":{}},{"x":14,"y":7,"type":"spike","extraAttributes":{}},{"x":15,"y":7,"type":"spike","extraAttributes":{}},{"x":16,"y":7,"type":"spike","extraAttributes":{}},{"x":17,"y":7,"type":"spike","extraAttributes":{}},{"x":1,"y":1,"type":"finishFlag","extraAttributes":{"collectiblesNeeded":true}},{"x":8,"y":3,"type":"collectible","extraAttributes":{"collected":false}},{"x":7,"y":2,"type":"collectible","extraAttributes":{"collected":false}},{"x":6,"y":3,"type":"collectible","extraAttributes":{"collected":false}},{"x":5,"y":2,"type":"collectible","extraAttributes":{"collected":false}},{"x":4,"y":3,"type":"collectible","extraAttributes":{"collected":false}},{"x":15,"y":15,"type":"redBlock","extraAttributes":{}},{"x":16,"y":15,"type":"redBlock","extraAttributes":{}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,0,14,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,11,11,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,2],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[2,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,0,0,0,0,0,0,0,0,5,5,5,5,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,6,6,6,6,0,0,5,5,0,0,0,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,6,0,0,1],[1,6,6,6,6,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":30,"y":15,"type":"finishFlag","extraAttributes":{}},{"x":30,"y":16,"type":"spike","extraAttributes":{}},{"x":31,"y":16,"type":"spike","extraAttributes":{}},{"x":31,"y":1,"type":"canon","extraAttributes":{}},{"x":13,"y":12,"type":"redBlock","extraAttributes":{}},{"x":13,"y":11,"type":"redBlock","extraAttributes":{}},{"x":13,"y":10,"type":"redBlock","extraAttributes":{}},{"x":13,"y":7,"type":"redBlock","extraAttributes":{}},{"x":13,"y":6,"type":"redBlock","extraAttributes":{}},{"x":13,"y":5,"type":"redBlock","extraAttributes":{}},{"x":13,"y":9,"type":"redBlock","extraAttributes":{}},{"x":13,"y":8,"type":"redBlock","extraAttributes":{}},{"x":13,"y":13,"type":"redBlock","extraAttributes":{}},{"x":27,"y":14,"type":"portal","extraAttributes":{"portalType":"blue"}},{"x":1,"y":2,"type":"portal","extraAttributes":{"portalType":"orange"}},{"x":1,"y":14,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"H3O"}},{"x":9,"y":16,"type":"spike","extraAttributes":{}},{"x":11,"y":15,"type":"spike","extraAttributes":{}},{"x":12,"y":15,"type":"spike","extraAttributes":{}},{"x":12,"y":16,"type":"spike","extraAttributes":{}},{"x":11,"y":16,"type":"spike","extraAttributes":{}},{"x":10,"y":16,"type":"spike","extraAttributes":{}},{"x":26,"y":1,"type":"redblueblockswitch","extraAttributes":{}},{"x":31,"y":15,"type":"spike","extraAttributes":{}},{"x":31,"y":14,"type":"spike","extraAttributes":{}},{"x":31,"y":13,"type":"spike","extraAttributes":{}},{"x":31,"y":12,"type":"spike","extraAttributes":{}},{"x":31,"y":11,"type":"spike","extraAttributes":{}},{"x":31,"y":10,"type":"spike","extraAttributes":{}},{"x":31,"y":9,"type":"spike","extraAttributes":{}},{"x":31,"y":8,"type":"spike","extraAttributes":{}},{"x":31,"y":7,"type":"spike","extraAttributes":{}},{"x":31,"y":6,"type":"spike","extraAttributes":{}},{"x":31,"y":5,"type":"spike","extraAttributes":{}},{"x":8,"y":16,"type":"spike","extraAttributes":{}},{"x":7,"y":16,"type":"spike","extraAttributes":{}},{"x":9,"y":15,"type":"spike","extraAttributes":{}},{"x":10,"y":15,"type":"spike","extraAttributes":{}},{"x":5,"y":16,"type":"spike","extraAttributes":{}},{"x":6,"y":16,"type":"spike","extraAttributes":{}},{"x":5,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":6,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":7,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":8,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":9,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":10,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":11,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":12,"y":4,"type":"blueBlock","extraAttributes":{}},{"x":30,"y":4,"type":"disappearingBlock","extraAttributes":{}},{"x":31,"y":4,"type":"disappearingBlock","extraAttributes":{}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,14,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,12,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,6,12,12,12,12,12,12,12,12,12,12,12,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,2],[1,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,14,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,14,6,0,0,0,0,0,0,0,0,0,0,0,1],[2,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,14,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,14,14,0,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1],[1,13,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,6,2,2,2,2,2,2,2,2,2,2,2,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[{"x":6,"y":12,"type":"collectible","extraAttributes":{"collected":false}},{"x":8,"y":10,"type":"collectible","extraAttributes":{"collected":false}},{"x":10,"y":8,"type":"collectible","extraAttributes":{"collected":false}},{"x":12,"y":6,"type":"collectible","extraAttributes":{"collected":false}},{"x":14,"y":4,"type":"collectible","extraAttributes":{"collected":false}},{"x":16,"y":2,"type":"collectible","extraAttributes":{"collected":false}},{"x":1,"y":16,"type":"redblueblockswitch","extraAttributes":{}},{"x":6,"y":16,"type":"canon","extraAttributes":{}},{"x":3,"y":12,"type":"startFlag","extraAttributes":{"levelStartFlag":true,"flagIndex":"ln3"}},{"x":28,"y":9,"type":"stomper","extraAttributes":{}},{"x":21,"y":8,"type":"spike","extraAttributes":{}},{"x":22,"y":8,"type":"spike","extraAttributes":{}},{"x":23,"y":8,"type":"spike","extraAttributes":{}},{"x":24,"y":8,"type":"spike","extraAttributes":{}},{"x":25,"y":8,"type":"spike","extraAttributes":{}},{"x":26,"y":8,"type":"spike","extraAttributes":{}},{"x":27,"y":8,"type":"spike","extraAttributes":{}},{"x":28,"y":8,"type":"spike","extraAttributes":{}},{"x":29,"y":8,"type":"spike","extraAttributes":{}},{"x":30,"y":8,"type":"spike","extraAttributes":{}},{"x":31,"y":8,"type":"spike","extraAttributes":{}},{"x":25,"y":15,"type":"npc","extraAttributes":{"dialogue":["Wew gal, you made it. I wasn't sure how you're going to.","Well, I guess this is final level, considering the grass that is here.","You also got some coins. Well done, considerng the little choice you have but to.","Anyway, go ahead, get out, and touch some grass. You've earned it. Just watch out for that thwomp though"]}},{"x":30,"y":15,"type":"blueBlock","extraAttributes":{}},{"x":30,"y":14,"type":"blueBlock","extraAttributes":{}},{"x":31,"y":14,"type":"blueBlock","extraAttributes":{}},{"x":21,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":22,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":23,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":24,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":25,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":26,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":27,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":29,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":30,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":28,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":31,"y":7,"type":"blueBlock","extraAttributes":{}},{"x":21,"y":4,"type":"redBlock","extraAttributes":{}},{"x":22,"y":4,"type":"redBlock","extraAttributes":{}},{"x":23,"y":4,"type":"redBlock","extraAttributes":{}},{"x":24,"y":4,"type":"redBlock","extraAttributes":{}},{"x":25,"y":4,"type":"redBlock","extraAttributes":{}},{"x":27,"y":4,"type":"redBlock","extraAttributes":{}},{"x":28,"y":4,"type":"redBlock","extraAttributes":{}},{"x":29,"y":4,"type":"redBlock","extraAttributes":{}},{"x":30,"y":4,"type":"redBlock","extraAttributes":{}},{"x":31,"y":4,"type":"redBlock","extraAttributes":{}},{"x":26,"y":4,"type":"redBlock","extraAttributes":{}},{"x":20,"y":3,"type":"redBlock","extraAttributes":{}},{"x":20,"y":2,"type":"redBlock","extraAttributes":{}},{"x":20,"y":1,"type":"redBlock","extraAttributes":{}},{"x":31,"y":15,"type":"finishFlag","extraAttributes":{"collectiblesNeeded":true}},{"x":18,"y":12,"type":"canon","extraAttributes":{"currentFacingDirection":"top"}},{"x":17,"y":12,"type":"canon","extraAttributes":{"currentFacingDirection":"top"}},{"x":19,"y":9,"type":"canon","extraAttributes":{}},{"x":19,"y":10,"type":"canon","extraAttributes":{}},{"x":19,"y":11,"type":"canon","extraAttributes":{}},{"x":31,"y":1,"type":"canon","extraAttributes":{}},{"x":31,"y":6,"type":"portal","extraAttributes":{"portalType":"blue"}},{"x":21,"y":9,"type":"portal","extraAttributes":{"portalType":"orange"}}],"deko":[],"paths":[]},{"tileData":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"levelObjects":[],"deko":[],"paths":[]}]
  WorldDataHandler.gamesName = unescape("Protonami");
  WorldDataHandler.endingMessage = unescape("Thanks%20for%20playing.");
  WorldDataHandler.backgroundColor = "555555";
  WorldDataHandler.textColor = "FFFFFF";
  //initialLevelDataEnd
        //changedSpritesStart
  SpritePixelArrays["pathMovementMapper"] = {"1":1,"2":2,"3":3,"4":4,"5":6,"6":8,"7":12};SpritePixelArrays["changeableAttributeFormElements"] = {"toggle":"toggle"};SpritePixelArrays["changeableAttributeTypes"] = {"frequency":"frequency","speed":"speed","dialogue":"dialogue","stopFrames":"stopFrames","movementDirection":"movementDirection","rotationSpeed":"rotationSpeed","collectiblesNeeded":"collectiblesNeeded"};SpritePixelArrays["TILE_1"] = {"name":1,"descriptiveName":"Left top","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00"],["00AA00","005500","005500","005500","005500","005500","005500","005500"],["AAFF55","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["00AA00","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["00AA00","005500","c26241","c26241","e1a45b","e1a45b","e1a45b","e1a45b"]]}]};SpritePixelArrays["TILE_2"] = {"name":2,"descriptiveName":"Middle top","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00"],["005500","005500","005500","005500","005500","005500","005500","005500"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["c26241","c26241","c26241","c26241","e1a45b","e1a45b","e1a45b","e1a45b"]]}]};SpritePixelArrays["TILE_3"] = {"name":3,"descriptiveName":"Right top","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00"],["005500","005500","005500","005500","005500","005500","005500","AAFF55"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","00AA00"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","AAFF55"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","00AA00"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","AAFF55"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","00AA00"],["c26241","c26241","c26241","c26241","e1a45b","e1a45b","005500","AAFF55"]]}]};SpritePixelArrays["TILE_4"] = {"name":4,"descriptiveName":"Left","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","005500","fbe7cf","fbe7cf","eeb39e","eeb39e","eeb39e","eeb39e"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["AAFF55","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["00AA00","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["00AA00","005500","c26241","c26241","e1a45b","e1a45b","e1a45b","e1a45b"]]}]};SpritePixelArrays["TILE_6"] = {"name":6,"descriptiveName":"Middle","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955"],["1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955"],["1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955"],["1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955","1C3955"],["0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B"],["0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B"],["0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B"],["0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B","0E1C2B"]]}]};SpritePixelArrays["TILE_7"] = {"name":7,"descriptiveName":"Right","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["fbe7cf","fbe7cf","fbe7cf","fbe7cf","eeb39e","eeb39e","005500","00AA00"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","AAFF55"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","00AA00"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","AAFF55"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","00AA00"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","AAFF55"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","00AA00"],["c26241","c26241","c26241","c26241","e1a45b","e1a45b","005500","AAFF55"]]}]};SpritePixelArrays["TILE_8"] = {"name":8,"descriptiveName":"Left bottom","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","005500","fbe7cf","fbe7cf","eeb39e","eeb39e","eeb39e","eeb39e"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["AAFF55","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["00AA00","005500","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["AAFF55","005500","005500","005500","005500","005500","005500","005500"],["00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55"]]}]};SpritePixelArrays["TILE_9"] = {"name":9,"descriptiveName":"Middle bottom","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["fbe7cf","fbe7cf","fbe7cf","fbe7cf","eeb39e","eeb39e","eeb39e","eeb39e"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["005500","005500","005500","005500","005500","005500","005500","005500"],["00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55"]]}]};SpritePixelArrays["TILE_10"] = {"name":10,"descriptiveName":"Right bottom","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["fbe7cf","fbe7cf","fbe7cf","fbe7cf","eeb39e","eeb39e","005500","00AA00"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","AAFF55"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","00AA00"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","005500","AAFF55"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","00AA00"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","005500","AAFF55"],["005500","005500","005500","005500","005500","005500","005500","00AA00"],["00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55"]]}]};SpritePixelArrays["TILE_11"] = {"name":15,"descriptiveName":"Top and bottom","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00"],["005500","005500","005500","005500","005500","005500","005500","005500"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["fbe7cf","f6c992","f6c992","f6c992","ee8764","ee8764","ee8764","c26241"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["eeb39e","ee8764","ee8764","ee8764","f6c992","f6c992","f6c992","e1a45b"],["005500","005500","005500","005500","005500","005500","005500","005500"],["AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00"]]}]};SpritePixelArrays["TILE_12"] = {"name":16,"descriptiveName":"Left and right","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","005500","fbe7cf","fbe7cf","eeb39e","eeb39e","005500","AAFF55"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","005500","00AA00"],["AAFF55","005500","f6c992","f6c992","ee8764","ee8764","005500","AAFF55"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","005500","00AA00"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","005500","AAFF55"],["00AA00","005500","ee8764","ee8764","f6c992","f6c992","005500","00AA00"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","005500","AAFF55"],["00AA00","005500","c26241","c26241","e1a45b","e1a45b","005500","00AA00"]]}]};SpritePixelArrays["TILE_13"] = {"name":17,"descriptiveName":"All sides","description":"Just a solid block","type":"tiles","animation":[{"sprite":[["AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00"],["00AA00","005500","005500","005500","005500","005500","005500","AAFF55"],["AAFF55","005500","f6c992","f6c992","ee8764","ee8764","005500","00AA00"],["00AA00","005500","f6c992","f6c992","ee8764","ee8764","005500","AAFF55"],["AAFF55","005500","ee8764","ee8764","f6c992","f6c992","005500","00AA00"],["00AA00","005500","ee8764","ee8764","f6c992","f6c992","005500","AAFF55"],["AAFF55","005500","005500","005500","005500","005500","005500","00AA00"],["00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55","00AA00","AAFF55"]]}]};SpritePixelArrays["TILE_5"] = {"name":5,"descriptiveName":"One way block","description":"The player can jump through it, but will land on it when he falls","type":"tiles","animation":[{"sprite":[["transp","0071E3","0071E3","0071E3","0071E3","0071E3","0071E3","transp"],["003971","003971","003971","003971","003971","003971","003971","003971"],["transp","003971","transp","transp","transp","transp","003971","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["TILE_edge"] = {"name":"edge","descriptiveName":"Edge block","description":"Will display on the edge of the game screen","animation":[{"sprite":[["b3a1b4","b3a1b4","b3a1b4","b3a1b4","b3a1b4","b3a1b4","b3a1b4","b3a1b4"],["6c686c","b3a1b4","b3a1b4","b3a1b4","b3a1b4","b3a1b4","b3a1b4","6c686c"],["6c686c","6c686c","b3a1b4","b3a1b4","b3a1b4","b3a1b4","6c686c","6c686c"],["6c686c","6c686c","6c686c","b3a1b4","b3a1b4","6c686c","6c686c","6c686c"],["6c686c","6c686c","6c686c","524f52","524f52","6c686c","6c686c","6c686c"],["6c686c","6c686c","524f52","524f52","524f52","524f52","6c686c","6c686c"],["6c686c","524f52","524f52","524f52","524f52","524f52","524f52","6c686c"],["524f52","524f52","524f52","524f52","524f52","524f52","524f52","524f52"]]}]};SpritePixelArrays["SPIKE_SPRITE"] = {"name":"spike","descriptiveName":"Spike","directions":["bottom","left","top","right"],"description":"A spike. If you touch it, you die","type":"objects","animation":[{"sprite":[["transp","transp","transp","transp","b3a1b4","transp","transp","transp"],["transp","transp","transp","b3a1b4","b3a1b4","transp","transp","transp"],["transp","transp","b3a1b4","6c686c","6c686c","b3a1b4","transp","transp"],["b3a1b4","b3a1b4","6c686c","524f52","FFFFFF","6c686c","b3a1b4","transp"],["transp","b3a1b4","6c686c","524f52","524f52","6c686c","b3a1b4","b3a1b4"],["transp","transp","b3a1b4","6c686c","6c686c","b3a1b4","transp","transp"],["transp","transp","transp","b3a1b4","b3a1b4","transp","transp","transp"],["transp","transp","transp","b3a1b4","transp","transp","transp","transp"]]}]};SpritePixelArrays["CANON_SPRITE"] = {"name":"canon","changeableAttributes":[{"name":"speed","defaultValue":3,"minValue":1,"maxValue":10},{"name":"frequency","defaultValue":3,"minValue":1,"maxValue":8}],"descriptiveName":"Cannon","description":"A cannon. It shoots <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Cannon ball'} }, true)\">cannonballs</span> at certain time intervals. Click on it after placing it again, to change the attributes of the individual cannon.","type":"objects","squishAble":false,"directions":["left","top","right","bottom"],"animation":[{"sprite":[["FFFFFF","transp","transp","transp","FFFFFF","FFFFFF","FFFFFF","transp"],["FFFFFF","FFFFFF","transp","FFFFFF","000000","000000","000000","FFFFFF"],["FFFFFF","000000","FFFFFF","000000","000000","000000","000000","FFFFFF"],["FFFFFF","000000","000000","000000","000000","000000","000000","FFFFFF"],["FFFFFF","000000","000000","000000","000000","000000","000000","FFFFFF"],["FFFFFF","000000","FFFFFF","000000","000000","000000","000000","FFFFFF"],["FFFFFF","FFFFFF","transp","FFFFFF","000000","000000","000000","FFFFFF"],["FFFFFF","transp","transp","transp","FFFFFF","FFFFFF","FFFFFF","transp"]]}]};SpritePixelArrays["FINISH_FLAG_SPRITE"] = {"name":"finishFlag","descriptiveName":"Finish flag","changeableAttributes":[{"name":"collectiblesNeeded","defaultValue":false}],"description":"The goal of a level. If you touch it, by default you continue to the next level. If you want to specify a custom exit to a different level, click on a set finish flag again. <br/><span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Finish flag closed'} }, true)\">Closed finish flag sprite</span>","type":"objects","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["FINISH_FLAG_CLOSED_SPRITE"] = {"name":"finishFlagClosed","descriptiveName":"Finish flag closed","description":"This sprite will be displayed if the player needs to collect collectibles to access the <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Finish flag'} }, true)\">Finish flag</span> (Can be configured by clicking on a set finish flag in the game screen).","hiddenSprite":true,"type":"objects","animation":[{"sprite":[["transp","transp","F1D4F1","F1D4F1","F1D4F1","F1D4F1","transp","transp"],["transp","transp","F1D4F1","transp","transp","F1D4F1","transp","transp"],["transp","transp","F1D4F1","transp","transp","F1D4F1","transp","transp"],["transp","D4E3F1","D4E3F1","D4E3F1","D4E3F1","D4E3F1","D4E3F1","transp"],["transp","D4E3F1","D4E3F1","0E1C2B","0E1C2B","D4E3F1","D4E3F1","transp"],["transp","D4E3F1","D4E3F1","0E1C2B","0E1C2B","D4E3F1","D4E3F1","transp"],["transp","D4E3F1","D4E3F1","0E1C2B","0E1C2B","D4E3F1","D4E3F1","transp"],["transp","D4E3F1","D4E3F1","D4E3F1","D4E3F1","D4E3F1","D4E3F1","transp"]]}]};SpritePixelArrays["CHECKPOINT_FLAG"] = {"name":"checkpoint","descriptiveName":"Checkpoint","description":"If the player touches the checkpoint, he will respawn here after a death. If there are multiple checkpoints, the latest one the player touched will become the respawn point.","type":"objects","animation":[{"sprite":[["fdfdfd","E3E300","E3E300","transp","transp","transp","transp","transp"],["fdfdfd","E3E300","E3E300","E3E300","transp","transp","transp","transp"],["fdfdfd","E3E300","E3E300","E3E300","E3E300","transp","transp","transp"],["fdfdfd","E3E300","E3E300","E3E300","E3E300","E3E300","transp","transp"],["fdfdfd","E3E300","E3E300","E3E300","E3E300","E3E300","E3E300","transp"],["fdfdfd","transp","transp","transp","transp","transp","transp","transp"],["fdfdfd","transp","transp","transp","transp","transp","transp","transp"],["fdfdfd","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["fdfdfd","E3E300","E3E300","transp","transp","transp","transp","transp"],["fdfdfd","E3E300","E3E300","E3E300","E3E300","transp","transp","transp"],["fdfdfd","E3E300","E3E300","E3E300","E3E300","E3E300","E3E300","transp"],["fdfdfd","E3E300","E3E300","E3E300","E3E300","transp","transp","transp"],["fdfdfd","E3E300","E3E300","transp","transp","transp","transp","transp"],["fdfdfd","transp","transp","transp","transp","transp","transp","transp"],["fdfdfd","transp","transp","transp","transp","transp","transp","transp"],["fdfdfd","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["START_FLAG_SPRITE"] = {"name":"startFlag","descriptiveName":"Start flag","description":"The starting point of a level. You also respawn here, if you die. <br/> If you create multiple start-flags, for non-linear games, you can click on a set start flag again, to declare it as the default start of a level.","type":"objects","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","transp","transp","transp","FFFFC6","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","FFFFC6","transp","transp","transp","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","transp","transp","transp","FFFFC6","transp","transp"],["transp","transp","FFFFC6","FFFFC6","FFFFC6","FFFFC6","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["RED_BLUE_BLOCK_SWITCH"] = {"name":"redblueblockswitch","descriptiveName":"Red/blue switch","description":"A switch for red/blue tiles. Can be activated by hitting it with your head, or if a stomper/cannon-ball/rocket hits it.","type":"objects","squishAble":false,"animNotEditale":true,"animation":[{"sprite":[["FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FFFFFF","FFFFFF","FFFFFF","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FFFFFF","FF1C1C","FF1C1C","FFFFFF","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FFFFFF","FFFFFF","FFFFFF","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FFFFFF","FF1C1C","FF1C1C","FFFFFF","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","AA0000","AA0000","AA0000","AA0000","AA0000","AA0000","AA0000"]]},{"sprite":[["8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","FFFFFF","FFFFFF","FFFFFF","FFFFFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","FFFFFF","FFFFFF","FFFFFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","FFFFFF","1C1CFF","1C1CFF","FFFFFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","FFFFFF","FFFFFF","FFFFFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","0000AA","0000AA","0000AA","0000AA","0000AA","0000AA","0000AA"]]}]};SpritePixelArrays["DISAPPEARING_BLOCK_SPRITE"] = {"name":"disappearingBlock","descriptiveName":"Disappearing block","description":"A block that will disappear upon touching it. It will reappear after a certain time.","type":"tiles","animation":[{"sprite":[["003971","003971","003971","003971","003971","003971","003971","003971"],["003971","transp","transp","transp","transp","transp","transp","003971"],["003971","001C39","001C39","001C39","001C39","001C39","001C39","003971"],["003971","transp","transp","transp","transp","transp","transp","003971"],["003971","transp","transp","transp","transp","transp","transp","003971"],["003971","001C39","001C39","001C39","001C39","001C39","001C39","003971"],["003971","transp","transp","transp","transp","transp","transp","003971"],["003971","003971","003971","003971","003971","003971","003971","003971"]]}]};SpritePixelArrays["RED_BLOCK"] = {"name":"redBlock","descriptiveName":"Red block","description":"There are red blocks and blue blocks. Only one them can be active at a time. By touching the switch (in the objects tab), the active tiles can be switched.","type":"tiles","animation":[{"sprite":[["FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E","FF8E8E"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","FF1C1C","AA0000"],["FF8E8E","AA0000","AA0000","AA0000","AA0000","AA0000","AA0000","AA0000"]]},{"sprite":[["FF1C1C","FF1C1C","transp","FF1C1C","FF1C1C","transp","FF1C1C","FF1C1C"],["FF1C1C","transp","transp","transp","transp","transp","transp","FF1C1C"],["transp","transp","transp","transp","transp","transp","transp","transp"],["FF1C1C","transp","transp","transp","transp","transp","transp","FF1C1C"],["FF1C1C","transp","transp","transp","transp","transp","transp","FF1C1C"],["transp","transp","transp","transp","transp","transp","transp","transp"],["FF1C1C","transp","transp","transp","transp","transp","transp","FF1C1C"],["FF1C1C","FF1C1C","transp","FF1C1C","FF1C1C","transp","FF1C1C","FF1C1C"]]}]};SpritePixelArrays["BLUE_BLOCK"] = {"name":"blueBlock","descriptiveName":"Blue block","description":"There are red blocks and blue blocks. Only one them can be active at a time. By touching the switch (in the objects tab), the active tiles can be switched.","type":"tiles","animation":[{"sprite":[["8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF","8E8EFF"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","1C1CFF","0000AA"],["8E8EFF","0000AA","0000AA","0000AA","0000AA","0000AA","0000AA","0000AA"]]},{"sprite":[["1C1CFF","1C1CFF","transp","1C1CFF","1C1CFF","transp","1C1CFF","1C1CFF"],["1C1CFF","transp","transp","transp","transp","transp","transp","1C1CFF"],["transp","transp","transp","transp","transp","transp","transp","transp"],["1C1CFF","transp","transp","transp","transp","transp","transp","1C1CFF"],["1C1CFF","transp","transp","transp","transp","transp","transp","1C1CFF"],["transp","transp","transp","transp","transp","transp","transp","transp"],["1C1CFF","transp","transp","transp","transp","transp","transp","1C1CFF"],["1C1CFF","1C1CFF","transp","1C1CFF","1C1CFF","transp","1C1CFF","1C1CFF"]]}]};SpritePixelArrays["DEKO_SPRITE"] = {"name":"deco","type":"deco","descriptiveName":"Deco 1","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","40BF40","transp","transp","transp","40BF40"],["transp","40BF40","transp","40BF40","transp","40BF40","transp","40BF40"],["transp","40BF40","40BF40","40BF40","40BF40","40BF40","transp","40BF40"],["40BF40","40BF40","40BF40","40BF40","40BF40","40BF40","transp","40BF40"]]}]};SpritePixelArrays["DEKO_SPRITE2"] = {"name":"deco","descriptiveName":"Deco 2","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","FF55FF","FF55FF","transp"],["transp","FF5555","FF5555","transp","FF00FF","transp","transp","FF00FF"],["FF5555","transp","transp","FF5555","transp","FF00FF","FF00FF","transp"],["transp","FF5555","FF5555","transp","transp","2B802B","2B802B","transp"]]}]};SpritePixelArrays["DEKO_SPRITE3"] = {"name":"deco","descriptiveName":"Deco 3","type":"deco","animation":[{"sprite":[["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["FFFFFF","FFFFFF","transp","FFFFFF","FFFFFF","transp","FFFFFF","FFFFFF"],["FFFFFF","FFFFFF","FFFFFF","0000FF","0000FF","FFFFFF","FFFFFF","FFFFFF"],["transp","transp","transp","0000FF","0000FF","transp","transp","transp"],["FFFFFF","FFFFFF","55AAFF","transp","transp","55AAFF","FFFFFF","FFFFFF"],["FFFFFF","FFFFFF","FFFFFF","55AAFF","55AAFF","FFFFFF","FFFFFF","FFFFFF"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE4"] = {"name":"deco","descriptiveName":"Deco 4","type":"deco","animation":[{"sprite":[["transp","2B8055","transp","15402A","15402A","transp","2B8055","transp"],["transp","2B8055","2B8055","15402A","15402A","2B8055","2B8055","transp"],["transp","transp","2B8055","15402A","15402A","2B8055","transp","transp"],["transp","transp","transp","15402A","15402A","transp","transp","transp"],["transp","2B8055","transp","15402A","15402A","transp","2B8055","transp"],["transp","2B8055","2B8055","15402A","15402A","2B8055","2B8055","transp"],["transp","transp","2B8055","15402A","15402A","2B8055","transp","transp"],["transp","transp","transp","15402A","15402A","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE5"] = {"name":"deco","descriptiveName":"Deco 5","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["713900","transp","transp","transp","transp","transp","transp","AA5500"],["713900","E37100","E37100","E37100","E37100","E37100","E37100","AA5500"],["713900","transp","transp","transp","transp","transp","transp","AA5500"],["713900","E37100","E37100","E37100","E37100","E37100","E37100","AA5500"],["713900","transp","transp","transp","transp","transp","transp","AA5500"],["713900","E37100","E37100","E37100","E37100","E37100","E37100","AA5500"]]}]};SpritePixelArrays["DEKO_SPRITE6"] = {"name":"deco","descriptiveName":"Deco 6","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","55AAFF","55AAFF","55AAFF","55AAFF","transp","transp","transp"],["transp","55AAFF","55AAFF","transp","55AAFF","transp","transp","transp"],["FFFF8E","FFFF8E","55AAFF","55AAFF","55AAFF","transp","transp","transp"],["transp","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF"],["transp","transp","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF","transp"],["transp","transp","transp","FFFF8E","FFFF8E","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","55AAFF","55AAFF","55AAFF","55AAFF","transp","transp","transp"],["FFFF8E","55AAFF","55AAFF","transp","55AAFF","transp","transp","transp"],["transp","FFFF8E","55AAFF","55AAFF","55AAFF","transp","transp","transp"],["FFFF8E","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF"],["transp","transp","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF","transp"],["transp","transp","transp","transp","FFFF8E","transp","transp","transp"],["transp","transp","transp","FFFF8E","FFFF8E","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE7"] = {"name":"deco","descriptiveName":"Deco 7","type":"deco","animation":[{"sprite":[["2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A"],["transp","2A2A2A","transp","transp","2A2A2A","transp","2A2A2A","transp"],["transp","2A2A2A","transp","2A2A2A","transp","transp","2A2A2A","transp"],["transp","2A2A2A","transp","2A2A2A","2A2A2A","transp","2A2A2A","transp"],["transp","2A2A2A","transp","transp","2A2A2A","transp","2A2A2A","transp"],["transp","2A2A2A","transp","2A2A2A","transp","transp","2A2A2A","transp"],["transp","2A2A2A","transp","2A2A2A","2A2A2A","transp","2A2A2A","transp"],["2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A"]]}]};SpritePixelArrays["DEKO_SPRITE8"] = {"name":"deco","descriptiveName":"Deco 8","type":"deco","animation":[{"sprite":[["2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","transp","2A2A2A","2A2A2A"],["2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","transp","2A2A2A","2A2A2A"],["transp","transp","transp","transp","transp","transp","transp","transp"],["2A2A2A","2A2A2A","transp","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A"],["2A2A2A","2A2A2A","transp","2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A"],["transp","transp","transp","transp","transp","transp","transp","transp"],["2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","transp","2A2A2A","2A2A2A"],["2A2A2A","2A2A2A","2A2A2A","2A2A2A","2A2A2A","transp","2A2A2A","2A2A2A"]]}]};SpritePixelArrays["DEKO_SPRITE9"] = {"name":"deco","descriptiveName":"Deco 9","type":"deco","animation":[{"sprite":[["transp","transp","transp","FF8E1C","transp","transp","transp","transp"],["transp","transp","FF8E1C","FFC68E","FF8E1C","transp","transp","transp"],["transp","FF8E1C","FFC68E","FFFFC6","FFC68E","FF8E1C","transp","transp"],["transp","FF8E1C","FFC68E","FFFFC6","FFC68E","FF8E1C","transp","transp"],["transp","8E8E8E","AAAAAA","AAAAAA","AAAAAA","8E8E8E","transp","transp"],["transp","transp","8E8E8E","AAAAAA","8E8E8E","transp","transp","transp"],["transp","transp","transp","8E8E8E","transp","transp","transp","transp"],["transp","transp","transp","8E8E8E","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","AA5500","transp","transp","transp","transp"],["transp","transp","AA5500","FF8E1C","AA5500","transp","transp","transp"],["transp","AA5500","FF8E1C","FFFF8E","FF8E1C","AA5500","transp","transp"],["transp","AA5500","FF8E1C","FFFF8E","FF8E1C","AA5500","transp","transp"],["transp","8E8E8E","AAAAAA","AAAAAA","AAAAAA","8E8E8E","transp","transp"],["transp","transp","8E8E8E","AAAAAA","8E8E8E","transp","transp","transp"],["transp","transp","transp","8E8E8E","transp","transp","transp","transp"],["transp","transp","transp","8E8E8E","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE10"] = {"name":"deco","descriptiveName":"Deco 10","type":"deco","animation":[{"sprite":[["transp","transp","8EC6FF","8EC6FF","8EC6FF","8EC6FF","transp","transp"],["transp","8EC6FF","FFFFFF","8EC6FF","8EC6FF","8EC6FF","8EC6FF","transp"],["8EC6FF","FFFFFF","8EC6FF","FFFFFF","8EC6FF","8EC6FF","8EC6FF","8EC6FF"],["8EC6FF","8EC6FF","FFFFFF","8EC6FF","8EC6FF","8EC6FF","8EC6FF","8EC6FF"],["8EC6FF","8EC6FF","8EC6FF","8EC6FF","8EC6FF","8EC6FF","FFFFFF","8EC6FF"],["8EC6FF","8EC6FF","8EC6FF","8EC6FF","8EC6FF","FFFFFF","8EC6FF","8EC6FF"],["transp","8EC6FF","8EC6FF","8EC6FF","8EC6FF","8EC6FF","8EC6FF","transp"],["transp","transp","8EC6FF","8EC6FF","8EC6FF","8EC6FF","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE11"] = {"name":"deco","descriptiveName":"Deco 11","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","FFC6FF","transp","transp","transp","transp","transp"],["transp","FFC6FF","FFFFFF","FFC6FF","transp","transp","transp","transp"],["transp","transp","FFC6FF","transp","transp","FFC6FF","transp","transp"],["transp","transp","transp","transp","FFC6FF","FFFFFF","FFC6FF","transp"],["transp","transp","FFC6FF","transp","transp","FFC6FF","transp","transp"],["transp","FFC6FF","FFFFFF","FFC6FF","transp","transp","transp","transp"],["transp","transp","FFC6FF","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","393939","transp","transp","transp","transp","transp"],["transp","393939","FFC6FF","393939","transp","transp","transp","transp"],["transp","transp","393939","transp","transp","393939","transp","transp"],["transp","transp","transp","transp","393939","FFC6FF","393939","transp"],["transp","transp","393939","transp","transp","393939","transp","transp"],["transp","393939","FFC6FF","393939","transp","transp","transp","transp"],["transp","transp","393939","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE12"] = {"name":"deco","descriptiveName":"Deco 12","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","0055AA","transp","transp","transp","transp"],["transp","transp","transp","8EC6FF","transp","transp","transp","transp"],["transp","transp","8EC6FF","C6E3FF","8EC6FF","transp","transp","transp"],["0055AA","8EC6FF","C6E3FF","C6E3FF","C6E3FF","8EC6FF","0055AA","transp"],["transp","transp","8EC6FF","C6E3FF","8EC6FF","transp","transp","transp"],["transp","transp","transp","8EC6FF","transp","transp","transp","transp"],["transp","transp","transp","0055AA","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","003971","transp","transp","transp","transp"],["transp","transp","transp","0055AA","transp","transp","transp","transp"],["transp","transp","0055AA","C6E3FF","0055AA","transp","transp","transp"],["003971","0055AA","C6E3FF","C6E3FF","C6E3FF","0055AA","003971","transp"],["transp","transp","0055AA","C6E3FF","0055AA","transp","transp","transp"],["transp","transp","transp","0055AA","transp","transp","transp","transp"],["transp","transp","transp","003971","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE13"] = {"name":"deco","descriptiveName":"Deco 13","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE14"] = {"name":"deco","descriptiveName":"Deco 14","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE15"] = {"name":"deco","descriptiveName":"Deco 15","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE16"] = {"name":"deco","descriptiveName":"Deco 16","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE17"] = {"name":"deco","descriptiveName":"Deco 17","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["DEKO_SPRITE18"] = {"name":"deco","descriptiveName":"Deco 18","type":"deco","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["TRAMPOLINE_SRPITE"] = {"name":"trampoline","descriptiveName":"Trampoline","description":"A trampoline. You will jump approximately twice as high when you land on it.","animNotEditale":true,"squishAble":false,"type":"objects","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["e97977","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","e97977"],["e97977","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","e97977"],["transp","transp","6c686c","6c686c","b3a1b4","fdfdfd","transp","transp"],["transp","transp","524f52","524f52","524f52","524f52","transp","transp"],["transp","transp","6c686c","6c686c","b3a1b4","fdfdfd","transp","transp"],["transp","transp","524f52","524f52","524f52","524f52","transp","transp"]]},{"sprite":[["e97977","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","e97977"],["e97977","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","d55c5a","e97977"],["transp","transp","6c686c","6c686c","b3a1b4","fdfdfd","transp","transp"],["transp","transp","524f52","524f52","524f52","524f52","transp","transp"],["transp","transp","6c686c","6c686c","b3a1b4","fdfdfd","transp","transp"],["transp","transp","524f52","524f52","524f52","524f52","transp","transp"],["transp","transp","6c686c","6c686c","b3a1b4","fdfdfd","transp","transp"],["transp","transp","524f52","524f52","524f52","524f52","transp","transp"]]}]};SpritePixelArrays["NPC_SPRITE"] = {"name":"npc","changeableAttributes":[{"name":"dialogue","defaultValue":[""]}],"descriptiveName":"Npc","description":"An object that can display a dialogue. Click on it again after placing it, to display the dialogue window.","type":"objects","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","F1F1D4","transp","transp","transp","transp","F1F1D4","transp"],["transp","transp","F1F1D4","transp","transp","F1F1D4","transp","transp"],["transp","transp","transp","F1F1D4","F1F1D4","transp","transp","transp"],["710000","710000","710000","710000","710000","710000","710000","710000"],["710000","D4E3F1","D4E3F1","710000","710000","D4E3F1","D4E3F1","710000"],["710000","D4E3F1","D4E3F1","003939","003939","D4E3F1","D4E3F1","710000"],["710000","710000","710000","710000","710000","710000","710000","710000"]]}]};SpritePixelArrays["PATH_SPRITE"] = {"name":"pathPoint","changeableAttributes":[{"name":"speed","defaultValue":3,"minValue":1,"maxValue":7,"mapper":{"1":1,"2":2,"3":3,"4":4,"5":6,"6":8,"7":12}},{"name":"stopFrames","defaultValue":10,"minValue":0,"maxValue":80,"step":5,"descriptiveName":"wait <span data-microtip-size='large'aria-label='The objects on the path will wait that amount of time, if an object reaches the path´s end.'data-microtip-position='top-left' role='tooltip' class='songInputInfo'><img src='images/icons/info.svg' alt='info' width='16' height='16'>"},{"name":"movementDirection","formElement":"toggle","defaultValue":"forwards","options":[{"true":"forwards"},{"false":"backwards"}]}],"directions":["top","right"],"descriptiveName":"Path","description":"<div>Draw paths, put objects on top and the objects will follow them. Click on an already set path-point to adjust the path's attributes.<div class='subSection'><details><summary>Compatible objects</summary><div class='marginTop8'><ul style='padding-left: 16px'><li>Finish flag</li><li>Spikes</li><li>Trampolines</li><li>Toggle mine</li><li>Rocket launchers</li><li>Portals</li><li>Collectibles</li></ul></div></details><details class='marginTop8'><summary>Rules</summary><div class='marginTop8'><ul style='padding-left: 16px'><li>Draw paths in a line or in an enclosed 'circle'</li><li>Place as many different objects on them as you want</li><li>You can't draw 2 paths above or beside each other. You need to leave 1 free space inbetween</li></ul></div></details></div></div>","type":"objects","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["FFFFFF","FFFFFF","transp","FFFFFF","FFFFFF","transp","FFFFFF","FFFFFF"],["1C1C1C","1C1C1C","transp","1C1C1C","1C1C1C","transp","1C1C1C","1C1C1C"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["PLAYER_IDLE_SPRITE"] = {"name":"playerIdle","descriptiveName":"Player idle","description":"The player sprite that is shown when you are not moving.","directions":["right","left"],"animation":[{"sprite":[["transp","transp","transp","55AAFF","55AAFF","55AAFF","transp","transp"],["transp","transp","55AAFF","55AAFF","55AAFF","55AAFF","55AAFF","transp"],["transp","55AAFF","55AAFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","55AAFF","55AAFF","FFFF55","E30000","FFFF55","E30000","transp"],["transp","transp","55AAFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","E37100","transp","transp","E37100","transp","transp"]]}]};SpritePixelArrays["PLAYER_JUMP_SPRITE"] = {"name":"playerJump","descriptiveName":"Player jump","description":"The player sprite that is shown when you are jumping.<br/><span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 1'} }, true)\">Jump SFX</span> will be displayed underneath.","squishAble":true,"directions":["right","left"],"animation":[{"sprite":[["transp","transp","transp","1C8EFF","1C8EFF","1C8EFF","transp","transp"],["transp","transp","1C8EFF","1C8EFF","1C8EFF","1C8EFF","1C8EFF","transp"],["transp","1C8EFF","1C8EFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","1C8EFF","1C8EFF","FFFF1C","E30000","FFFF1C","E30000","transp"],["transp","transp","1C8EFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["PLAYER_WALL_JUMP_SPRITE"] = {"descriptiveName":"Player wall jump","description":"The player sprite that is shown when you are jumping.","squishAble":false,"directions":["right","left"],"animation":[{"sprite":[["transp","transp","4080BF","4080BF","4080BF","4080BF","transp","4080BF"],["transp","4080BF","4080BF","4080BF","4080BF","4080BF","4080BF","transp"],["transp","transp","EABFBF","FFFFFF","80552B","EABFBF","80552B","transp"],["transp","transp","EABFBF","EABFBF","EABFBF","EABFBF","EABFBF","transp"],["transp","EABFBF","BF4040","BF4040","BF4040","BF4040","EABFBF","transp"],["transp","transp","transp","BF4040","BF4040","FFAA55","transp","transp"],["transp","transp","FFAA55","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["PLAYER_WALK_SPRITE"] = {"name":"playerWalk","descriptiveName":"Player walk","description":"The player sprite that is shown when you are running.","directions":["right","left"],"animation":[{"sprite":[["transp","transp","transp","1C8EFF","1C8EFF","1C8EFF","transp","transp"],["transp","transp","1C8EFF","1C8EFF","1C8EFF","1C8EFF","1C8EFF","transp"],["transp","1C8EFF","1C8EFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","1C8EFF","1C8EFF","FFFF1C","E30000","FFFF1C","E30000","transp"],["transp","transp","1C8EFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","transp","transp","transp","E37100","transp","transp"]]},{"sprite":[["transp","transp","transp","1C8EFF","1C8EFF","1C8EFF","transp","transp"],["transp","transp","1C8EFF","1C8EFF","1C8EFF","1C8EFF","1C8EFF","transp"],["transp","1C8EFF","1C8EFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","1C8EFF","1C8EFF","FFFF1C","E30000","FFFF1C","E30000","transp"],["transp","transp","1C8EFF","FFFF1C","FFFF1C","FFFF1C","FFFF1C","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","E37100","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["CANON_BALL_SPRITE"] = {"name":"canonBall","descriptiveName":"Cannon ball","directions":["left","top","right","bottom"],"description":"A cannonball. The <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Cannon'} }, true)\">cannon</span> shoots it. <br/>When it hits a wall, <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 2'} }, true)\">explosion</span> will be displayed.","animation":[{"sprite":[["transp","transp","FFFFFF","FFFFFF","FFFFFF","FFFFFF","transp","transp"],["transp","FFFFFF","ff5e7a","ff5e7a","ff5e7a","ff5e7a","FFFFFF","transp"],["FFFFFF","ff5e7a","ff5e7a","ff5e7a","FFFFFF","ff5e7a","ff5e7a","FFFFFF"],["FFFFFF","ff5e7a","ff5e7a","ff5e7a","ff5e7a","FFFFFF","ff5e7a","FFFFFF"],["FFFFFF","ff5e7a","ff5e7a","ff5e7a","ff5e7a","ff5e7a","ff5e7a","FFFFFF"],["FFFFFF","ff5e7a","ff5e7a","ff5e7a","ff5e7a","ff5e7a","ff5e7a","FFFFFF"],["transp","FFFFFF","ff5e7a","ff5e7a","ff5e7a","ff5e7a","FFFFFF","transp"],["transp","transp","FFFFFF","FFFFFF","FFFFFF","FFFFFF","transp","transp"]]}]};SpritePixelArrays["STOMPER"] = {"name":"stomper","type":"objects","descriptiveName":"Stomper","squishAble":false,"directions":["bottom","left","top","right"],"description":"A deadly hazard, that will fly torwards the player, if he is in it's way and move back to it's initial place once it hits a solid block. Can be rotated by clicking on a placed object again.","animation":[{"sprite":[["AAAAAA","AAAAAA","transp","AAAAAA","AAAAAA","transp","AAAAAA","AAAAAA"],["AAAAAA","717171","transp","717171","717171","transp","717171","AAAAAA"],["transp","transp","AAAAAA","AAAAAA","AAAAAA","AAAAAA","transp","transp"],["AAAAAA","717171","FFFFFF","AAAAAA","AAAAAA","FFFFFF","717171","AAAAAA"],["AAAAAA","717171","FF1C1C","AAAAAA","AAAAAA","FF1C1C","717171","AAAAAA"],["transp","transp","AAAAAA","AAAAAA","AAAAAA","AAAAAA","transp","transp"],["AAAAAA","717171","transp","717171","717171","transp","717171","AAAAAA"],["AAAAAA","AAAAAA","transp","AAAAAA","AAAAAA","transp","AAAAAA","AAAAAA"]]}]};SpritePixelArrays["TOGGLE_MINE"] = {"name":"toggleMine","type":"objects","descriptiveName":"Toggle mine","description":"An object that is harmless at first, but once you step in and out of it, it becomes deadly.","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","C6C6C6","C6C6C6","transp","transp","transp"],["transp","transp","C6C6C6","transp","transp","C6C6C6","transp","transp"],["transp","C6C6C6","transp","transp","transp","transp","C6C6C6","transp"],["transp","C6C6C6","transp","transp","transp","transp","C6C6C6","transp"],["transp","transp","C6C6C6","transp","transp","C6C6C6","transp","transp"],["transp","transp","transp","C6C6C6","C6C6C6","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","FF1C1C","FF1C1C","transp","transp","transp"],["transp","transp","FF1C1C","transp","transp","FF1C1C","transp","transp"],["transp","FF1C1C","transp","transp","transp","transp","FF1C1C","transp"],["FF1C1C","transp","FFFFFF","transp","transp","FFFFFF","transp","FF1C1C"],["FF1C1C","transp","transp","transp","transp","transp","transp","FF1C1C"],["transp","FF1C1C","transp","transp","transp","transp","FF1C1C","transp"],["transp","transp","FF1C1C","transp","transp","FF1C1C","transp","transp"],["transp","transp","transp","FF1C1C","FF1C1C","transp","transp","transp"]]}]};SpritePixelArrays["ROCKET_LAUNCHER"] = {"name":"rocketLauncher","type":"objects","descriptiveName":"Rocket launcher","changeableAttributes":[{"name":"speed","defaultValue":3,"minValue":1,"maxValue":10},{"name":"frequency","defaultValue":3,"minValue":1,"maxValue":8},{"name":"rotationSpeed","defaultValue":8,"minValue":0,"maxValue":24,"descriptiveName":"rotation speed <span data-microtip-size='large'aria-label='Determines how fast the rockets will rotate to the players direction. 0 = rockets will decide direction once and not turn at all. 24 = basically following the player everywhere.'data-microtip-position='top-left' role='tooltip' class='songInputInfo'><img src='images/icons/info.svg' alt='info' width='16' height='16'>"}],"squishAble":false,"rotateable":true,"description":"A rocket-launcher. It shoots <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Rocket'} }, true)\">rockets</span> at certain time intervals that will follow the player. Click on it after placing it again, to change the attributes of the individual cannon.","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","AAAAAA","AAAAAA","transp","transp"],["AAAAAA","AAAAAA","FF1C1C","FF1C1C","AAAAAA","AAAAAA","717171","transp"],["AAAAAA","AAAAAA","AAAAAA","AAAAAA","AAAAAA","AAAAAA","717171","717171"],["FFFFFF","FFFFFF","FFFFFF","FFFFFF","FFFFFF","FFFFFF","717171","717171"],["FFFFFF","FFFFFF","FF1C1C","FF1C1C","FFFFFF","FFFFFF","717171","transp"],["transp","transp","transp","transp","FFFFFF","FFFFFF","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["ROCKET"] = {"name":"rocket","descriptiveName":"Rocket","description":"A rocket. The <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Rocket launcher'} }, true)\">rocket launcher</span> shoots it.<br/>When it hits a wall, <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 2'} }, true)\">explosion</span> will be displayed.","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","FFFFFF","transp","transp"],["transp","transp","transp","transp","FFFFFF","FFFFFF","transp","transp"],["FF1C1C","FF1C1C","FFFFFF","FFFFFF","FFFFFF","FFFFFF","FFFF8E","FF8E1C"],["FF1C1C","FF1C1C","AAAAAA","AAAAAA","AAAAAA","AAAAAA","FFFF8E","FF8E1C"],["transp","transp","transp","transp","AAAAAA","AAAAAA","transp","transp"],["transp","transp","transp","transp","transp","AAAAAA","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","FFFFFF","transp","transp"],["transp","transp","transp","transp","FFFFFF","FFFFFF","transp","transp"],["FF1C1C","FF1C1C","FFFFFF","FFFFFF","FFFFFF","FFFFFF","transp","FF8E1C"],["FF1C1C","FF1C1C","AAAAAA","AAAAAA","AAAAAA","AAAAAA","transp","FF8E1C"],["transp","transp","transp","transp","AAAAAA","AAAAAA","transp","transp"],["transp","transp","transp","transp","transp","AAAAAA","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["PORTAL2"] = {"name":"portal2","type":"objects","descriptiveName":"Portal 2","description":"<b>First Sprite:</b> <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Portal'} }, true)\">Here</span><br/><br/>A portal with 2 exits. <br/>Just draw 2 portals on the game screen. The odd one will automatically be the first, the even one the second.","squishAble":false,"hiddenSprite":true,"animation":[{"sprite":[["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","E37100","E37100","E37100","E37100","transp","transp"],["transp","E37100","E37100","FFAA55","FFAA55","E37100","E37100","transp"],["FFFFFF","E37100","FFAA55","FFC68E","FFC68E","FFAA55","E37100","FFFFFF"],["FFFFFF","E37100","FFAA55","FFC68E","FFC68E","FFAA55","E37100","FFFFFF"],["transp","E37100","E37100","FFAA55","FFAA55","E37100","E37100","transp"],["transp","transp","E37100","E37100","E37100","E37100","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"]]}]};SpritePixelArrays["PORTAL"] = {"name":"portal","type":"objects","descriptiveName":"Portal","squishAble":false,"description":"<b>Second Sprite:</b> <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Portal 2'} }, true)\">Here</span><br/><br/>A portal with 2 exits. <br/>Just draw 2 portals on the game screen. The odd one will automatically be the first, the even one the second.","animation":[{"sprite":[["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","0071E3","0071E3","0071E3","0071E3","transp","transp"],["transp","0071E3","0071E3","55AAFF","55AAFF","0071E3","0071E3","transp"],["FFFFFF","0071E3","55AAFF","8EC6FF","8EC6FF","55AAFF","0071E3","FFFFFF"],["FFFFFF","0071E3","55AAFF","8EC6FF","8EC6FF","55AAFF","0071E3","FFFFFF"],["transp","0071E3","0071E3","55AAFF","55AAFF","0071E3","0071E3","transp"],["transp","transp","0071E3","0071E3","0071E3","0071E3","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"]]}]};SpritePixelArrays["COLLECTIBLE"] = {"name":"collectible","type":"objects","descriptiveName":"Collectible","description":"They can be placed to give the player an additional challenge. <br/> Inside the tool, the collectibles will reappear if you die or reset the level, in the exported game they are gone forever, once <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'SFX 4'} }, true)\">collected</span>.","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","FFFFC6","FFFF8E","FFFF8E","FFFF55","transp","transp"],["transp","transp","FFFFC6","FFFF8E","FFFF8E","FFFF55","transp","transp"],["transp","transp","FFFFC6","FFFF8E","FFFF8E","FFFF55","transp","transp"],["transp","transp","FFFFC6","FFFF8E","FFFF8E","FFFF55","transp","transp"],["transp","transp","transp","FFFF55","FFFF55","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFFC6","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFF55","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFF55","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFF55","transp","transp","transp"],["transp","transp","transp","FFFFC6","FFFF55","transp","transp","transp"],["transp","transp","transp","FFFF55","FFFF55","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["SFX1"] = {"name":"sfx","directions":["bottom","left","top","right"],"descriptiveName":"SFX 1","description":"SFX that shows when the <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Player jump'} }, true)\">player jumps</span>.","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"]]}]};SpritePixelArrays["SFX2"] = {"name":"sfx","descriptiveName":"SFX 2","description":"SFX when <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Cannon ball'} }, true)\">cannon ball</span> or <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Rocket'} }, true)\">rocket</span> hit a wall.","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["SFX3"] = {"name":"sfx","descriptiveName":"SFX 3","description":"SFX when player dashes","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","393939","393939","transp","transp","transp"],["transp","transp","transp","393939","393939","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","393939","transp","transp","393939","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","393939","transp","transp","393939","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["SFX4"] = {"name":"sfx","descriptiveName":"Build SFX","hiddenEverywhere":true,"description":"SFX when an object is placed in build mode","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","FFFFFF","FFFFFF","FFFFFF","FFFFFF","FFFFFF","FFFFFF","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","FFFFFF","FFFFFF","FFFFFF","FFFFFF","FFFFFF","FFFFFF","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["SFX5"] = {"name":"sfx","descriptiveName":"SFX 4","description":"Plays when the player touches a <span class='textAsLink' onclick=\"DrawSectionHandler.changeSelectedSprite({ target: { value:  'Collectible'} }, true)\">collectible</span>.","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","transp","transp","FFFFFF","FFFFFF","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]},{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","FFFFFF","transp","transp","transp","transp","FFFFFF","transp"],["transp","transp","FFFFFF","transp","transp","FFFFFF","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};SpritePixelArrays["SFX6"] = {"name":"sfx","descriptiveName":"SFX 5","description":"Used for shaders","animation":[{"sprite":[["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","CC66E3","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"],["transp","transp","transp","transp","transp","transp","transp","transp"]]}]};
  player.setAnimationProperties();
  //changedSpritesEnd
        //changedPlayerAttributesStart
  player["groundAcceleration"] = 0.8;player["air_acceleration"] = 0.8;player["maxSpeed"] = 2;player["groundFriction"] = 0.36;player["air_friction"] = 0.63;player["jumpSpeed"] = 0.33;player["maxJumpFrames"] = 18;player["maxJumpFrames"] = 18;player["jumpChecked"] = true;player["wallJumpChecked"] = true;player["dashChecked"] = true;player["runChecked"] = false;
  //changedPlayerAttributesEnd
        //musicCommentStart
    SoundHandler.song = new Sound("https://dl.dropbox.com/s/oohi6502s84hzek/viraxor%20-%20protonami%20theme.ogg", "mainSong", true);//music here
    //musicCommentEnd
        let startLevel = 0;
        
        const canvasSize = WorldDataHandler.calucalteCanvasSize();
        canvas.width = canvasSize.width;
        canvas.height = canvasSize.height;
        const canvasWidth = canvasSize.width;
        const canvasHeight = canvasSize.height;
        canvas.style.backgroundColor = WorldDataHandler.backgroundColor;
        var canvasOffsetLeft = canvas.offsetLeft;
        var canvasOffsetTop = canvas.offsetTop;
        const ctx = canvas.getContext("2d");

        Camera.staticConstructor(ctx, canvasSize.width, canvasHeight, WorldDataHandler.levels[startLevel].tileData[0].length * WorldDataHandler.tileSize,
            WorldDataHandler.levels[startLevel].tileData.length * WorldDataHandler.tileSize);
        let tileMapHandler = new TileMapHandler(WorldDataHandler.tileSize, startLevel, spriteCanvas, player);
        DialogueHandler.staticConstructor(tileMapHandler);
        Display.staticConstructor(ctx, canvasWidth, canvasHeight);
        Controller.staticConstructor();
        Collision.staticConstructor(tileMapHandler);
        const spriteSheetCreator = new SpriteSheetCreator(tileMapHandler, spriteCanvas);
        CharacterCollision.staticConstructor(tileMapHandler);
        PlayMode.staticConstructor(player, tileMapHandler);
        SFXHandler.staticConstructor(tileMapHandler.tileSize, spriteCanvas);
        GameStatistics.staticConstructor();
        PauseHandler.staticConstructor();
        EffectsHandler.staticConstructor();

        

        function play() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            Camera.begin();
            tileMapHandler.displayLevel();
            if (tileMapHandler.currentLevel === 0) {
                Controller.handleGamepadInput();
                PlayMode.runStartScreenLogic();
                Display.displayStartScreen(tileMapHandler.currentGeneralFrameCounter, tileMapHandler.generalFrameCounterMax);
            }
            else if (tileMapHandler.currentLevel === WorldDataHandler.levels.length - 1) {
                Display.displayEndingScreen(spriteCanvas, tileMapHandler.currentGeneralFrameCounter, tileMapHandler.generalFrameCounterMax);
            }
            else {
                Controller.handleGamepadInput();
                PlayMode.runPlayLogic();
                SFXHandler.updateSfxAnimations();
                player.draw();
                DialogueHandler.handleDialogue();
                Camera.followObject(player.x, player.y);
                PlayMode.pauseFramesHandler();
            }
            
            Camera.end();
            if (Game.playMode === Game.PLAY_MODE) {
                window.requestAnimationFrame(play);
            }
        }

        function loading() {
            let loadedAssets = 0;
            SoundHandler.sounds.forEach(soundRawData => {
                const sound = SoundHandler[soundRawData.key];
                if (sound.loaded || sound.errorWhileLoading) {
                    loadedAssets++;
                }
            })
            if (loadedAssets === SoundHandler.sounds.length) {
                WorldDataHandler.insideTool ? Game.changeGameMode() : Game.executeGameMode();
            }
            else {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                Display.displayLoadingScreen(loadedAssets, SoundHandler.sounds.length);
                window.requestAnimationFrame(loading);
            }
        }

        window.requestAnimationFrame(loading);
    </script></body>
